class IterativeDeepeningAlphaBetaSearch
!!!147074.java!!!	createFor(inout game : Game, in utilMin : double, in utilMax : double, in time : int) : IterativeDeepeningAlphaBetaSearch
        return new IterativeDeepeningAlphaBetaSearch<>(game, utilMin, utilMax, time);
!!!147202.java!!!	IterativeDeepeningAlphaBetaSearch(inout game : Game, in utilMin : double, in utilMax : double, in time : int)
        this.game = game;
        this.utilMin = utilMin;
        this.utilMax = utilMax;
        this.timer = new Timer(time);
!!!147330.java!!!	setLogEnabled(inout b : boolean) : void
        logEnabled = b;
!!!147458.java!!!	makeDecision(inout state : S) : A
        metrics = new Metrics();
        StringBuffer logText = null;
        P player = game.getPlayer(state);
        List<A> results = orderActions(state, game.getActions(state), player, 0);
        timer.start();
        currDepthLimit = 0;
        do {
            incrementDepthLimit();
            if (logEnabled)
                logText = new StringBuffer("depth " + currDepthLimit + ": ");
            heuristicEvaluationUsed = false;
            ActionStore<A> newResults = new ActionStore<>();
            for (A action : results) {
                double value = minValue(game.getResult(state, action), player, Double.NEGATIVE_INFINITY,
                        Double.POSITIVE_INFINITY, 1);
                if (timer.timeOutOccurred())
                    break; // exit from action loop
                newResults.add(action, value);
                if (logEnabled)
                    logText.append(action).append("->").append(value).append(" ");
            }
            if (logEnabled)
                System.out.println(logText);
            if (newResults.size() > 0) {
                results = newResults.actions;
                if (!timer.timeOutOccurred()) {
                    if (hasSafeWinner(newResults.utilValues.get(0)))
                        break; // exit from iterative deepening loop
                    else if (newResults.size() > 1
                            && isSignificantlyBetter(newResults.utilValues.get(0), newResults.utilValues.get(1)))
                        break; // exit from iterative deepening loop
                }
            }
        } while (!timer.timeOutOccurred() && heuristicEvaluationUsed);
        return results.get(0);
!!!147586.java!!!	maxValue(inout state : S, inout player : P, in alpha : double, in beta : double, in depth : int) : double
        updateMetrics(depth);
        if (game.isTerminal(state) || depth >= currDepthLimit || timer.timeOutOccurred()) {
            return eval(state, player);
        } else {
            double value = Double.NEGATIVE_INFINITY;
            for (A action : orderActions(state, game.getActions(state), player, depth)) {
                value = Math.max(value, minValue(game.getResult(state, action), //
                        player, alpha, beta, depth + 1));
                if (value >= beta)
                    return value;
                alpha = Math.max(alpha, value);
            }
            return value;
        }
!!!147714.java!!!	minValue(inout state : S, inout player : P, in alpha : double, in beta : double, in depth : int) : double
        updateMetrics(depth);
        if (game.isTerminal(state) || depth >= currDepthLimit || timer.timeOutOccurred()) {
            return eval(state, player);
        } else {
            double value = Double.POSITIVE_INFINITY;
            for (A action : orderActions(state, game.getActions(state), player, depth)) {
                value = Math.min(value, maxValue(game.getResult(state, action), //
                        player, alpha, beta, depth + 1));
                if (value <= alpha)
                    return value;
                beta = Math.min(beta, value);
            }
            return value;
        }
!!!147842.java!!!	updateMetrics(in depth : int) : void
        metrics.incrementInt(METRICS_NODES_EXPANDED);
        metrics.set(METRICS_MAX_DEPTH, Math.max(metrics.getInt(METRICS_MAX_DEPTH), depth));
!!!147970.java!!!	getMetrics() : Metrics
        return metrics;
!!!148098.java!!!	incrementDepthLimit() : void
        currDepthLimit++;
!!!148226.java!!!	isSignificantlyBetter(in newUtility : double, in utility : double) : boolean
        return false;
!!!148354.java!!!	hasSafeWinner(in resultUtility : double) : boolean
        return resultUtility <= utilMin || resultUtility >= utilMax;
!!!148482.java!!!	eval(inout state : S, inout player : P) : double
        if (game.isTerminal(state)) {
            return game.getUtility(state, player);
        } else {
            heuristicEvaluationUsed = true;
            return (utilMin + utilMax) / 2;
        }
!!!148610.java!!!	orderActions(inout state : S, inout actions : List<A>, inout player : P, in depth : int) : List<A>
        return actions;
