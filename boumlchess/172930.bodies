class PLLexer
!!!373890.java!!!	PLLexer(in inputString : String)
		setInput(inputString);
!!!374018.java!!!	nextToken() : Token
		int startPosition = getCurrentPositionInInput();
		if (lookAhead(1) == '(') {
			consume();
			return new Token(LogicTokenTypes.LPAREN, "(", startPosition);
		} else if (lookAhead(1) == '[') {
				consume();
				return new Token(LogicTokenTypes.LSQRBRACKET, "[", startPosition);
		} else if (lookAhead(1) == ')') {
			consume();
			return new Token(LogicTokenTypes.RPAREN, ")", startPosition);
		} else if (lookAhead(1) == ']') {
			consume();
			return new Token(LogicTokenTypes.RSQRBRACKET, "]", startPosition);
		} else if (Character.isWhitespace(lookAhead(1))) {
			consume();
			return nextToken();
		} else if (connectiveDetected(lookAhead(1))) {
			return connective();
		} else if (symbolDetected(lookAhead(1))) {
			return symbol();
		} else if (lookAhead(1) == (char) -1) {
			return new Token(LogicTokenTypes.EOI, "EOI", startPosition);
		} else {
			throw new LexerException("Lexing error on character " + lookAhead(1) + " at position " + getCurrentPositionInInput(), getCurrentPositionInInput());
		}
!!!374146.java!!!	connectiveDetected(in leadingChar : char) : boolean
		return Connective.isConnectiveIdentifierStart(leadingChar);
!!!374274.java!!!	symbolDetected(in leadingChar : char) : boolean
		return PropositionSymbol.isPropositionSymbolIdentifierStart(leadingChar);
!!!374402.java!!!	connective() : Token
		int startPosition = getCurrentPositionInInput();
		StringBuffer sbuf = new StringBuffer();
		// Ensure pull out just one connective at a time, the isConnective(...)
		// test ensures we handle chained expressions like the following:
		// ~~P
		while (Connective.isConnectiveIdentifierPart(lookAhead(1)) && !isConnective(sbuf.toString())) {
			sbuf.append(lookAhead(1));
			consume();
		}
		
		String symbol = sbuf.toString();
		if (isConnective(symbol)) {
			return new Token(LogicTokenTypes.CONNECTIVE, sbuf.toString(), startPosition);
		}
		
		throw new LexerException("Lexing error on connective "+symbol + " at position " + getCurrentPositionInInput(), getCurrentPositionInInput());
!!!374530.java!!!	symbol() : Token
		int startPosition = getCurrentPositionInInput();
		StringBuffer sbuf = new StringBuffer();
		while (PropositionSymbol.isPropositionSymbolIdentifierPart(lookAhead(1))) {
			sbuf.append(lookAhead(1));
			consume();
		}
		String symbol = sbuf.toString();
		if (PropositionSymbol.isAlwaysTrueSymbol(symbol)) {
			return new Token(LogicTokenTypes.TRUE, PropositionSymbol.TRUE_SYMBOL, startPosition);
		} else if (PropositionSymbol.isAlwaysFalseSymbol(symbol)) {
			return new Token(LogicTokenTypes.FALSE, PropositionSymbol.FALSE_SYMBOL, startPosition);
		} else if (PropositionSymbol.isPropositionSymbol(symbol)){
			return new Token(LogicTokenTypes.SYMBOL, sbuf.toString(), startPosition);
		}
		
		throw new LexerException("Lexing error on symbol "+symbol+ " at position "+ getCurrentPositionInInput(), getCurrentPositionInInput());
!!!374658.java!!!	isConnective(in aSymbol : String) : boolean
		return Connective.isConnective(aSymbol);
