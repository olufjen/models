class EfficientHybridWumpusAgent
!!!191490.java!!!	EfficientHybridWumpusAgent(in caveXDim : int, in caveYDim : int, inout start : AgentPosition)
        this(caveXDim, caveYDim, start, new DPLLSatisfiable(), null);
!!!191618.java!!!	EfficientHybridWumpusAgent(in caveXDim : int, in caveYDim : int, inout start : AgentPosition, inout satSolver : DPLL, inout notifier : EnvironmentViewNotifier)
        this(caveXDim, caveYDim, start, new WumpusKnowledgeBase(caveXDim, caveYDim, start, satSolver), notifier);
!!!191746.java!!!	EfficientHybridWumpusAgent(in caveXDim : int, in caveYDim : int, inout start : AgentPosition, inout kb : WumpusKnowledgeBase, inout notifier : EnvironmentViewNotifier)
        super(caveXDim, caveYDim, start, kb, notifier);
        getKB().disableNavSentences(); // Optimization: Verbosity of produced sentences is reduced.
        modelCave = new WumpusCave(caveXDim, caveYDim);
        visitedRooms.add(currentPosition.getRoom());
!!!191874.java!!!	execute(inout percept : Percept) : Action

        // TELL(KB, MAKE-PERCEPT-SENTENCE(percept, t))
        getKB().makePerceptSentence((WumpusPercept) percept, t);
        // TELL the KB the temporal "physics" sentences for time t
        // Optimization: The agent is aware of it's position - the KB can profit from that!
        getKB().tellTemporalPhysicsSentences(t, currentPosition);

        Set<Room> safe = null;
        Set<Room> unvisited = null;

        // Optimization: Do not ask anything during plan execution (different from pseudo-code)
        if (plan.isEmpty()) {
            notifyViews("Reasoning (t=" + t + ", Percept=" + percept + ", Pos=" + currentPosition + ") ...");
            // safe <- {[x, y] : ASK(KB, OK<sup>t</sup><sub>x,y</sub>) = true}
            safe = getKB().askSafeRooms(t, visitedRooms);
            notifyViews("Ask safe -> " + safe);
        }

        // if ASK(KB, Glitter<sup>t</sup>) = true then
        // Optimization: Use percept (condition can only be true if plan is empty).
        if (plan.isEmpty() && ((WumpusPercept) percept).isGlitter()) {
            // plan <- [Grab] + PLAN-ROUTE(current, {[1,1]}, safe) + [Climb]
            Set<Room> goals = new LinkedHashSet<>();
            goals.add(modelCave.getStart().getRoom());
            plan.add(WumpusAction.GRAB);
            plan.addAll(planRouteToRooms(goals, safe));
            plan.add(WumpusAction.CLIMB);
        }

        // if plan is empty then
        if (plan.isEmpty()) {
            // unvisited <- {[x, y] : ASK(KB, L<sup>t'</sup><sub>x,y</sub>) = false for all t' &le; t}
            // Optimization: Agent remembers visited locations, no need to ask.
            unvisited = SetOps.difference(modelCave.getAllRooms(), visitedRooms);
            // plan <- PLAN-ROUTE(current, unvisited &cap; safe, safe)
            plan.addAll(planRouteToRooms(unvisited, safe));
        }

        // if plan is empty and ASK(KB, HaveArrow<sup>t</sup>) = true then
        if (plan.isEmpty() && getKB().askHaveArrow(t)) {
            // possible_wumpus <- {[x, y] : ASK(KB, ~W<sub>x,y</sub>) = false}
            Set<Room> possibleWumpus = getKB().askPossibleWumpusRooms(t);
            notifyViews("Ask possible Wumpus positions -> " + possibleWumpus);
            // plan <- PLAN-SHOT(current, possible_wumpus, safe)
            plan.addAll(planShot(possibleWumpus, safe));
        }

        // if plan is empty then //no choice but to take a risk
        if (plan.isEmpty()) {
            // not_unsafe <- {[x, y] : ASK(KB, ~OK<sup>t</sup><sub>x,y</sub>) = false}
            // Optimization: Do not check visited rooms again.
            Set<Room> notUnsafe = getKB().askNotUnsafeRooms(t, visitedRooms);
            notifyViews("Ask not unsafe -> " + notUnsafe);
            // plan <- PLAN-ROUTE(current, unvisited &cap; not_unsafe, safe)
            // Correction: Last argument must be not_unsafe!
            plan.addAll(planRouteToRooms(unvisited, notUnsafe));
        }

        // if plan is empty then
        if (plan.isEmpty()) {
            notifyViews("Going home.");
            // plan PLAN-ROUTE(current, {[1,1]}, safe) + [Climb]
            Set<Room> goal = new LinkedHashSet<>();
            goal.add(modelCave.getStart().getRoom());
            plan.addAll(planRouteToRooms(goal, safe));
            plan.add(WumpusAction.CLIMB);
        }
        // action <- POP(plan)
        WumpusAction action = plan.remove();
        // TELL(KB, MAKE-ACTION-SENTENCE(action, t))
        getKB().makeActionSentence(action, t);
        // t <- t+1
        t = t + 1;
        updateAgentPosition(action);
        visitedRooms.add(currentPosition.getRoom());
        // return action
        return action;
!!!192002.java!!!	planRoute(inout goals : Set<AgentPosition>, inout allowed : Set<Room>) : WumpusAction
        modelCave.setAllowed(allowed);
        Problem<AgentPosition, WumpusAction> problem = new GeneralProblem<>(currentPosition,
                WumpusFunctions.createActionsFunction(modelCave),
                WumpusFunctions.createResultFunction(modelCave), goals::contains);
        SearchForActions<AgentPosition, WumpusAction> search =
                new AStarSearch<>(new GraphSearch<>(), new ManhattanHeuristicFunction(goals));
        Optional<List<WumpusAction>> actions = search.findActions(problem);

        return actions.orElse(Collections.emptyList());
!!!192130.java!!!	updateAgentPosition(inout action : WumpusAction) : void
        modelCave.setAllowed(modelCave.getAllRooms());
        switch (action) {
            case FORWARD:
                currentPosition = modelCave.moveForward(currentPosition);
                break;
            case TURN_LEFT:
                currentPosition = modelCave.turnLeft(currentPosition);
                break;
            case TURN_RIGHT:
                currentPosition = modelCave.turnRight(currentPosition);
                break;
        }
