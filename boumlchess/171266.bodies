class OptimizedDPLL
!!!360450.java!!!	dpllSatisfiable(inout s : Sentence) : boolean
		// clauses <- the set of clauses in the CNF representation of s
		Set<Clause> clauses = ConvertToConjunctionOfClauses.convert(s)
				.getClauses();
		// symbols <- a list of the proposition symbols in s
		List<PropositionSymbol> symbols = getPropositionSymbolsInSentence(s);

		// return DPLL(clauses, symbols, {})
		return dpll(clauses, symbols, new Model());
!!!360578.java!!!	dpll(inout clauses : Set<Clause>, inout symbols : List<PropositionSymbol>, inout model : Model) : boolean
		// if every clause in clauses is true in model then return true
		// if some clause in clauses is false in model then return false
		// NOTE: for optimization reasons we only want to determine the
		// values of clauses once on each call to dpll
		boolean allTrue = true;			
		Set<Clause> unknownClauses = new LinkedHashSet<>();
		for (Clause c : clauses) {
			Boolean value = model.determineValue(c);
			if (!Boolean.TRUE.equals(value)) {
				allTrue = false;
				if (Boolean.FALSE.equals(value)) {					
					return false;
				}				
				unknownClauses.add(c);
			}
		}
		if (allTrue) {
			return true;
		} else if (Tasks.currIsCancelled())
			return false;
		
		// NOTE: Performance Optimization -
		// Going forward, algorithm can ignore clauses that are already 
		// known to be true (reduces overhead on recursive calls and simplifies
		// findPureSymbols() and findUnitClauses() logic as they can
		// always assume unknown).
		clauses = unknownClauses;

		// P, value <- FIND-PURE-SYMBOL(symbols, clauses, model)
		Pair<PropositionSymbol, Boolean> pAndValue = findPureSymbol(symbols,
				clauses, model);
		// if P is non-null then
		if (pAndValue != null) {
			// return DPLL(clauses, symbols - P, model U {P = value})
			return callDPLL(clauses, minus(symbols, pAndValue.getFirst()), model, 
					pAndValue.getFirst(), pAndValue.getSecond()); 
		}

		// P, value <- FIND-UNIT-CLAUSE(clauses, model)
		pAndValue = findUnitClause(clauses, model);
		// if P is non-null then
		if (pAndValue != null) {
			// return DPLL(clauses, symbols - P, model U {P = value})
			return callDPLL(clauses, minus(symbols, pAndValue.getFirst()), model, 
					pAndValue.getFirst(), pAndValue.getSecond());
		}

		// P <- FIRST(symbols); rest <- REST(symbols)
		PropositionSymbol p = Util.first(symbols);
		List<PropositionSymbol> rest = Util.rest(symbols);
		// return DPLL(clauses, rest, model U {P = true}) or
		// ...... DPLL(clauses, rest, model U {P = false})
		return callDPLL(clauses, rest, model, p, true)
				|| callDPLL(clauses, rest, model, p, false);
!!!360706.java!!!	isEntailed(inout kb : KnowledgeBase, inout alpha : Sentence) : boolean
		// AIMA3e p.g. 260: kb |= alpha, can be done by testing
		// unsatisfiability of kb & ~alpha.
		Set<Clause>             kbAndNotAlpha = new LinkedHashSet<>();
		Sentence                notQuery      = new ComplexSentence(Connective.NOT, alpha);
		Set<PropositionSymbol>  symbols       = new LinkedHashSet<>();
		List<PropositionSymbol> querySymbols  = new ArrayList<>(SymbolCollector.getSymbolsFrom(notQuery));
		
		kbAndNotAlpha.addAll(kb.asCNF());
		kbAndNotAlpha.addAll(ConvertToConjunctionOfClauses.convert(notQuery).getClauses());
		symbols.addAll(querySymbols);
		symbols.addAll(kb.getSymbols());

		return !dpll(kbAndNotAlpha, new ArrayList<>(symbols), new Model());
!!!360834.java!!!	getPropositionSymbolsInSentence(inout s : Sentence) : PropositionSymbol
		return new ArrayList<>(SymbolCollector.getSymbolsFrom(s));
!!!360962.java!!!	callDPLL(inout clauses : Set<Clause>, inout symbols : List<PropositionSymbol>, inout model : Model, inout p : PropositionSymbol, inout value : boolean) : boolean
		// We update the model in place with the assignment p=value,
		boolean result = dpll(clauses, symbols, model.unionInPlace(p, value));
		// as backtracking can occur during the recursive calls we
		// need to remove the assigned value before we pop back out from this
		// call.
		model.remove(p);
		return result;
!!!361090.java!!!	findPureSymbol(inout symbols : List<PropositionSymbol>, inout clauses : Set<Clause>, inout model : Model) : Pair
		Pair<PropositionSymbol, Boolean> result = null;

		Set<PropositionSymbol> symbolsToKeep = new HashSet<>(symbols);
		// Collect up possible positive and negative candidate sets of pure
		// symbols
		Set<PropositionSymbol> candidatePurePositiveSymbols = new HashSet<>();
		Set<PropositionSymbol> candidatePureNegativeSymbols = new HashSet<>();
		for (Clause c : clauses) {
			// Algorithm can ignore clauses that are already known to be true
			// NOTE: no longer need to do this here as we remove, true clauses
			// up front in the dpll call (as an optimization)

			// Collect possible candidates, removing all candidates that are
			// not part of the input list of symbols to be considered.
			for (PropositionSymbol p : c.getPositiveSymbols()) {
				if (symbolsToKeep.contains(p)) {
					candidatePurePositiveSymbols.add(p);
				}
			}
			for (PropositionSymbol n : c.getNegativeSymbols()) {
				if (symbolsToKeep.contains(n)) {
					candidatePureNegativeSymbols.add(n);
				}
			}
		}

		// Determine the overlap/intersection between the positive and negative
		// candidates
		for (PropositionSymbol s : symbolsToKeep) {
			// Remove the non-pure symbols
			if (candidatePurePositiveSymbols.contains(s) && candidatePureNegativeSymbols.contains(s)) {
				candidatePurePositiveSymbols.remove(s);
				candidatePureNegativeSymbols.remove(s);
			}
		}

		// We have an implicit preference for positive pure symbols
		if (candidatePurePositiveSymbols.size() > 0) {
			result = new Pair<>(candidatePurePositiveSymbols.iterator().next(), true);
		} // We have a negative pure symbol
		else if (candidatePureNegativeSymbols.size() > 0) {
			result = new Pair<PropositionSymbol, Boolean>(
					candidatePureNegativeSymbols.iterator().next(), false);
		}

		return result;
!!!361218.java!!!	findUnitClause(inout clauses : Set<Clause>, inout model : Model) : Pair
		Pair<PropositionSymbol, Boolean> result = null;

		for (Clause c : clauses) {
			// if clauses value is currently unknown
			// (i.e. means known literals are false)
			// NOTE: no longer need to perform this check
			// as only clauses with unknown values will
			// be passed to this routine from dpll as it
			// removes known ones up front.
			Literal unassigned = null;
			// Default definition of a unit clause is a clause
			// with just one literal
			if (c.isUnitClause()) {
				unassigned = c.getLiterals().iterator().next();
			} else {
				// Also, a unit clause in the context of DPLL, also means a
				// clauseF in which all literals but one are already
				// assigned false by the model.
				// Note: at this point we already know the clause is not
				// true, so just need to determine if the clause has a
				// single unassigned literal
				for (Literal l : c.getLiterals()) {
					Boolean value = model.getValue(l.getAtomicSentence());
					if (value == null) {
						// The first unassigned literal encountered.
						if (unassigned == null) {
							unassigned = l;
						} else {
							// This means we have more than 1 unassigned
							// literal so lets skip
							unassigned = null;
							break;
						}
					}
				}
			}

			// if a value assigned it means we have a single
			// unassigned literal and all the assigned literals
			// are not true under the current model as we were
			// unable to determine a value.
			if (unassigned != null) {
				result = new Pair<>(
						unassigned.getAtomicSentence(),
						unassigned.isPositiveLiteral());
				break;
			}
		}

		return result;
!!!361346.java!!!	minus(inout symbols : List<PropositionSymbol>, inout p : PropositionSymbol) : PropositionSymbol
		List<PropositionSymbol> result = new ArrayList<>(
				symbols.size());
		for (PropositionSymbol s : symbols) {
			// symbols - P
			if (!p.equals(s))
				result.add(s);
		}
		return result;
