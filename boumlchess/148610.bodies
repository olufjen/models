class Clause
!!!322818.java!!!	Clause()
		// i.e. the empty clause
!!!322946.java!!!	Clause(inout lits : List<Literal>)
		this.literals.addAll(lits);
		for (Literal l : literals) {
			if (l.isPositiveLiteral()) {
				this.positiveLiterals.add(l);
			} else {
				this.negativeLiterals.add(l);
			}
		}
		recalculateIdentity();
!!!323074.java!!!	Clause(inout lits1 : List<Literal>, inout lits2 : List<Literal>)
		literals.addAll(lits1);
		literals.addAll(lits2);
		for (Literal l : literals) {
			if (l.isPositiveLiteral()) {
				this.positiveLiterals.add(l);
			} else {
				this.negativeLiterals.add(l);
			}
		}
		recalculateIdentity();
!!!323202.java!!!	getProofStep() : ProofStep
		if (null == proofStep) {
			// Assume was a premise
			proofStep = new ProofStepPremise(this);
		}
		return proofStep;
!!!323330.java!!!	setProofStep(inout proofStep : ProofStep) : void
		this.proofStep = proofStep;
!!!323458.java!!!	isImmutable() : boolean
		return immutable;
!!!323586.java!!!	setImmutable() : void
		immutable = true;
!!!323714.java!!!	isStandardizedApartCheckRequired() : boolean
		return saCheckRequired;
!!!323842.java!!!	setStandardizedApartCheckNotRequired() : void
		saCheckRequired = false;
!!!323970.java!!!	isEmpty() : boolean
		return literals.size() == 0;
!!!324098.java!!!	isUnitClause() : boolean
		return literals.size() == 1;
!!!324226.java!!!	isDefiniteClause() : boolean
		// A Definite Clause is a disjunction of literals of which exactly 1 is
		// positive.
		return !isEmpty() && positiveLiterals.size() == 1;
!!!324354.java!!!	isImplicationDefiniteClause() : boolean
		// An Implication Definite Clause is a disjunction of literals of
		// which exactly 1 is positive and there is 1 or more negative
		// literals.
		return isDefiniteClause() && negativeLiterals.size() >= 1;
!!!324482.java!!!	isHornClause() : boolean
		// A Horn clause is a disjunction of literals of which at most one is
		// positive.
		return !isEmpty() && positiveLiterals.size() <= 1;
!!!324610.java!!!	isTautology() : boolean

		for (Literal pl : positiveLiterals) {
			// Literals in a clause must be exact complements
			// for tautology elimination to apply. Do not
			// remove non-identical literals just because
			// they are complements under unification, see pg16:
			// http://logic.stanford.edu/classes/cs157/2008/notes/chap09.pdf
			for (Literal nl : negativeLiterals) {
				if (pl.getAtomicSentence().equals(nl.getAtomicSentence())) {
					return true;
				}
			}
		}

		return false;
!!!324738.java!!!	addLiteral(inout literal : Literal) : void
		if (isImmutable()) {
			throw new IllegalStateException(
					"Clause is immutable, cannot be updated.");
		}
		int origSize = literals.size();
		literals.add(literal);
		if (literals.size() > origSize) {
			if (literal.isPositiveLiteral()) {
				positiveLiterals.add(literal);
			} else {
				negativeLiterals.add(literal);
			}
		}
		recalculateIdentity();
!!!324866.java!!!	addPositiveLiteral(inout atom : AtomicSentence) : void
		addLiteral(new Literal(atom));
!!!324994.java!!!	addNegativeLiteral(inout atom : AtomicSentence) : void
		addLiteral(new Literal(atom, true));
!!!325122.java!!!	getNumberLiterals() : int
		return literals.size();
!!!325250.java!!!	getNumberPositiveLiterals() : int
		return positiveLiterals.size();
!!!325378.java!!!	getNumberNegativeLiterals() : int
		return negativeLiterals.size();
!!!325506.java!!!	getLiterals() : Literal
		return Collections.unmodifiableSet(literals);
!!!325634.java!!!	getPositiveLiterals() : Literal
		return Collections.unmodifiableList(positiveLiterals);
!!!325762.java!!!	getNegativeLiterals() : Literal
		return Collections.unmodifiableList(negativeLiterals);
!!!325890.java!!!	getFactors() : Clause
		if (null == factors) {
			calculateFactors(null);
		}
		return Collections.unmodifiableSet(factors);
!!!326018.java!!!	getNonTrivialFactors() : Clause
		if (null == nonTrivialFactors) {
			calculateFactors(null);
		}
		return Collections.unmodifiableSet(nonTrivialFactors);
!!!326146.java!!!	subsumes(inout othC : Clause) : boolean
		boolean subsumes = false;

		// Equality is not subsumption
		if (!(this == othC)) {
			// Ensure this has less literals total and that
			// it is a subset of the other clauses positive and negative counts
			if (this.getNumberLiterals() < othC.getNumberLiterals()
					&& this.getNumberPositiveLiterals() <= othC
							.getNumberPositiveLiterals()
					&& this.getNumberNegativeLiterals() <= othC
							.getNumberNegativeLiterals()) {

				Map<String, List<Literal>> thisToTry = collectLikeLiterals(this.literals);
				Map<String, List<Literal>> othCToTry = collectLikeLiterals(othC.literals);
				// Ensure all like literals from this clause are a subset
				// of the other clause.
				if (othCToTry.keySet().containsAll(thisToTry.keySet())) {
					boolean isAPossSubset = true;
					// Ensure that each set of same named literals
					// from this clause is a subset of the other
					// clauses same named literals.
					for (String pk : thisToTry.keySet()) {
						if (thisToTry.get(pk).size() > othCToTry.get(pk).size()) {
							isAPossSubset = false;
							break;
						}
					}
					if (isAPossSubset) {
						// At this point I know this this Clause's
						// literal/arity names are a subset of the
						// other clauses literal/arity names
						subsumes = checkSubsumes(othC, thisToTry, othCToTry);
					}
				}
			}
		}

		return subsumes;
!!!326274.java!!!	binaryResolvents(inout othC : Clause) : Clause
		Set<Clause> resolvents = new LinkedHashSet<Clause>();
		// Resolving two empty clauses
		// gives you an empty clause
		if (isEmpty() && othC.isEmpty()) {
			resolvents.add(new Clause());
			return resolvents;
		}

		// Ensure Standardized Apart
		// Before attempting binary resolution
		othC = saIfRequired(othC);

		List<Literal> allPosLits = new ArrayList<Literal>();
		List<Literal> allNegLits = new ArrayList<Literal>();
		allPosLits.addAll(this.positiveLiterals);
		allPosLits.addAll(othC.positiveLiterals);
		allNegLits.addAll(this.negativeLiterals);
		allNegLits.addAll(othC.negativeLiterals);

		List<Literal> trPosLits = new ArrayList<Literal>();
		List<Literal> trNegLits = new ArrayList<Literal>();
		List<Literal> copyRPosLits = new ArrayList<Literal>();
		List<Literal> copyRNegLits = new ArrayList<Literal>();

		for (int i = 0; i < 2; i++) {
			trPosLits.clear();
			trNegLits.clear();

			if (i == 0) {
				// See if this clauses positives
				// unify with the other clauses
				// negatives
				trPosLits.addAll(this.positiveLiterals);
				trNegLits.addAll(othC.negativeLiterals);
			} else {
				// Try the other way round now
				trPosLits.addAll(othC.positiveLiterals);
				trNegLits.addAll(this.negativeLiterals);
			}

			// Now check to see if they resolve
			Map<Variable, Term> copyRBindings = new LinkedHashMap<Variable, Term>();
			for (Literal pl : trPosLits) {
				for (Literal nl : trNegLits) {
					copyRBindings.clear();
					if (null != _unifier.unify(pl.getAtomicSentence(),
							nl.getAtomicSentence(), copyRBindings)) {
						copyRPosLits.clear();
						copyRNegLits.clear();
						boolean found = false;
						for (Literal l : allPosLits) {
							if (!found && pl.equals(l)) {
								found = true;
								continue;
							}
							copyRPosLits.add(_substVisitor.subst(copyRBindings,
									l));
						}
						found = false;
						for (Literal l : allNegLits) {
							if (!found && nl.equals(l)) {
								found = true;
								continue;
							}
							copyRNegLits.add(_substVisitor.subst(copyRBindings,
									l));
						}
						// Ensure the resolvents are standardized apart
						Map<Variable, Term> renameSubstitituon = _standardizeApart
								.standardizeApart(copyRPosLits, copyRNegLits,
										_saIndexical);
						Clause c = new Clause(copyRPosLits, copyRNegLits);
						c.setProofStep(new ProofStepClauseBinaryResolvent(c,
								pl, nl, this, othC, copyRBindings,
								renameSubstitituon));
						if (isImmutable()) {
							c.setImmutable();
						}
						if (!isStandardizedApartCheckRequired()) {
							c.setStandardizedApartCheckNotRequired();
						}
						resolvents.add(c);
					}
				}
			}
		}

		return resolvents;
!!!326402.java!!!	toString() : String
		if (null == stringRep) {
			List<Literal> sortedLiterals = new ArrayList<Literal>(literals);
			Collections.sort(sortedLiterals, _literalSorter);

			stringRep = sortedLiterals.toString();
		}
		return stringRep;
!!!326530.java!!!	hashCode() : int
		return equalityIdentity.hashCode();
!!!326658.java!!!	equals(inout othObj : Object) : boolean
		if (null == othObj) {
			return false;
		}
		if (this == othObj) {
			return true;
		}
		if (!(othObj instanceof Clause)) {
			return false;
		}
		Clause othClause = (Clause) othObj;

		return equalityIdentity.equals(othClause.equalityIdentity);
!!!326786.java!!!	getEqualityIdentity() : String
		return equalityIdentity;
!!!326914.java!!!	recalculateIdentity() : void
		synchronized (this) {

			// Sort the literals first based on negation, atomic sentence,
			// constant, function and variable.
			List<Literal> sortedLiterals = new ArrayList<Literal>(literals);
			Collections.sort(sortedLiterals, _literalSorter);

			// All variables are considered the same as regards
			// sorting. Therefore, to determine if two clauses
			// are equivalent you need to determine
			// the # of unique variables they contain and
			// there positions across the clauses
			ClauseEqualityIdentityConstructor ceic = new ClauseEqualityIdentityConstructor(
					sortedLiterals, _literalSorter);

			equalityIdentity = ceic.getIdentity();

			// Reset, these as will need to re-calcualte
			// if requested for again, best to only
			// access lazily.
			factors = null;
			nonTrivialFactors = null;
			// Reset the objects string representation
			// until it is requested for.
			stringRep = null;
		}
!!!327042.java!!!	calculateFactors(inout parentFactors : Set<Clause>) : void
		nonTrivialFactors = new LinkedHashSet<Clause>();

		Map<Variable, Term> theta = new HashMap<Variable, Term>();
		List<Literal> lits = new ArrayList<Literal>();
		for (int i = 0; i < 2; i++) {
			lits.clear();
			if (i == 0) {
				// Look at the positive literals
				lits.addAll(positiveLiterals);
			} else {
				// Look at the negative literals
				lits.addAll(negativeLiterals);
			}
			for (int x = 0; x < lits.size(); x++) {
				for (int y = x + 1; y < lits.size(); y++) {
					Literal litX = lits.get(x);
					Literal litY = lits.get(y);

					theta.clear();
					Map<Variable, Term> substitution = _unifier.unify(
							litX.getAtomicSentence(), litY.getAtomicSentence(),
							theta);
					if (null != substitution) {
						List<Literal> posLits = new ArrayList<Literal>();
						List<Literal> negLits = new ArrayList<Literal>();
						if (i == 0) {
							posLits.add(_substVisitor.subst(substitution, litX));
						} else {
							negLits.add(_substVisitor.subst(substitution, litX));
						}
						for (Literal pl : positiveLiterals) {
							if (pl == litX || pl == litY) {
								continue;
							}
							posLits.add(_substVisitor.subst(substitution, pl));
						}
						for (Literal nl : negativeLiterals) {
							if (nl == litX || nl == litY) {
								continue;
							}
							negLits.add(_substVisitor.subst(substitution, nl));
						}
						// Ensure the non trivial factor is standardized apart
						Map<Variable, Term> renameSubst = _standardizeApart
								.standardizeApart(posLits, negLits,
										_saIndexical);
						Clause c = new Clause(posLits, negLits);
						c.setProofStep(new ProofStepClauseFactor(c, this, litX,
								litY, substitution, renameSubst));
						if (isImmutable()) {
							c.setImmutable();
						}
						if (!isStandardizedApartCheckRequired()) {
							c.setStandardizedApartCheckNotRequired();
						}
						if (null == parentFactors) {
							c.calculateFactors(nonTrivialFactors);
							nonTrivialFactors.addAll(c.getFactors());
						} else {
							if (!parentFactors.contains(c)) {
								c.calculateFactors(nonTrivialFactors);
								nonTrivialFactors.addAll(c.getFactors());
							}
						}
					}
				}
			}
		}

		factors = new LinkedHashSet<Clause>();
		// Need to add self, even though a non-trivial
		// factor. See: slide 30
		// http://logic.stanford.edu/classes/cs157/2008/lectures/lecture10.pdf
		// for example of incompleteness when
		// trivial factor not included.
		factors.add(this);
		factors.addAll(nonTrivialFactors);
!!!327170.java!!!	saIfRequired(inout othClause : Clause) : Clause

		// If performing resolution with self
		// then need to standardize apart in
		// order to work correctly.
		if (isStandardizedApartCheckRequired() || this == othClause) {
			Set<Variable> mVariables = _variableCollector
					.collectAllVariables(this);
			Set<Variable> oVariables = _variableCollector
					.collectAllVariables(othClause);

			Set<Variable> cVariables = new HashSet<Variable>();
			cVariables.addAll(mVariables);
			cVariables.addAll(oVariables);

			if (cVariables.size() < (mVariables.size() + oVariables.size())) {
				othClause = _standardizeApart.standardizeApart(othClause,
						_saIndexical);
			}
		}

		return othClause;
!!!327298.java!!!	collectLikeLiterals(inout literals : Set<Literal>) : Map<String, List<Literal>>
		Map<String, List<Literal>> likeLiterals = new HashMap<String, List<Literal>>();
		for (Literal l : literals) {
			// Want to ensure P(a, b) is considered different than P(a, b, c)
			// i.e. consider an atom's arity P/#.
			String literalName = (l.isNegativeLiteral() ? "~" : "")
					+ l.getAtomicSentence().getSymbolicName() + "/"
					+ l.getAtomicSentence().getArgs().size();
			List<Literal> like = likeLiterals.get(literalName);
			if (null == like) {
				like = new ArrayList<Literal>();
				likeLiterals.put(literalName, like);
			}
			like.add(l);
		}
		return likeLiterals;
!!!327426.java!!!	checkSubsumes(inout othC : Clause, inout thisToTry : Map<String, List<Literal>>, inout othCToTry : Map<String, List<Literal>>) : boolean
		boolean subsumes = false;

		List<Term> thisTerms = new ArrayList<Term>();
		List<Term> othCTerms = new ArrayList<Term>();

		// Want to track possible number of permuations
		List<Integer> radices = new ArrayList<Integer>();
		for (String literalName : thisToTry.keySet()) {
			int sizeT = thisToTry.get(literalName).size();
			int sizeO = othCToTry.get(literalName).size();

			if (sizeO > 1) {
				// The following is being used to
				// track the number of permutations
				// that can be mapped from the
				// other clauses like literals to this
				// clauses like literals.
				// i.e. n!/(n-r)!
				// where n=sizeO and r =sizeT
				for (int i = 0; i < sizeT; i++) {
					int r = sizeO - i;
					if (r > 1) {
						radices.add(r);
					}
				}
			}
			// Track the terms for this clause
			for (Literal tl : thisToTry.get(literalName)) {
				thisTerms.addAll(tl.getAtomicSentence().getArgs());
			}
		}

		MixedRadixNumber permutation = null;
		long numPermutations = 1L;
		if (radices.size() > 0) {
			permutation = new MixedRadixNumber(0, radices);
			numPermutations = permutation.getMaxAllowedValue() + 1;
		}
		// Want to ensure none of the othCVariables are
		// part of the key set of a unification as
		// this indicates it is not a legal subsumption.
		Set<Variable> othCVariables = _variableCollector
				.collectAllVariables(othC);
		Map<Variable, Term> theta = new LinkedHashMap<Variable, Term>();
		List<Literal> literalPermuations = new ArrayList<Literal>();
		for (long l = 0L; l < numPermutations; l++) {
			// Track the other clause's terms for this
			// permutation.
			othCTerms.clear();
			int radixIdx = 0;
			for (String literalName : thisToTry.keySet()) {
				int sizeT = thisToTry.get(literalName).size();
				literalPermuations.clear();
				literalPermuations.addAll(othCToTry.get(literalName));
				int sizeO = literalPermuations.size();

				if (sizeO > 1) {
					for (int i = 0; i < sizeT; i++) {
						int r = sizeO - i;
						if (r > 1) {
							// If not a 1 to 1 mapping then you need
							// to use the correct permuation
							int numPos = permutation
									.getCurrentNumeralValue(radixIdx);
							othCTerms.addAll(literalPermuations.remove(numPos)
									.getAtomicSentence().getArgs());
							radixIdx++;
						} else {
							// is the last mapping, therefore
							// won't be on the radix
							othCTerms.addAll(literalPermuations.get(0)
									.getAtomicSentence().getArgs());
						}
					}
				} else {
					// a 1 to 1 mapping
					othCTerms.addAll(literalPermuations.get(0)
							.getAtomicSentence().getArgs());
				}
			}

			// Note: on unifier
			// unifier.unify(P(w, x), P(y, z)))={w=y, x=z}
			// unifier.unify(P(y, z), P(w, x)))={y=w, z=x}
			// Therefore want this clause to be the first
			// so can do the othCVariables check for an invalid
			// subsumes.
			theta.clear();
			if (null != _unifier.unify(thisTerms, othCTerms, theta)) {
				boolean containsAny = false;
				for (Variable v : theta.keySet()) {
					if (othCVariables.contains(v)) {
						containsAny = true;
						break;
					}
				}
				if (!containsAny) {
					subsumes = true;
					break;
				}
			}

			// If there is more than 1 mapping
			// keep track of where I am in the
			// possible number of mapping permutations.
			if (null != permutation) {
				permutation.increment();
			}
		}

		return subsumes;
