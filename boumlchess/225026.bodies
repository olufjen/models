class ChessAlphaBetaSearch
!!!663426.java!!!	ChessAlphaBetaSearch(inout game : Game, in utilMin : double, in utilMax : double, in time : int)
	
		super(game, utilMin, utilMax, time);
		this.timecount = time;
	      this.timer = new Timer(time);
			try {
				fw = new FileWriter(outputFileName, true);
			} catch (IOException e1) {

				e1.printStackTrace();
			}
		      writer = new PrintWriter(new BufferedWriter(fw));		
	      
	      
/*	      try 
	      {
	         writer = new PrintWriter(outputFileName);
	      } catch (FileNotFoundException e) {
	         System.err.println("'" + outputFileName 
	            + "' is an invalid output file.");
	      }	*/
!!!663554.java!!!	createFor(inout game : ChessGame, in utilMin : double, in utilMax : double, in time : int) : ChessAlphaBetaSearch
    	
        return new ChessAlphaBetaSearch((Game<no.games.chess.ChessState<GameBoard>, no.games.chess.ChessAction<?, ?, ?, GamePiece<?>, ?>, no.games.chess.ChessPlayer<GamePiece, PieceMove>>) game, utilMin, utilMax, time);
!!!663682.java!!!	makeDecision(inout state : ChessState) : ChessAction
    	ChessState mystate = (ChessState)state;
    	
        metrics = new Metrics();
        StringBuffer logText = new StringBuffer("Log\n");
        StringBuffer store = new StringBuffer("Ordered actions");
        ChessPlayer player =  (ChessPlayer) game.getPlayer(mystate);
        ChessGame chessGame = (ChessGame) game;
        List<ChessAction> actions = chessGame.getActions(mystate);
        List<ChessAction> results =  orderActions(mystate, actions, player, 0);
        timer.start();
        currDepthLimit = 1;
        do {
            incrementDepthLimit();
            if (logEnabled)
                logText = new StringBuffer("New while with depth " + currDepthLimit + ": \n");
            heuristicEvaluationUsed = false;
            ActionStore<ChessAction> newResults = new ActionStore<>();
            for (ChessAction action : results) { // Do a minimax search on ordered actions
                double value = minValue(game.getResult(state, action), player, Double.NEGATIVE_INFINITY,
                        Double.POSITIVE_INFINITY, 1);
/*                if (timer.timeOutOccurred())
                    break; // exit from action loop
*/                newResults.add(action, value);
                if (logEnabled)
                    logText.append(action).append("\n -> ").append(value).append(" Metrics ").append(metrics).append("\n").append("From action store:\n");
            }
            if (logEnabled) {
            	 if (newResults.size() > 0) {
            		 logText.append(newResults.actions.get(0)).append(" Utilvalue ").append(newResults.utilValues.get(0)).append("\n");
            	 }
            }
            logText.append("new depth " + currDepthLimit + ": \n");

//           System.out.println(newResults.toString());
//            writer.println(newResults.toString());
            if (newResults.size() > 0) {
                results = newResults.actions;
                logText.append("Checking ordered actions \n");
/*
 * Use this structure to ensure that the makeDecision method always return actions belonging to the active player, not the opponent  
 * The minimax search has run through all actions.  See above!            
 */
//                if (!timer.timeOutOccurred()) {
                   if (hasSafeWinner(newResults.utilValues.get(0))) {
                	   logText.append(" Has a safe winner "+newResults.actions.get(0).toString()+"\n");
                       break; // exit from iterative deepening loop
                   }else if (newResults.size() > 1
                           && isSignificantlyBetter(newResults.utilValues.get(0), newResults.utilValues.get(1))) {
                	   logText.append(" Is better " +newResults.actions.get(0).toString()+"\n");
                       break; // exit from iterative deepening loop
                   }
//                }
            }
            store.append(newResults.toString());
 //           writer.println(logText);
        } while (!timer.timeOutOccurred() && heuristicEvaluationUsed ); // Added test of depthlimit removed 
        writer.println(logText);
        writer.println(store);
        writer.close();
        return results.get(0);
!!!663810.java!!!	orderActions(inout state : ChessState, inout list : List<ChessAction>, inout player : ChessPlayer, in depth : int) : ChessAction
    	ActionStore<ChessAction> newResults = new ActionStore<>();
        ChessGame chessGame = (ChessGame) game;
        writer.println("Ordering actions "+"depth/depthlimit "+depth+"/"+currDepthLimit+"\n");
//        System.out.println("From orderAction\n");
    	for (ChessAction action:list) {
    		double rank = chessGame.analyzePieceandPosition(action);
    		newResults.add(action, rank);
    	}
//    	System.out.println(newResults.toString());
        return  newResults.actions;
!!!663938.java!!!	maxValue(inout state : ChessState, inout player : ChessPlayer, in alpha : double, in beta : double, in depth : int) : double
        updateMetrics(depth);
        if (game.isTerminal(state) || depth >= currDepthLimit || timer.timeOutOccurred()) {
        	writer.println("maxValue Calling eval "+"depth/depthlimit "+depth+"/"+currDepthLimit+"\n");
            return eval(state, player);
        } else {
            double value = Double.NEGATIVE_INFINITY;
            List<ChessAction> localActions = game.getActions(state); //Produces a new set of actions for this state
            if(player.getPlayerName() == player.getBlackPlayer()) {
            	writer.println("Maxvalue Opponent to play "+player.getPlayerName()+"\n");
            }
            for (ChessAction action : orderActions(state, localActions, player, depth)) {
                value = Math.max(value, minValue(game.getResult(state, action), //
                        player, alpha, beta, depth + 1));
                if (value >= beta)
                    return value;
                alpha = Math.max(alpha, value);
            }
            return value;
        }
!!!664066.java!!!	minValue(inout state : ChessState, inout player : ChessPlayer, in alpha : double, in beta : double, in depth : int) : double
        updateMetrics(depth);
        if (game.isTerminal(state) || depth >= currDepthLimit || timer.timeOutOccurred()) {
        	writer.println("minValue Calling eval "+"depth/depthlimit "+depth+"/"+currDepthLimit+"\n");
            return eval(state, player);
        } else {
            double value = Double.POSITIVE_INFINITY;
            List<ChessAction> localActions = game.getActions(state);//Produces a new set of actions for this state
            if(player.getPlayerName() == player.getBlackPlayer()) {
            	writer.println("Minvalue Opponent to play "+player.getPlayerName()+"\n");
            }
            for (ChessAction action : orderActions(state,localActions, player, depth)) {
                value = Math.min(value, maxValue(game.getResult(state, action), //
                        player, alpha, beta, depth + 1));
                if (value <= alpha)
                    return value;
                beta = Math.min(beta, value);
            }
            return value;
        }
!!!664194.java!!!	updateMetrics(in depth : int) : void
        metrics.incrementInt(METRICS_NODES_EXPANDED);
        metrics.set(METRICS_MAX_DEPTH, Math.max(metrics.getInt(METRICS_MAX_DEPTH), depth));
!!!664322.java!!!	eval(inout state : ChessState, inout player : ChessPlayer) : double
//    	double primValue = super.eval(state, player);
        if (game.isTerminal(state)) {
            return game.getUtility(state, player);
        } else {
//          heuristicEvaluationUsed = true; Set in comment olj 10.08.20
        ChessGame chessGame = (ChessGame) game;
        double returnValue = chessGame.analyzeState(state);
 /*       if (returnValue == 0) {
        	 heuristicEvaluationUsed = true; // indicates opponent to move
        }

        return chessGame.analyzeState(state);*/
        heuristicEvaluationUsed = false;
        return returnValue;
          
/*          List<ChessAction> chessActions = chessState.getActions();
          ChessAction action = chessState.getAction();
          ChessGame chessGame = (ChessGame) game;
          if (action != null)
        	  return chessGame.analyzePieceandPosition(action);
          else
        	  return 0;
*/
        }
