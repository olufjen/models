class RapporterChessStartServerResourceHTML
!!!2565378.java!!!	RapporterChessStartServerResourceHTML()
		super();
		  System.out.println("RapporterChessStartServerResourceHTML felles started");
!!!2565506.java!!!	getTilgjengeligPos() : String
		return tilgjengeligPos;
!!!2565634.java!!!	setTilgjengeligPos(in tilgjengeligPos : String) : void
		this.tilgjengeligPos = tilgjengeligPos;
!!!2565762.java!!!	getAvailablePosNames() : List<String>
		return availablePosNames;
!!!2565890.java!!!	setAvailablePosNames(inout availablePosNames : List<String>) : void
		this.availablePosNames = availablePosNames;
!!!2566018.java!!!	getAvailableKey() : String
		return availableKey;
!!!2566146.java!!!	setAvailableKey(in availableKey : String) : void
		this.availableKey = availableKey;
!!!2566274.java!!!	getAvailableMoves() : Position
		return availableMoves;
!!!2566402.java!!!	setAvailableMoves(inout availableMoves : List<Position>) : void
		this.availableMoves = availableMoves;
!!!803074.java!!!	getMovesKey() : String
		return movesKey;
!!!803202.java!!!	setMovesKey(in movesKey : String) : void
		this.movesKey = movesKey;
!!!803330.java!!!	getBlackmovesKey() : String
		return blackmovesKey;
!!!803458.java!!!	setBlackmovesKey(in blackmovesKey : String) : void
		this.blackmovesKey = blackmovesKey;
!!!803586.java!!!	getOntologyKey() : String
		return ontologyKey;
!!!803714.java!!!	setOntologyKey(in ontologyKey : String) : void
		this.ontologyKey = ontologyKey;
!!!803842.java!!!	getBlackMoves() : List<String>
		return blackMoves;
!!!803970.java!!!	setBlackMoves(inout blackMoves : List<String>) : void
		this.blackMoves = blackMoves;
!!!804098.java!!!	getRulesKey() : String
		return rulesKey;
!!!804226.java!!!	setRulesKey(in rulesKey : String) : void
		this.rulesKey = rulesKey;
!!!804354.java!!!	getRulelabelKey() : String
		return rulelabelKey;
!!!804482.java!!!	setRulelabelKey(in rulelabelKey : String) : void
		this.rulelabelKey = rulelabelKey;
!!!804610.java!!!	getStartPosition() : String
		return startPosition;
!!!804738.java!!!	setStartPosition(in startPosition : String) : void
		this.startPosition = startPosition;
!!!804866.java!!!	getPosition() : String
		return position;
!!!804994.java!!!	setPosition(in position : String) : void
		this.position = position;
!!!805122.java!!!	getDisplayPassord() : String
		return displayPassord;
!!!805250.java!!!	setDisplayPassord(in displayPassord : String) : void
		this.displayPassord = displayPassord;
!!!805378.java!!!	getPassordCheck() : String
		return passordCheck;
!!!805506.java!!!	setPassordCheck(in passordCheck : String) : void
		this.passordCheck = passordCheck;
!!!805634.java!!!	getDelMelding() : String
		return delMelding;
!!!805762.java!!!	setDelMelding(in delMelding : String) : void
		this.delMelding = delMelding;
!!!805890.java!!!	getMeldeTxtId() : String
		return meldeTxtId;
!!!806018.java!!!	setMeldeTxtId(in meldeTxtId : String) : void
		this.meldeTxtId = meldeTxtId;
!!!806146.java!!!	getPositions(inout object : Object) : Object
	    System.out.println(object.getClass());
	    return object;
	    
!!!806274.java!!!	establishRules(inout chessBoard : ChessBoard) : void
		 rules = chessBoard.getExeRules();
		 labels = chessBoard.getExeLabels();
		 chessRules = chessBoard.getChessRules();


		 if (rules == null || rules.isEmpty()) {
			 rules = new ArrayList<String>();
			 rules.add("No rules avaiable");
		 }
		 if (labels == null || labels.isEmpty()) {
			 labels = new ArrayList<String>();
			 labels.add("No rule");
		 }
!!!806402.java!!!	establishMoves(inout chessBoard : ChessBoard, inout position : Position) : void
		String move = position.getPositionName();
		String pieceName = position.getUsedBy().getName();
		String pieceType = position.getUsedBy().getPieceName();
		if (!pieceType.equals("P"))
			move = pieceType+move;
		chessMoves = chessBoard.getChessMoves();
		int last = chessMoves.size() ;
		chessMove = chessMoves.get(last-1);
		int moveNr = chessMove.getMoveNr();
		if (pieceName.contains("w")) {
			chessMove = new ChessMoves();
			chessMove.setWhiteMove(move);
			chessMove.setMoveNr(moveNr+1);
			chessMoves.add(chessMove);
		}else {
			chessMove.setBlackMove(move);
		}
		
!!!806530.java!!!	getChess(inout request : HttpServletRequest) : Response

   // 	Response rep = null;
    	String siden = "chess/startside.html";
		/*
		 * try { // OBS: Må peke til der index.html ligger relativt til Context-roten.
		 * // Hvis index.html ligger i roten av webapp-mappen: URI location = new
		 * URI("../../chess/startside.html"); rep =
		 * Response.temporaryRedirect(location).build(); } catch (Exception e) { return
		 * Response.serverError().entity("Feil ved lasting av skjema: " +
		 * e.getMessage()).build(); }
		 */
    	
    
		/*
		 * Reference reference = new Reference(getReference(),"..").getTargetRef(); //
		 * org.restlet.data Request request = getRequest(); // Tidligere kall til
		 * org.restlet.resource.ServerResource !!
		 */
//    	HttpSession session = (HttpSession) request.getSession(true);
         Map<String, Object> dataModel = new HashMap<String, Object>();
	
//	     establishMoves();
	     String meldingsText = " ";
	     String fileName = null;
	     SimpleScalar simple = new SimpleScalar(piece);
	     SimpleScalar movedTo = new SimpleScalar(snewPosition);
	     SimpleScalar movedfrom = new SimpleScalar(soldPosition);
	     SimpleScalar chessPosition = new SimpleScalar(startPosition);
//	     SimpleScalar chessMove = new SimpleScalar(moves);
	     ChessBoard chessBoard = new ChessBoard(fileName);
	     String[] legalMoves = {"a3","a4"};
	     String fen = chessBoard.createFen();
	     String popup = "nopopup";
//	     System.out.println(fen);
/*	     moves = chessBoard.getMoves();
	     blackMoves = chessBoard.getBlackMoves();*/
	     dataModel.put(fenPosid,fen);
	     dataModel.put(popupId, popup);
	     establishRules(chessBoard);
	     chessMoves = chessBoard.getChessMoves();
	     sessionAdmin.setSessionObject(request,chessBoard, chessBoardsession);
//	     ChessPiece whitePawn1 = whitePawnpos.getUsedBy();
//	     if (whitePawn1 != null)
//	    	 whitePawn1.setLegalMoves(legalMoves);
		 dataModel.put(pieceId,simple );
		 dataModel.put(newPosId,movedTo );
		 dataModel.put(oldPosId,movedfrom );
		 dataModel.put(displayKey, chessPosition);
		 availablePosNames = new ArrayList<String>();
		 availablePosNames.add("xx");
   	 	dataModel.put(rulesKey,chessRules);
   	 	dataModel.put(movesKey, chessMoves);
   	 	dataModel.put(availableKey, availablePosNames);
 //  	 	dataModel.put(blackmovesKey, blackMoves);
//   	 	dataModel.put(rulelabelKey, labels);
   	 	
//		 dataModel.put(pawnId,whitePawn1);
		
//		 SimpleScalar pwd = new SimpleScalar(passordCheck);
//		 dataModel.put(displayPassord,pwd);
   	 	
   	 	 FreemarkerView view = new FreemarkerView(siden, dataModel);
			/*
			 * LocalReference pakke =
			 * LocalReference.createClapReference(LocalReference.CLAP_CLASS, "/chess"); //
			 * org.restlet.data
			 * 
			 * LocalReference localUri = new LocalReference(reference);
			 * 
			 * // Denne client resource forholder seg til src/main/resource katalogen !!!
			 * ClientResource clres2 = new
			 * ClientResource(LocalReference.createClapReference(LocalReference.CLAP_CLASS,
			 * "/chess/startside.html")); //org.restlet.resource
			 * 
			 * Representation pasientkomplikasjonFtl = clres2.get();
			 * 
			 * TemplateRepresentation templatemapRep = new
			 * TemplateRepresentation(pasientkomplikasjonFtl,dataModel,
			 * MediaType.TEXT_HTML); // org.restlet.representation
			 */
   	 	 return Response.ok(view).build();
	
!!!806658.java!!!	storeChess(in restartGame : String, in ontology : String, in printOntology : String, in reload : String, in query : String, in fileselect : String, in ontlogyselect : String, in printGame : String, in eightqueen : String, in achessGame : String, in findPiece : String, in posisjon : String, in piece : String, in startposisjon : String, in tilgjengeligpos : String, inout request : HttpServletRequest) : Response
    	
//    	TemplateRepresentation  templateRep = null;
 	    Map<String, Object> dataModel = new HashMap<String, Object>();
 	   String siden = "chess/startside.html";
// 	    Request request = getRequest();
 	   boolean noMove = false;
 
		/*
		 * if(form == null){ invalidateSessionobjects(); }
		 */
/*	     String[] legalMoves = {"a3","a4"};
	     ChessPiece whitePawn1 = new ChessPiece(newPos,"w","wP",legalMoves);
	     whitePawn1.setValue(1);*/
		  String popup = "nopopup";
	      	dataModel.put(popupId, popup);
    	String[] legalMoves = {"",""};
    	ChessPiece chessPiece = null;
 //   	availablePosNames = null;
    	availableMoves = null;
    	ChessBoard chessBoard = (ChessBoard)sessionAdmin.getSessionObject(request , chessBoardsession);
    	PlayGame game = (PlayGame)sessionAdmin.getSessionObject(request, gameboardSession); // If the game object is null, then the user has not chosen to play a game yet.
	    moves = chessBoard.getMoves();
	    blackMoves = chessBoard.getBlackMoves();
	    chessMoves = chessBoard.getChessMoves();
	    availableMoves = new ArrayList<Position>();
//    	Parameter restartGame = form.getFirst("startBtnx"); // Bruker oppgir å starte på nytt
//    	Parameter ontology = form.getFirst("ontBtnx"); // User wants ontology position on chessboard
//    	Parameter printOntology = form.getFirst("printBtnx"); // User wants ontology printed
//    	Parameter reload = form.getFirst("relBtnx"); // User wants to reload ontology from file
//    	Parameter query = form.getFirst("qBtnx"); // User wants to query ontology 
//    	Parameter fileselect = form.getFirst("fileinput"); // User has selected a file
//      	Parameter ontlogyselect = form.getFirst("ontologyinput"); // User has selected an ontology file file
//    	Parameter printGame = form.getFirst("printgame"); // User has selected to print the game
//    	Parameter eightqueen = form.getFirst("eightqueen"); // User has selected to solve the eight queen problem
//    	Parameter achessGame = form.getFirst("playgame"); // User has selected to play a game of chess
//    	Parameter findPiece = form.getFirst("btnfind"); // User has moved mouse over a piece
    	if (printGame != null) {
//         	chessBoard.findMoves(gameMoves);
//	     	int nolines = gameMoves.size();
//	     	String mov = (String)gameMoves.get(13)+gameMoves.get(14)+gameMoves.get(15);
//			Representation representation = null;
//			Response response = getResponse(); 
    		chessMoves = chessBoard.getChessMoves();
    		String pdfFile = "";
    		try {
				pdfFile = printGame(chessMoves);
				/*
				 * representation = new FileRepresentation(pdfFile, MediaType.APPLICATION_PDF);
				 * Disposition disposition = representation.getDisposition();
				 * disposition.setType(disposition.TYPE_ATTACHMENT);
				 * disposition.setFilename("game" + ".pdf"); response.setEntity(representation);
				 */
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

         	String fen = chessBoard.createFen();
         	System.out.println(fen);
         	dataModel.put(fenPosid,fen);
         	SimpleScalar pieceMoved = new SimpleScalar(piece);
         	SimpleScalar movedTo = new SimpleScalar(newPos);
         	SimpleScalar chessPosition = new SimpleScalar(position);
         	dataModel.put(displayKey, chessPosition);
         	dataModel.put(pieceId,pieceMoved );
   
         	establishRules(chessBoard);
         	//		dataModel.put(pieceId,simple );
         	dataModel.put(rulesKey,chessRules);
         	dataModel.put(movesKey, chessMoves);
         	//  	 	dataModel.put(blackmovesKey, blackMoves);
         	 FreemarkerView view = new FreemarkerView(siden, dataModel);
         	return Response.ok(view).build();
         	//		 dataModel.put(pawnId,whitePawn1);
			/*
			 * ClientResource clres2 = new
			 * ClientResource(LocalReference.createClapReference(LocalReference.CLAP_CLASS,
			 * "/chess/startside.html")); Representation pasientkomplikasjonFtl =
			 * clres2.get(); templateRep = new
			 * TemplateRepresentation(pasientkomplikasjonFtl,dataModel,
			 * MediaType.TEXT_HTML);
			 * 
			 * 
			 * 
			 * return templateRep;
			 */
    	}
    	if (ontlogyselect != null && !ontlogyselect.equals("")) {// This parameter is always created: Why?!!
       		String fileName = "";
    		String rep = "\\";
    		String newRep = "\\\\";
    		String user = "olj";
    		String newUser = "bruker";
    		System.out.println("ontlogy selected");
			/*
			 * for (Parameter entry : form) { if (entry.getValue() != null &&
			 * !(entry.getValue().equals("")) && entry.getName().equals("ontologyinput")){
			 * System.out.println(entry.getName() + "=" + entry.getValue()); fileName =
			 * entry.getValue(); fileName = fileName.replace(rep, newRep); fileName =
			 * fileName.replace(user, newUser); System.out.println(fileName); } }
			 */
    		 sessionAdmin.setSessionObject(request,fileName, ontologyKey);
    		 chessBoard = null;
    		 chessBoard = new ChessBoard(fileName);
    		 sessionAdmin.setSessionObject(request,chessBoard, chessBoardsession);
//    	     legalMoves = {"a3","a4"};
    	     SimpleScalar simple = new SimpleScalar(piece);
    	     SimpleScalar chessPosition = new SimpleScalar(startPosition);
    	     String fen = chessBoard.createFen();
    	     dataModel.put(fenPosid,fen);
    	     establishRules(chessBoard);
    	     chessMoves = chessBoard.getChessMoves();
    		 dataModel.put(pieceId,simple );
    		 dataModel.put(displayKey, chessPosition);
        	 FreemarkerView view = new FreemarkerView(siden, dataModel);
         	return Response.ok(view).build();
			/*
			 * Reference reference = new Reference(getReference(),"..").getTargetRef();
			 * dataModel.put(rulesKey,chessRules); dataModel.put(movesKey, chessMoves);
			 * 
			 * LocalReference pakke =
			 * LocalReference.createClapReference(LocalReference.CLAP_CLASS, "/chess");
			 * 
			 * LocalReference localUri = new LocalReference(reference);
			 * 
			 * // Denne client resource forholder seg til src/main/resource katalogen !!!
			 * ClientResource clres2 = new
			 * ClientResource(LocalReference.createClapReference(LocalReference.CLAP_CLASS,
			 * "/chess/startside.html"));
			 * 
			 * Representation pasientkomplikasjonFtl = clres2.get();
			 * 
			 * TemplateRepresentation templatemapRep = new
			 * TemplateRepresentation(pasientkomplikasjonFtl,dataModel,
			 * MediaType.TEXT_HTML); return templatemapRep;
			 */
    	}
    	if (fileselect != null && !fileselect.equals("")) { // This parameter is always created: Why?!!
    		String fileName = "";
    		String rep = "\\";
    		String newRep = "\\\\";
    		String user = "olj";
    		String newUser = "bruker";
    		System.out.println("fileselect");
			/*
			 * for (Parameter entry : form) { if (entry.getValue() != null &&
			 * !(entry.getValue().equals("")) && entry.getName().equals("fileinput")){
			 * System.out.println(entry.getName() + "=" + entry.getValue()); fileName =
			 * entry.getValue(); fileName = fileName.replace(rep, newRep); fileName =
			 * fileName.replace(user, newUser); System.out.println(fileName); } }
			 */
//    		fileName = "C:\\Users\\olj\\Google Drive\\privat\\ontologies\\chessgames\\brill\\brill.pgn";
//    		fileName = "c:\\\\ullern\\\\acem\\\\radio\\\\translist.txt";
//    		chessBoard.getGameFile().setFilePath("c:\\ullern\\acem\\radio\\translist.txt");
       		chessBoard.getGameFile().setFilePath(fileName);
    		chessBoard.getGameFile().createLines();
    		 Stream lines = chessBoard.getGameFile().getLines();
//    		 System.out.println(lines);
   	     	List<String> gameMoves = chessBoard.getGameFile().sendeListe();
   	     	chessBoard.findMoves(gameMoves);
//   	     	int nolines = gameMoves.size();
//   	     	String mov = (String)gameMoves.get(13)+gameMoves.get(14)+gameMoves.get(15);
      	     String fen = chessBoard.createFen();
       	     System.out.println(fen);
       	     dataModel.put(fenPosid,fen);
        	SimpleScalar pieceMoved = new SimpleScalar(piece);
        	SimpleScalar movedTo = new SimpleScalar(newPos);
    	     SimpleScalar chessPosition = new SimpleScalar(position);
    		 dataModel.put(displayKey, chessPosition);
       	 	dataModel.put(pieceId,pieceMoved );
      		establishRules(chessBoard);
//    		dataModel.put(pieceId,simple );
    	 	dataModel.put(rulesKey,chessRules);
    		dataModel.put(movesKey, chessMoves);
//      	 	dataModel.put(blackmovesKey, blackMoves);
       	 FreemarkerView view = new FreemarkerView(siden, dataModel);
        	return Response.ok(view).build();
     //		 dataModel.put(pawnId,whitePawn1);
		/*
		 * ClientResource clres2 = new
		 * ClientResource(LocalReference.createClapReference(LocalReference.CLAP_CLASS,
		 * "/chess/startside.html")); Representation pasientkomplikasjonFtl =
		 * clres2.get(); templateRep = new
		 * TemplateRepresentation(pasientkomplikasjonFtl,dataModel,
		 * MediaType.TEXT_HTML);
		 * 
		 * 
		 * 
		 * return templateRep;
		 */
    	}
    	if (query != null){
    		chessBoard.queryOntology();
     		String fen = chessBoard.createFen();
    		//   	     System.out.println(fen);
    		dataModel.put(fenPosid,fen);
    		sessionAdmin.setSessionObject(request,chessBoard, chessBoardsession);
       	 FreemarkerView view = new FreemarkerView(siden, dataModel);
        	return Response.ok(view).build();
     //		 dataModel.put(pawnId,whitePawn1);
		/*
		 * ClientResource clres2 = new
		 * ClientResource(LocalReference.createClapReference(LocalReference.CLAP_CLASS,
		 * "/chess/startside.html")); Representation pasientkomplikasjonFtl =
		 * clres2.get(); templateRep = new
		 * TemplateRepresentation(pasientkomplikasjonFtl,dataModel,
		 * MediaType.TEXT_HTML); return templateRep;
		 */
    	}    	
    	if (reload != null){
    		request.getSession().invalidate();
//    		sessionAdmin.getSession(request,chessBoardsession).invalidate();
    		chessBoard = null;
    		String fileName = null;
   	     	SimpleScalar simple = new SimpleScalar(piece);
   	     	SimpleScalar movedTo = new SimpleScalar(newPos);
   	     	SimpleScalar chessPosition = new SimpleScalar(startPosition);
    		chessBoard = new ChessBoard(fileName);
   	     	moves = chessBoard.getMoves();
   	     	blackMoves = chessBoard.getBlackMoves();
     		String fen = chessBoard.createFen();
     		establishRules(chessBoard);
     		dataModel.put(pieceId,simple );
     		dataModel.put(displayKey, chessPosition);
     		chessBoard.emptyGame();
   		
      	 	dataModel.put(rulesKey,chessRules);
      		dataModel.put(movesKey, chessMoves);
//      	 	dataModel.put(blackmovesKey, blackMoves);
    		//   	     System.out.println(fen);
    		dataModel.put(fenPosid,fen);
    		sessionAdmin.setSessionObject(request,chessBoard, chessBoardsession);
         	 FreemarkerView view = new FreemarkerView(siden, dataModel);
         	return Response.ok(view).build();

     //		 dataModel.put(pawnId,whitePawn1);
		/*
		 * ClientResource clres2 = new
		 * ClientResource(LocalReference.createClapReference(LocalReference.CLAP_CLASS,
		 * "/chess/startside.html")); Representation pasientkomplikasjonFtl =
		 * clres2.get(); templateRep = new
		 * TemplateRepresentation(pasientkomplikasjonFtl,dataModel,
		 * MediaType.TEXT_HTML); return templateRep;
		 */
    	}
    	if (printOntology != null){
    	 chessBoard.printOntology();	
   	     String fen = chessBoard.createFen();
   	     System.out.println(fen);
   	     dataModel.put(fenPosid,fen);
      	 FreemarkerView view = new FreemarkerView(siden, dataModel);
     	return Response.ok(view).build();


    	}
    	if (ontology != null){ // User want ontology position on board
    		chessBoard.createChessontlogyPosition();
    		String fen = chessBoard.createFen();

    		System.out.println(fen);
    		dataModel.put(fenPosid,fen);
    		SimpleScalar pieceMoved = new SimpleScalar(piece);
    		SimpleScalar movedTo = new SimpleScalar(newPos);
    		SimpleScalar chessPosition = new SimpleScalar(position);
    		dataModel.put(displayKey, chessPosition);
    		dataModel.put(pieceId,pieceMoved );
    		List<ChessRules> chessRules = chessBoard.getChessRules();
    		dataModel.put(rulesKey,chessRules);
    		dataModel.put(movesKey, chessMoves);
         	 FreemarkerView view = new FreemarkerView(siden, dataModel);
         	return Response.ok(view).build();

    	}
    	if (restartGame != null){
    		chessBoard.createStartPosition();
      	     String fen = chessBoard.createFen();
       	     System.out.println(fen);
       	     dataModel.put(fenPosid,fen);
        	SimpleScalar pieceMoved = new SimpleScalar(piece);
        	SimpleScalar movedTo = new SimpleScalar(newPos);
    	     SimpleScalar chessPosition = new SimpleScalar(position);
      		establishRules(chessBoard);
     		chessBoard.emptyGame();
//      		dataModel.put(pieceId,simple );
       	 	dataModel.put(rulesKey,chessRules);
       		dataModel.put(movesKey, chessMoves);
//      	 	dataModel.put(blackmovesKey, blackMoves);
    		 dataModel.put(displayKey, chessPosition);
       	 	dataModel.put(pieceId,pieceMoved );
         	 FreemarkerView view = new FreemarkerView(siden, dataModel);
         	return Response.ok(view).build();
     //		 dataModel.put(pawnId,whitePawn1);
		/*
		 * ClientResource clres2 = new
		 * ClientResource(LocalReference.createClapReference(LocalReference.CLAP_CLASS,
		 * "/chess/startside.html")); Representation pasientkomplikasjonFtl =
		 * clres2.get(); templateRep = new
		 * TemplateRepresentation(pasientkomplikasjonFtl,dataModel,
		 * MediaType.TEXT_HTML); return templateRep;
		 */
    	}
    	if (eightqueen != null) { // User wants to solve the eight queen problem  
//      		chessBoard.clearChessBoard();
      		EightQueenProblem queenProblem = new EightQueenProblem();
      		queenProblem.prepare();
//      		queenProblem.solveProblem();
      		
      		boolean bDone= queenProblem.solvepartProblem();
      		while (!bDone) {
      			bDone = queenProblem.solvepartProblem();
      			System.out.println(queenProblem.getStatistics());
      		}
      	     System.out.println(queenProblem.getStatistics());
      	     List<XYLocation> locations = queenProblem.getEnv().getBoard().getQueenPositions(); 
      	     XYLocation loc = locations.get(0);
      	     NQueensCSP qCSP = queenProblem.getnQueens();
      	     List<Variable> variables = qCSP.getVariables();
      	     Variable var = variables.get(0);
      	     String varName = var.getName();
      	     List<Constraint<Variable,Integer>> constraints = qCSP.getConstraints();
      	     Domain domain = qCSP.getDomain(var);
     	     chessBoard.setPiecetoPosition(queenProblem.getEnv().getBoard(),queenProblem.getnQueens());
     	     String fen = chessBoard.createFen();
      	     System.out.println(fen);
      	     dataModel.put(fenPosid,fen);
       	SimpleScalar pieceMoved = new SimpleScalar(piece);
       	SimpleScalar movedTo = new SimpleScalar(newPos);
   	     SimpleScalar chessPosition = new SimpleScalar(position);
     		establishRules(chessBoard);
    		chessBoard.emptyGame();
//     		dataModel.put(pieceId,simple );
      	 	dataModel.put(rulesKey,chessRules);
      		dataModel.put(movesKey, chessMoves);
//     	 	dataModel.put(blackmovesKey, blackMoves);
   		 dataModel.put(displayKey, chessPosition);
      	 	dataModel.put(pieceId,pieceMoved );
         	 FreemarkerView view = new FreemarkerView(siden, dataModel);
         	return Response.ok(view).build();
    //		 dataModel.put(pawnId,whitePawn1);
	/*
	 * ClientResource clres2 = new
	 * ClientResource(LocalReference.createClapReference(LocalReference.CLAP_CLASS,
	 * "/chess/startside.html")); Representation pasientkomplikasjonFtl =
	 * clres2.get(); templateRep = new
	 * TemplateRepresentation(pasientkomplikasjonFtl,dataModel,
	 * MediaType.TEXT_HTML); return templateRep;
	 */
    	}
/*
 *     	 User wants to play a game of chess
 */
    	if (achessGame != null) { // User wants to play a game of chess
    		chessBoard.createChessontlogyPosition();
    		if (game == null) {
    			game = new PlayGame(chessBoard.getPositions(),chessBoard); // Creates start position based on ontology start position
    			sessionAdmin.setSessionObject(request,game, gameboardSession);
    		}
  	    	APlayer opponent = game.getGame().getLocalblackPlayer(); //OBS !! Gameplayer is always white!!!
  	    	opponent.calculateOpponentActions(game.getActiveState());   
 // 	    	opponent.calculateOpponentPositions();This call is replaced by the call to calculateOpponentActions
       	    System.out.println("Start positions\n"+game.getGame().getBoardPic());
    	
    		SimpleScalar chessPosition = new SimpleScalar(position);
//    		establishRules(chessBoard);
    		chessBoard.emptyGame();
    		game.proposeMove();
  	    	AgamePiece playerPiece = game.getLastPiece();
   		 	availablePosNames = new ArrayList<String>();
   		 	availablePosNames.add("pl"); // Wants to play a game of chess
   		 	
   	    	piece = playerPiece.getMyPiece().getName();
  	    	snewPosition = game.getNewPosition().getPositionName();
   	    	soldPosition = game.getOldPosition().getPositionName();
   	    	String fen = chessBoard.createFen();
   	    	
    		return produceTemplate(siden,dataModel,fen,chessBoard);
    	}
    	if (findPiece != null) {   		// User has marked a piece formSubmit('btnfind');
    		collectParameters(posisjon, piece, startposisjon, tilgjengeligpos);
        	if (newPos == null || newPos.equals("")){
        		newPos = "a2";
        	}
        	if (oldPos == null || oldPos.equals("y")){
        		oldPos = newPos;
        	}    
        	boolean findTilgjengelig = tilgjengeligPos.equals("til");
       	    chessPiece = chessBoard.findPiece(oldPos,piece);
       	   	AgamePiece movedPiece = chessPiece.getMyPiece();
      	    System.out.println("Piece marked Finding available positions "+findTilgjengelig);
      	    String fen = chessBoard.createFen();
      	   	 if (game != null && findTilgjengelig) { // 
     	    	APlayer opponent = game.getActiveState().getOpponent();
     	    	Position oldPosition = chessBoard.findPostion(oldPos);
     	    	Position newPosition = chessBoard.findPostion(newPos);
        	    	HashMap<String,Position> allMoves =  movedPiece.getLegalmoves();
        	    	Set<String> keySet = allMoves.keySet();
        	    	ArrayList<String> listOfKeys = new ArrayList<String>(keySet);
        	    	ArrayList<Position> allMoveslist = new ArrayList<>(allMoves.values());
        	    	availableMoves.addAll(allMoveslist);
        	    	availablePosNames = new ArrayList<String>();
      	    	for (Position pos:availableMoves) {
      	    		availablePosNames.add(pos.getPositionName());
      	    	}
        	 }
            return produceTemplate(siden,dataModel,fen,chessBoard);
    	}
   // Opponent Player has moved a piece	
   		collectParameters(posisjon, piece, startposisjon, tilgjengeligpos); // This call replaces the structure below:

    	if (newPos == null || newPos.equals("")){
    		newPos = "a2";
    	}
    	if (oldPos == null || oldPos.equals("y")){
    		oldPos = newPos;
    	}    	
    	String moveText = "Proper move";
    	if (oldPos.equals(newPos)) { // A no move
    		noMove = true;
    		moveText = "No move";
    	}
//    	chessPiece.setName(piece);
/*
 * The position and piece entered by user
 * corresponds to position.positionName and piece.name !!! 
 */

    	boolean findTilgjengelig = tilgjengeligPos.equals("til");
   	    chessPiece = chessBoard.findPiece(oldPos,piece); // Name of piece (String object from user) to a chess piece !!!
   	   	AgamePiece movedPiece = chessPiece.getMyPiece();
   	    String fen = chessBoard.createFen();
   	    System.out.println("Piece name "+chessPiece.getOntlogyName()+" Finding available positions "+findTilgjengelig);
   	    System.out.println("Game and moveflagg "+game+" "+noMove+" "+moveText);
   	    System.out.println(fen);
/*   	    if (noMove) {
   	    	System.out.println(movedPiece.toString());
   	    }*/
   	    
   	    if (game != null && !noMove && !findTilgjengelig) { // Performs the opponent's move and creates the next move

//       	chessPiece.setPosition(newPos);
   	    	APlayer opponent = game.getActiveState().getOpponent();
   	    	Position oldPosition = chessBoard.findPostion(oldPos);
   	    	Position newPosition = chessBoard.findPostion(newPos);
   	    	AgamePiece castle = opponent.checkCastling(movedPiece, newPosition);
   	    	boolean castleCheck = false;
   	    	Position castlePos = null;
   	    	if (castle != null) {
   	    		castle.setCastlingMove(true);
   	    		movedPiece.setCastlingMove(true);
   	    		Position castlePosfrom = castle.getHeldPosition();
   	    		if (castlePosfrom == null)
   	    			castlePosfrom = castle.getMyPosition();
   	    		String fromPos = castlePosfrom.getPositionName();
   	    		castlePos = castleMove(castle, newPosition,opponent,chessBoard);
   	    		String toPos = "";
   	    		String castleName = castle.getName();
   	    		if (castlePos != null) {
   	    			castleCheck = true;
   	    			toPos = castlePos.getPositionName();
  	    			chessBoard.determineMove(fromPos, toPos, castleName); // Determine if move is legal
   	    			castle.setNofMoves(0);
   	    			castle.setMyPosition(castlePos);
   	    			castle.produceLegalmoves(castlePos);
   	    		}
   	    		
   	    	}
   	    	
   	    	HashMap<String,Position> allMoves =  movedPiece.getLegalmoves();
   	    	Set<String> keySet = allMoves.keySet();
   	    	ArrayList<String> listOfKeys = new ArrayList<String>(keySet);
   	    	ArrayList<Position> allMoveslist = new ArrayList<>(allMoves.values());
   	    	availableMoves.addAll(allMoveslist);
   	    	availablePosNames = new ArrayList<String>();
 	    	for (Position pos:availableMoves) {
 	    		availablePosNames.add(pos.getPositionName());
 	    	}

   	    	chessBoard.determineMove(oldPos, newPos, piece); // Determine if move is legal
   	    	if (castle != null) {
   	    		castle.setCastlingMove(false);
   	    		movedPiece.setCastlingMove(false);
   	    	}
   	    	/*
   	    	 * Keeps track of move numbers and the number of moves		
   	    	 */
   	    	movedPiece.setNofMoves(0);

   	    	chessPiece.getMyPiece().setMyPosition(newPosition);
   	    	/*
   	    	 *  New 16.04.20 similar to proposemove
   	    	 */

   	    	/*
   	    	 * Is this correct ??? OLJ 10.07.20 ???? 	    	
   	    	 */
   	    	// 	    	chessPiece.getMyPiece().setHeldPosition(newPosition); // All pieces are now set in correct positions: Should this line be removed ??? OLJ 10.07.20
   	    	newPosition.setUsedandRemoved(chessPiece); // When this call is removed, a piece is removed from the board!!!
 /*
  * end new	    	
  */
// 	    	System.out.println("Old position "+oldPosition.toString()+ " New position "+newPosition.toString());
 	    // setHeldPosition(oldPosition); in this position removes the black pawn in move nr. 3 
 	    	List<ApieceMove>  movesofar = game.getMovements();
 	    	 System.out.println("Moves so far ");
 	    	for (ApieceMove  piecemove:movesofar) {
 	    		System.out.println(piecemove.toString());
 	    		Position topos = piecemove.getToPosition();
 	    		AgamePiece movePiece = piecemove.getPiece();
 	    		Position piecePos = movePiece.getmyPosition();
 	    		Position heldPos = movePiece.getHeldPosition();
 	    		if (topos == heldPos && piecePos != topos) {
 	    			System.out.println(movePiece.toString());
 	    		}
 	    		
 	    	}
 	    	System.out.println("Available positions for "+piece+" before move");
 	    	for (Position pos:allMoveslist) {
 	    		System.out.println(pos.getPositionName());
 	    	}
 	    	for (String akey:listOfKeys) {
 	    		System.out.println(akey);
 	    	}
  	    	game.getGame().movePiece(movedPiece, newPosition,"Opponent");// 16.04.20 Move piece before setting new position.

 // 	    	chessPiece.getMyPiece().setHeldPosition(oldPosition); // Then there are no previous positions to restore from
// setHeldPosition(oldPosition); in this position removes the black pawn in move nr. 2
//   	    	game.getGame().movePiece(oldPosition.getXyloc(),newPosition.getXyloc());
   	    	game.createMove(movedPiece, oldPosition, newPosition); // Creates a new move for the opponent
/*
 * Put the last move to the list of movements for the player  
 * 
 */

   	    	HashMap<String,ApieceMove> myMoves = game.getActiveState().getOpponent().getMyMoves();
   	    	int index = game.getMovements().size();
   	    	ApieceMove lastMove = game.getMovements().get(index-1);
   	    	String moveNot = lastMove.getMoveNotation(); // OBS move notation is not set !!!
 
   	    	lastMove.setMoveNotation(moveNot);
   	    	myMoves.put(moveNot, lastMove);
 	    	Integer noofMoves = new Integer(lastMove.getMoveNumber());
 			movedPiece.getMoveNumbers().add(noofMoves);
  	    	movedPiece.produceLegalmoves(newPosition); // Added 23.06.20 produces new available positions for the moved piece
  	    	movedPiece.giveNewdirections();// Calculates nw,ne,sw,se for bishop and queen Added 03.06.21
 	    	opponent.calculateOpponentActions( game.getActiveState());   
 // 	    	opponent.calculateOpponentPositions(); This call is replaced by the call to calculateOpponentActions
//   	    	game.getActiveState().switchActivePlayer(); // OBS 11.08.20: Must ensure that player now switches to the game player (white) New 16.04.20 After a move, must switch active player
   	    	game.getActiveState().returnMyplayer();
   	    	game.getGame().createNewboard();
   	    	System.out.println(game.getGame().getBoardPic());
//   	    	game.getGame().setChosenPlayer(); // This method is only used at startup OLJ 20.04.20
   	    	
   	    	game.proposeMove(); //The game object proposes the next move for player
   	    	AgamePiece playerPiece = game.getLastPiece();
   	    	piece = playerPiece.getMyPiece().getName();
   	    	snewPosition = game.getNewPosition().getPositionName();
   	    	soldPosition = game.getOldPosition().getPositionName();
     	    fen = chessBoard.createFen();
//   	    System.out.println("Piece name "+chessPiece.getOntlogyName());
     	    System.out.println("moved piece "+piece+" "+fen);
   	    	System.out.println(game.getGame().getBoardPic());
 /*  	    	for (ChessMoves move:chessMoves) {
   	    		System.out.println(move.toString());
   	    	}*/
   	    } // End opponent move
/*   	 if (game != null && findTilgjengelig) { // 
	    	APlayer opponent = game.getActiveState().getOpponent();
	    	Position oldPosition = chessBoard.findPostion(oldPos);
	    	Position newPosition = chessBoard.findPostion(newPos);
   	    	HashMap<String,Position> allMoves =  movedPiece.getLegalmoves();
   	    	Set<String> keySet = allMoves.keySet();
   	    	ArrayList<String> listOfKeys = new ArrayList<String>(keySet);
   	    	ArrayList<Position> allMoveslist = new ArrayList<>(allMoves.values());
   	    	availableMoves.addAll(allMoveslist);
   	    	availablePosNames = new ArrayList<String>();
 	    	for (Position pos:availableMoves) {
 	    		availablePosNames.add(pos.getPositionName());
 	    	}
   	 }*/
   	 if (availablePosNames == null) {
	 	availablePosNames = new ArrayList<String>();
		 	availablePosNames.add("yy");
   	 }
 /*  The below code has been replaced by call to produceTemplate	
*/

        return produceTemplate(siden,dataModel,fen,chessBoard);
!!!2566530.java!!!	collectParameters(in posisjon : String, in mpiece : String, in startposisjon : String, in tilgjengeligpos : String) : void
    	
    	if(posisjon != null)
    		newPos = posisjon;
    	if(mpiece != null)
    		piece = mpiece;
    	if(startposisjon != null)
    		oldPos = startposisjon;
    	if(tilgjengeligpos != null)
    		tilgjengeligPos = tilgjengeligpos;
 
!!!2566658.java!!!	produceTemplate(in siden : String, inout dataModel : Map<String,Object>, in fen : String, inout chessBoard : ChessBoard) : Response
//    	TemplateRepresentation  templateRep = null;
      	 dataModel.put(fenPosid,fen);
       	 SimpleScalar pieceMoved = new SimpleScalar(piece);
       	 SimpleScalar movedTo = new SimpleScalar(snewPosition);
       	 SimpleScalar movedfrom = new SimpleScalar(soldPosition);
       	 SimpleScalar chessPosition = new SimpleScalar(position);
       	 dataModel.put(newPosId,movedTo );
       	 dataModel.put(oldPosId,movedfrom );
       	 dataModel.put(displayKey, chessPosition);
       	 dataModel.put(pieceId,pieceMoved );
       	 establishRules(chessBoard);
       	 //		dataModel.put(pieceId,simple );
       	 dataModel.put(rulesKey,chessRules);
       	 dataModel.put(movesKey, chessMoves);
       	 dataModel.put(availableKey, availablePosNames);
       	 //  	 	dataModel.put(blackmovesKey, blackMoves);

       	 //		 dataModel.put(pawnId,whitePawn1);
      	 FreemarkerView view = new FreemarkerView(siden, dataModel);
     	return Response.ok(view).build();
!!!1840002.java!!!	castleMove(inout castle : AgamePiece, inout newPosition : Position, inout opponent : APlayer, inout chessBoard : ChessBoard) : Position
    	String posName = newPosition.getPositionName();
    	Position castlePos =null;
      	String pieceName = castle.getMyPiece().getOntlogyName();
      	boolean castleCheck = false;
       	System.out.println("Checking castling");
    	if (opponent.getPlayerName() == opponent.getBlackPlayer()) {
        	if (posName.equals("c8") && pieceName.equals("BlackRook1")) {
        		System.out.println("Correct piece "+castle.toString());
        		castlePos = chessBoard.findPostion("d8");
        		castleCheck = true;
        	}
        	if (posName.equals("g8") && pieceName.equals("BlackRook2")) {
        		System.out.println("Correct piece "+castle.toString());
        		castlePos = chessBoard.findPostion("f8");
        		castleCheck = true;
        	}
    	}
       	if (opponent.getPlayerName() == opponent.getWhitePlayer()) {
        	if (posName.equals("c1") && pieceName.equals("WhiteRook1")) {
        		System.out.println("Correct piece "+castle.toString());
        		castlePos = chessBoard.findPostion("d1");
        		castleCheck = true;
        	}
        	if (posName.equals("g1") && pieceName.equals("WhiteRook2")) {
        		System.out.println("Correct piece "+castle.toString());
        		castlePos = chessBoard.findPostion("f1");
        		castleCheck = true;
        	}
       	}
       	return castlePos;
    	
