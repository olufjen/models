class FOLOTTERLikeTheoremProver
!!!295554.java!!!	FOLOTTERLikeTheoremProver()

!!!295682.java!!!	FOLOTTERLikeTheoremProver(in maxQueryTime : long)
		setMaxQueryTime(maxQueryTime);
!!!295810.java!!!	FOLOTTERLikeTheoremProver(inout useParamodulation : boolean)
		setUseParamodulation(useParamodulation);
!!!295938.java!!!	FOLOTTERLikeTheoremProver(in maxQueryTime : long, inout useParamodulation : boolean)
		setMaxQueryTime(maxQueryTime);
		setUseParamodulation(useParamodulation);
!!!296066.java!!!	getMaxQueryTime() : long
		return maxQueryTime;
!!!296194.java!!!	setMaxQueryTime(in maxQueryTime : long) : void
		this.maxQueryTime = maxQueryTime;
!!!296322.java!!!	isUseParamodulation() : boolean
		return useParamodulation;
!!!296450.java!!!	setUseParamodulation(inout useParamodulation : boolean) : void
		this.useParamodulation = useParamodulation;
!!!296578.java!!!	getLightestClauseHeuristic() : LightestClauseHeuristic
		return lightestClauseHeuristic;
!!!296706.java!!!	setLightestClauseHeuristic(inout lightestClauseHeuristic : LightestClauseHeuristic) : void
		this.lightestClauseHeuristic = lightestClauseHeuristic;
!!!296834.java!!!	getClauseFilter() : ClauseFilter
		return clauseFilter;
!!!296962.java!!!	setClauseFilter(inout clauseFilter : ClauseFilter) : void
		this.clauseFilter = clauseFilter;
!!!297090.java!!!	getClauseSimplifier() : ClauseSimplifier
		return clauseSimplifier;
!!!297218.java!!!	setClauseSimplifier(inout clauseSimplifier : ClauseSimplifier) : void
		this.clauseSimplifier = clauseSimplifier;
!!!297346.java!!!	ask(inout KB : FOLKnowledgeBase, inout alpha : Sentence) : InferenceResult
		Set<Clause> sos = new HashSet<Clause>();
		Set<Clause> usable = new HashSet<Clause>();

		// Usable set will be the set of clauses in the KB,
		// are assuming this is satisfiable as using the
		// Set of Support strategy.
		for (Clause c : KB.getAllClauses()) {
			c = KB.standardizeApart(c);
			c.setStandardizedApartCheckNotRequired();
			usable.addAll(c.getFactors());
		}

		// Ensure reflexivity axiom is added to usable if using paramodulation.
		if (isUseParamodulation()) {
			// Reflexivity Axiom: x = x
			TermEquality reflexivityAxiom = new TermEquality(new Variable("x"),
					new Variable("x"));
			Clause reflexivityClause = new Clause();
			reflexivityClause.addLiteral(new Literal(reflexivityAxiom));
			reflexivityClause = KB.standardizeApart(reflexivityClause);
			reflexivityClause.setStandardizedApartCheckNotRequired();
			usable.add(reflexivityClause);
		}

		Sentence notAlpha = new NotSentence(alpha);
		// Want to use an answer literal to pull
		// query variables where necessary
		Literal answerLiteral = KB.createAnswerLiteral(notAlpha);
		Set<Variable> answerLiteralVariables = KB
				.collectAllVariables(answerLiteral.getAtomicSentence());
		Clause answerClause = new Clause();

		if (answerLiteralVariables.size() > 0) {
			Sentence notAlphaWithAnswer = new ConnectedSentence(Connectors.OR,
					notAlpha, answerLiteral.getAtomicSentence());
			for (Clause c : KB.convertToClauses(notAlphaWithAnswer)) {
				c = KB.standardizeApart(c);
				c.setProofStep(new ProofStepGoal(c));
				c.setStandardizedApartCheckNotRequired();
				sos.addAll(c.getFactors());
			}

			answerClause.addLiteral(answerLiteral);
		} else {
			for (Clause c : KB.convertToClauses(notAlpha)) {
				c = KB.standardizeApart(c);
				c.setProofStep(new ProofStepGoal(c));
				c.setStandardizedApartCheckNotRequired();
				sos.addAll(c.getFactors());
			}
		}

		// Ensure all subsumed clauses are removed
		usable.removeAll(SubsumptionElimination.findSubsumedClauses(usable));
		sos.removeAll(SubsumptionElimination.findSubsumedClauses(sos));

		OTTERAnswerHandler ansHandler = new OTTERAnswerHandler(answerLiteral,
				answerLiteralVariables, answerClause, maxQueryTime);

		IndexedClauses idxdClauses = new IndexedClauses(
				getLightestClauseHeuristic(), sos, usable);

		return otter(ansHandler, idxdClauses, sos, usable);
!!!297474.java!!!	otter(inout ansHandler : FOLOTTERLikeTheoremProver::OTTERAnswerHandler, inout idxdClauses : FOLOTTERLikeTheoremProver::IndexedClauses, inout sos : Set<Clause>, inout usable : Set<Clause>) : InferenceResult

		getLightestClauseHeuristic().initialSOS(sos);

		// * repeat
		do {
			// * clause <- the lightest member of sos
			Clause clause = getLightestClauseHeuristic().getLightestClause();
			if (null != clause) {
				// * move clause from sos to usable
				sos.remove(clause);
				getLightestClauseHeuristic().removedClauseFromSOS(clause);
				usable.add(clause);
				// * PROCESS(INFER(clause, usable), sos)
				process(ansHandler, idxdClauses, infer(clause, usable), sos,
						usable);
			}

			// * until sos = [] or a refutation has been found
		} while (sos.size() != 0 && !ansHandler.isComplete());

		return ansHandler;
!!!297602.java!!!	infer(inout clause : Clause, inout usable : Set<Clause>) : Clause
		Set<Clause> resultingClauses = new LinkedHashSet<Clause>();

		// * resolve clause with each member of usable
		for (Clause c : usable) {
			Set<Clause> resolvents = clause.binaryResolvents(c);
			for (Clause rc : resolvents) {
				resultingClauses.add(rc);
			}

			// if using paramodulation to handle equality
			if (isUseParamodulation()) {
				Set<Clause> paras = paramodulation.apply(clause, c, true);
				for (Clause p : paras) {
					resultingClauses.add(p);
				}
			}
		}

		// * return the resulting clauses after applying filter
		return getClauseFilter().filter(resultingClauses);
!!!297730.java!!!	process(inout ansHandler : FOLOTTERLikeTheoremProver::OTTERAnswerHandler, inout idxdClauses : FOLOTTERLikeTheoremProver::IndexedClauses, inout clauses : Set<Clause>, inout sos : Set<Clause>, inout usable : Set<Clause>) : void

		// * for each clause in clauses do
		for (Clause clause : clauses) {
			// * clause <- SIMPLIFY(clause)
			clause = getClauseSimplifier().simplify(clause);

			// * merge identical literals
			// Note: Not required as handled by Clause Implementation
			// which keeps literals within a Set, so no duplicates
			// will exist.

			// * discard clause if it is a tautology
			if (clause.isTautology()) {
				continue;
			}

			// * if clause has no literals then a refutation has been found
			// or if it just contains the answer literal.
			if (!ansHandler.isAnswer(clause)) {
				// * sos <- [clause | sos]
				// This check ensure duplicate clauses are not
				// introduced which will cause the
				// LightestClauseHeuristic to loop continuously
				// on the same pair of objects.
				if (!sos.contains(clause) && !usable.contains(clause)) {
					for (Clause ac : clause.getFactors()) {
						if (!sos.contains(ac) && !usable.contains(ac)) {
							idxdClauses.addClause(ac, sos, usable);

							// * if clause has one literal then look for unit
							// refutation
							lookForUnitRefutation(ansHandler, idxdClauses, ac,
									sos, usable);
						}
					}
				}
			}

			if (ansHandler.isComplete()) {
				break;
			}
		}
!!!297858.java!!!	lookForUnitRefutation(inout ansHandler : FOLOTTERLikeTheoremProver::OTTERAnswerHandler, inout idxdClauses : FOLOTTERLikeTheoremProver::IndexedClauses, inout clause : Clause, inout sos : Set<Clause>, inout usable : Set<Clause>) : void

		Set<Clause> toCheck = new LinkedHashSet<Clause>();

		if (ansHandler.isCheckForUnitRefutation(clause)) {
			for (Clause s : sos) {
				if (s.isUnitClause()) {
					toCheck.add(s);
				}
			}
			for (Clause u : usable) {
				if (u.isUnitClause()) {
					toCheck.add(u);
				}
			}
		}

		if (toCheck.size() > 0) {
			toCheck = infer(clause, toCheck);
			for (Clause t : toCheck) {
				// * clause <- SIMPLIFY(clause)
				t = getClauseSimplifier().simplify(t);

				// * discard clause if it is a tautology
				if (t.isTautology()) {
					continue;
				}

				// * if clause has no literals then a refutation has been found
				// or if it just contains the answer literal.
				if (!ansHandler.isAnswer(t)) {
					// * sos <- [clause | sos]
					// This check ensure duplicate clauses are not
					// introduced which will cause the
					// LightestClauseHeuristic to loop continuously
					// on the same pair of objects.
					if (!sos.contains(t) && !usable.contains(t)) {
						idxdClauses.addClause(t, sos, usable);
					}
				}

				if (ansHandler.isComplete()) {
					break;
				}
			}
		}
