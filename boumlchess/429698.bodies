class APerceptor
!!!2077570.java!!!	APerceptor(inout posin : Position, in reach : String, in type : String, in typeofPiece : String, in playerName : String)
		  super();
		  setPredicatenames();
		  this.playerName = playerName;
		  ChessVariables.setPlayerName(playerName);
		  mypieceNames = new ArrayList<String>();
		  pos = posin;
		  String posname = pos.getPositionName();
		  reaches = reach;
		  types = type;
		  pieceName = new Variable("piecename");
		  typeTerms = new ArrayList<Term>();
		  typeTerms.add(pieceName); // Two terms for the piecetype predicate
		  if (typeofPiece == null) {
			  pieceType = new Variable("type");
			  typeTerms.add(pieceType);
		  }else {
			  typePiece = new Constant(typeofPiece);
			  typeTerms.add(typePiece);
		  }
		  topos = new Constant(posname);
		  precondition = new ArrayList();
		  reachTerms = new ArrayList<Term>();
		  variables = new ArrayList<Term>();
		  reachTerms.add(pieceName); // Two terms for the reachable predicate
		  reachTerms.add(topos);
		  variables.addAll(reachTerms);
		  variables.addAll(typeTerms);
		  reachPredicate = new Predicate(reaches,reachTerms);
		  typePredicate = new Predicate(types,typeTerms);
		  precondition.add(new Literal((AtomicSentence) reachPredicate));
		  precondition.add(new Literal((AtomicSentence)typePredicate));
		  percept = new PerceptSchema("MOVE",variables,precondition);
		  propinitStates = new ArrayList<State>();
		  propgoalStates = new ArrayList<State>();
		  try {
			  fw = new FileWriter(outputFileName, true);
		  } catch (IOException e1) {

			  e1.printStackTrace();
		  }
		  writer = new PrintWriter(new BufferedWriter(fw));	
!!!2086274.java!!!	setPredicatenames() : void
		  ACTION = KnowledgeBuilder.getACTION();
		  ATTACKED = KnowledgeBuilder.getATTACKED();
		  CANMOVE = KnowledgeBuilder.getCANMOVE();
		  CAPTURE =  KnowledgeBuilder.getCAPTURE();
		  CONQUER = KnowledgeBuilder.getCONQUER();
		  MOVE =  KnowledgeBuilder.getMOVE();
		  OWNER = KnowledgeBuilder.getOWNER();
		  PROTECTED =  KnowledgeBuilder.getPROTECTED();
		  REACHABLE = KnowledgeBuilder.getREACHABLE();
		  SAFEMOVE = KnowledgeBuilder.getSAFEMOVE();
		  STRIKE = KnowledgeBuilder.getSTRIKE();
		  simpleProtected =  KnowledgeBuilder.getSimpleProtected();
		  THREATEN = KnowledgeBuilder.getTHREATEN();
		  PIECETYPE = KnowledgeBuilder.getPIECETYPE();
		  PLAY = 	KnowledgeBuilder.getPLAY();
		  PAWN = KnowledgeBuilder.getPAWN();
		  KNIGHT = KnowledgeBuilder.getKNIGHT();
		  BISHOP = KnowledgeBuilder.getBISHOP();
		  ROOK = KnowledgeBuilder.getROOK();
		  KING = KnowledgeBuilder.getKING();
		  QUEEN = KnowledgeBuilder.getQUEEN();
		  PIECE = KnowledgeBuilder.getPIECE();
		  OCCUPIES = KnowledgeBuilder.getOCCUPIES();
		  PAWNMOVE = KnowledgeBuilder.getPAWNMOVE();
		  PAWNATTACK = KnowledgeBuilder.getPAWNATTACK();
		  BOARD = KnowledgeBuilder.getBOARD();
		  PLAYER = KnowledgeBuilder.getPLAYER();
		  CASTLE = KnowledgeBuilder.getCASTLE();
		  OPPONENTTO = KnowledgeBuilder.getOPPONENTTO();
		  POSSIBLETHREAT = KnowledgeBuilder.getPOSSIBLETHREAT();
		  POSSIBLEPROTECT = KnowledgeBuilder.getPOSSIBLEPROTECT();
		  POSSIBLEREACH = KnowledgeBuilder.getPOSSIBLEREACH();
!!!2186370.java!!!	getOtherActions() : ActionSchema
		  return otherActions;
!!!2186498.java!!!	setOtherActions(inout otherActions : List<ActionSchema>) : void
		  this.otherActions = otherActions;
!!!2186626.java!!!	getOtherSchemas() : ActionSchema
		  return otherSchemas;
!!!2186754.java!!!	setOtherSchemas(inout otherSchemas : Set<ActionSchema>) : void
		  this.otherSchemas = otherSchemas;
!!!2186882.java!!!	getInitState() : State
		  return initState;
!!!2187010.java!!!	setInitState(inout initState : State) : void
		  this.initState = initState;
!!!2187138.java!!!	getGoalState() : State
		  return goalState;
!!!2187266.java!!!	setGoalState(inout goalState : State) : void
		  this.goalState = goalState;
!!!2187394.java!!!	getInitialStates() : List<List>
		  return initialStates;
!!!2187522.java!!!	setInitialStates(inout initialStates : List<List>) : void
		  this.initialStates = initialStates;
!!!2187650.java!!!	getGoalStates() : State
		  return goalStates;
!!!2187778.java!!!	setGoalStates(inout goalStates : Map<String, State>) : void
		  this.goalStates = goalStates;
!!!2175874.java!!!	getAgent() : OpponentAgent
		  return agent;
!!!2187906.java!!!	getInitStates() : State
		return initStates;
!!!2188034.java!!!	setInitStates(inout initStates : Map<String, State>) : void
		this.initStates = initStates;
!!!2176002.java!!!	setAgent(inout agent : OpponentAgent) : void
		  this.agent = agent;
!!!2176130.java!!!	getMyPlayer() : APlayer
		  return myPlayer;
!!!2176258.java!!!	setMyPlayer(inout myPlayer : APlayer) : void
		  this.myPlayer = myPlayer;
!!!2176386.java!!!	getOpponent() : APlayer
		  return opponent;
!!!2176514.java!!!	setOpponent(inout opponent : APlayer) : void
		  this.opponent = opponent;
!!!2176642.java!!!	getFolKb() : ChessFolKnowledgeBase
		  return folKb;
!!!2176770.java!!!	setFolKb(inout folKb : ChessFolKnowledgeBase) : void
		  this.folKb = folKb;
!!!2176898.java!!!	getLocalKb() : ChessFolKnowledgeBase
		  return localKb;
!!!2177026.java!!!	setLocalKb(inout localKb : ChessFolKnowledgeBase) : void
		  this.localKb = localKb;
!!!2077698.java!!!	getPercept() : PerceptSchema
	return percept;
!!!2077826.java!!!	setPercept(inout percept : PerceptSchema) : void
	this.percept = percept;
!!!2077954.java!!!	getPieceName() : Variable
	return pieceName;
!!!2078082.java!!!	setPieceName(inout pieceName : Variable) : void
	this.pieceName = pieceName;
!!!2078210.java!!!	getPieceType() : Variable
	return pieceType;
!!!2078338.java!!!	setPieceType(inout pieceType : Variable) : void
	this.pieceType = pieceType;
!!!2078466.java!!!	getPos() : Position
	return pos;
!!!2078594.java!!!	setPos(inout pos : Position) : void
	this.pos = pos;
!!!2177154.java!!!	getPlayerPiece() : AgamePiece
		return playerPiece;
!!!2177282.java!!!	setPlayerPiece(inout playerPiece : AgamePiece) : void
		this.playerPiece = playerPiece;
!!!2078722.java!!!	checkPercept(inout initStates : Map<String,State>) : State
		  List<AgamePiece> pieces = myPlayer.getMygamePieces();
		  List<State> allStates = new ArrayList<State>(initStates.values());
		  List<Constant> stateconstants = new ArrayList<Constant>();
		  List<Literal> preconditions = percept.getPrecondition();
		  for (State state:allStates) {
			  List<Literal> literals = state.getFluents(); // The initial states have only ground atoms
			  for (Literal lit:literals) {
				  Predicate p = (Predicate) lit.getAtomicSentence();
				  List<Term> terms = p.getTerms(); // Must find the correct type of constants, piece piecetype etc!!
				  for (Term t:terms) {
					  Constant c = (Constant)t;
					  if (!stateconstants.contains(t))
						  stateconstants.add(c);
				  }
			  }
			  PerceptSchema conPercept = percept.getActionBySubstitution(stateconstants); // Create a percept with only ground atoms
			  boolean found = state.getFluents().containsAll(conPercept.getPrecondition());//is applicable in state s if the precondition of the percept action is satisfied by s.
			  if (found) {
				  for (Constant c:stateconstants) {
					  String cn = c.getValue();
					  AgamePiece thepiece = (AgamePiece) pieces.stream().filter(p -> p.getMyPiece().getOntlogyName().contains(cn)).findAny().orElse(null);
					  if (thepiece != null) {
						  playerPiece = thepiece;
						  break;
					  }
				  }
			  }
			  stateconstants.clear();
			  if (found) {
				  return state;
			  }
		  }
		  return null;
!!!2177410.java!!!	findReachable(inout position : Position) : void
		  List<AgamePiece> pieces = myPlayer.getMygamePieces();
		  List<String>thepieceNames = myPlayer.getPieceNames();
		  List<String> pieceNames = new ArrayList<String>();
		  for (String fullName:thepieceNames) {
			  String apieceName = KnowledgeBuilder.extractString(fullName, '#',-1);
			  pieceNames.add(apieceName);
			  mypieceNames.add(apieceName);
		  }
		  for (String apieceName:pieceNames) {
			  AgamePiece thepiece = (AgamePiece) pieces.stream().filter(c -> c.getMyPiece().getOntlogyName().contains(apieceName)).findAny().orElse(null);
			  createKnowledgefacts(thepiece, position);
		  }

!!!2177538.java!!!	createKnowledgefacts(inout piece : AgamePiece, inout position : Position) : void
		  ChessPiece chessPiece = piece.getMyPiece();
		  String newPosname = position.getPositionName();
		  ABishop bishop = null;
		  ARook rook = null;
		  AKnight knight = null;
		  AQueen queen = null;
		  Aking king = null;
		  APawn pawn = null; 
		  String predicate = null;
		  HashMap<String,Position> reachables = null;

		  HashMap<String,Position>piecereachables = piece.getReacablePositions();
		  List<Position>removed = piece.getRemovedPositions();
		  Position piecePosition = piece.getmyPosition();
		  String piecePosname = piecePosition.getPositionName();
		  if (piece.getMybishop() != null) {
			  bishop = new ABishop(position,chessPiece);
			  reachables = bishop.getLegalmoves();
			  predicate = agent.getBISHOP();
		  }
		  if (piece.getMyrook() != null) {
			  rook = new ARook(position,chessPiece);
			  reachables = rook.getLegalmoves();
			  predicate = agent.getROOK();
		  }
		  if (piece.getMyKnight() != null) {
			  knight = new AKnight(position,chessPiece);
			  reachables = knight.getLegalmoves();
			  predicate = agent.getKNIGHT();
		  }
		  if (piece.getMyqueen() != null) {
			  queen = new AQueen(position,chessPiece);
			  reachables = queen.getLegalmoves();
			  predicate = agent.getQUEEN();
		  }
		  if (piece.getMyKing() != null) {
			  king = new Aking(position,chessPiece);
			  reachables = king.getLegalmoves();
			  predicate = agent.getKING();
		  }	 
		  if (piece.getMyPawn() != null) {
			  pawn = new APawn(position,chessPiece);
			  reachables = pawn.getAttackPositions();
			  predicate = agent.getPAWN();
		  }
		  if(reachables != null && !reachables.isEmpty()) {
			  List<Position> reachablelist = new ArrayList<Position>(reachables.values());
			  for (Position pos:reachablelist) {
				  String posName = pos.getPositionName();
				  //				writer.println("Bishop Reachable to Kings position from "+posName + " King at "+opponentKingPosition);
				  localKb.createfacts(predicate,newPosname, posName); // To strategy knowledge base
			  }
		  }
		  if(piecereachables != null && !piecereachables.isEmpty()) {
			  List<Position> reachablelist = new ArrayList<Position>(piecereachables.values());
			  for (Position pos:reachablelist) {
				  String posName = pos.getPositionName();
				  if(removed != null && !removed.isEmpty()) {
					  Position removedPos = (Position) removed.stream().filter(c -> c.getPositionName().contains(posName)).findAny().orElse(null);
					  if(removedPos == null) {
						  folKb.createfacts(predicate,piecePosname, posName); // To parent knowledge base
					  }
				  }
				  if(removed != null && removed.isEmpty()) {
					  folKb.createfacts(predicate,piecePosname, posName); // To parent knowledge base
				  }
				  if(removed == null) {
					  folKb.createfacts(predicate,piecePosname, posName); // To parent knowledge base
				  }
			  }
		  }
!!!2188162.java!!!	createLiftedActions(inout  : String...names) : void
		  writer.println("Actions with ");
		  ActionSchema occupy = KnowledgeBuilder.createOccupyaction(names); // Creates a lifted action schema
		  writer.println(occupy.toString());
		  otherActions = KnowledgeBuilder.findApplicable(initStates,occupy); // Returns propositionalized action schemas from the lifted action schemas
		  otherSchemas =  new HashSet<ActionSchema>(otherActions);
		
		  State theInitState = null; // A determined init state for the Problem
	      State theGoal = null;		// A determined goalState for the Problem
		  for (ActionSchema primitiveAction :
			   otherActions) {	 
			  writer.println(primitiveAction.toString());
		  }
		  List<State> allStates = new ArrayList<State>(initStates.values()); // All Init states from all available action schemas
		  List<State> allGoals = new ArrayList<State>(goalStates.values()); // All goal states from all available action schemas
	/*
	 * A procedure to determine a possible initial state
	 */
		  writer.println("New goal states - testing the result function");
		  for (State state:allStates) { // For all the initial states:
			  State agoalState = state.result(otherActions); // Given a list of propostionalized action schema the result function returns a goal state
			  boolean found = state.getFluents().containsAll(agoalState.getFluents()); // Could any of the initial states entail the new goal state?
			  if (!found) { // If not check if the new goal state entails the given goal state
				  writer.println("A possible goal state not entailed by an init state");
			      boolean agree = false;
			      for (State goalstate:allGoals) {
			    	  agree = agoalState.getFluents().containsAll(goalstate.getFluents());// A possible goal state entails the given goal state
			    	  if (agree) {
			    		  theGoal = goalstate; // The goal state has been found
			    		  propgoalStates.add(theGoal);
			    		  break;
			    	  }
			      }
			      if (agree) {
			    	  writer.println("Found the goal state");
				      for (Literal literal :
				    	  agoalState.getFluents()) {
				    	 writer.println(literal.toString());
				      } 
			      }
		      
			      if (agree) { // When this is true we have found the current init state
			    	  writer.println("A possible goal state entails the given goal state");
				      for (Literal literal :
				    	  theGoal.getFluents()) {
				    	 writer.println(literal.toString());
				      }
				      theInitState = state; // The initial state has been found
				      propinitStates.add(theInitState);
				      writer.println("--");
				      writer.println("And the init state is"); // This is then the current initial state
				      for (Literal literal :
				    	  state.getFluents()) {
				    	 writer.println(literal.toString());
				      } 
			      }
		//		  writer.println(agoalState.toString());  
			  }else {
/*				  writer.println("A possible init state");
			      for (Literal literal :
			    	  state.getFluents()) {
			    	 writer.println(literal.toString());
			      }
			      writer.println("For this goal state");
			      for (Literal literal :
			    	  agoalState.getFluents()) {
			    	 writer.println(literal.toString());
			      }*/
			      boolean agree = false;
			      for (State goalstate:allGoals) {
			    	  agree = agoalState.getFluents().containsAll(goalstate.getFluents());
			    	  if (agree) {
			    		  theGoal = goalstate;
			    		  break;
			    	  }
			      }
			     
			      if (agree) { // Never found !!! ????
			    	  writer.println("A possible goal state entails the given goal state in agreement with init state");
				      for (Literal literal :
				    	  theGoal.getFluents()) {
				    	 writer.println(literal.toString());
				      }
			      }
			  }

		  }
		  initState = theInitState;
		  goalState = theGoal;
		  writer.flush();
