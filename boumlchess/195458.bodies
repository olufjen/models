class BidirectionalSearch
!!!468738.java!!!	BidirectionalSearch()
		this(new NodeExpander<>());
!!!468866.java!!!	BidirectionalSearch(inout nodeExpander : NodeExpander)
		super(nodeExpander);
		explored = new ArrayList<>(2);
		explored.add(new HashMap<>());
		explored.add(new HashMap<>());
!!!468994.java!!!	findNode(inout problem : Problem, inout frontier : Queue<Node<S, A>>) : Node
		assert (problem instanceof BidirectionalProblem);

		nodeExpander.useParentLinks(true); // bidirectional search needs parents!
		this.frontier = frontier;
		clearMetrics();
		explored.get(ORG_P_IDX).clear();
		explored.get(REV_P_IDX).clear();

		Problem<S, A> orgP = ((BidirectionalProblem<S, A>) problem).getOriginalProblem();
		Problem<S, A> revP = ((BidirectionalProblem<S, A>) problem).getReverseProblem();
		ExtendedNode<S, A> initStateNode;
		initStateNode = new ExtendedNode<>(nodeExpander.createRootNode(orgP.getInitialState()), ORG_P_IDX);
		goalStateNode = new ExtendedNode<>(nodeExpander.createRootNode(revP.getInitialState()), REV_P_IDX);

		if (orgP.getInitialState().equals(revP.getInitialState()))
			return getSolution(orgP, initStateNode, goalStateNode);

		// initialize the frontier using the initial state of the problem
		addToFrontier(initStateNode);
		addToFrontier(goalStateNode);

		while (!isFrontierEmpty() && !Tasks.currIsCancelled()) {
			// choose a leaf node and remove it from the frontier
			ExtendedNode<S, A> nodeToExpand = (ExtendedNode) removeFromFrontier();
			ExtendedNode<S, A> nodeFromOtherProblem;

			// if the node contains a goal state then return the
			// corresponding solution
			if (!earlyGoalTest && (nodeFromOtherProblem = getCorrespondingNodeFromOtherProblem(nodeToExpand)) != null)
				return getSolution(orgP, nodeToExpand, nodeFromOtherProblem);

			// expand the chosen node, adding the resulting nodes to the
			// frontier
			for (Node<S, A> s : nodeExpander.expand(nodeToExpand, problem)) {
				ExtendedNode<S, A> successor = new ExtendedNode<>(s, nodeToExpand.getProblemIndex());
				if (!isReverseActionTestEnabled || nodeToExpand.getProblemIndex() == ORG_P_IDX
						|| getReverseAction(orgP, successor) != null) {

					if (earlyGoalTest
							&& (nodeFromOtherProblem = getCorrespondingNodeFromOtherProblem(successor)) != null)
						return getSolution(orgP, successor, nodeFromOtherProblem);

					addToFrontier(successor);
				}
			}
		}
		// if the frontier is empty then return failure
		return Optional.empty();
!!!469122.java!!!	setReverseActionTestEnabled(inout b : boolean) : void
		isReverseActionTestEnabled = b;
!!!469250.java!!!	addToFrontier(inout node : Node) : void
		if (!isExplored(node)) {
			frontier.add(node);
			updateMetrics(frontier.size());
		}
!!!469378.java!!!	removeFromFrontier() : Node
		cleanUpFrontier(); // not really necessary because isFrontierEmpty
							// should be called before...
		Node<S, A> result = frontier.remove();
		updateMetrics(frontier.size());
		// add the node to the explored set of the corresponding problem
		setExplored(result);
		return result;
!!!469506.java!!!	isFrontierEmpty() : boolean
		cleanUpFrontier();
		updateMetrics(frontier.size());
		return frontier.isEmpty();
!!!469634.java!!!	cleanUpFrontier() : void
		while (!frontier.isEmpty() && isExplored(frontier.element()))
			frontier.remove();
!!!469762.java!!!	getSolution(inout orgP : Problem, inout node1 : BidirectionalSearch::ExtendedNode, inout node2 : BidirectionalSearch::ExtendedNode) : Node
		assert node1.getState().equals(node2.getState());
		
		Node<S, A> orgNode = node1.getProblemIndex() == ORG_P_IDX ? node1 : node2;
		Node<S, A> revNode = node1.getProblemIndex() == REV_P_IDX ? node1 : node2;

		while (revNode.getParent() != null) {
			A action = getReverseAction(orgP, revNode);
			if (action != null) {
				S nextState = revNode.getParent().getState();
				double stepCosts = orgP.getStepCosts(revNode.getState(), action, nextState);
				orgNode = nodeExpander.createNode(nextState, orgNode, action, stepCosts);
				revNode = revNode.getParent();
			} else {
				return Optional.empty();
			}
		}
		metrics.set(METRIC_PATH_COST, orgNode.getPathCost());
		return Optional.of(orgNode);
!!!469890.java!!!	getReverseAction(inout orgP : Problem, inout node : Node) : A
		S currState = node.getState();
		S nextState = node.getParent().getState();

		for (A action : orgP.getActions(currState)) {
			S aResult = orgP.getResult(currState, action);
			if (nextState.equals(aResult))
				return action;
		}
		return null;
!!!470018.java!!!	isExplored(inout node : Node) : boolean
		ExtendedNode<S, A> eNode =  (ExtendedNode) node;
		return explored.get(eNode.getProblemIndex()).containsKey(eNode.getState());
!!!470146.java!!!	setExplored(inout node : Node) : void
		ExtendedNode<S, A> eNode = (ExtendedNode) node;
		explored.get(eNode.getProblemIndex()).put(eNode.getState(), eNode);
!!!470274.java!!!	getCorrespondingNodeFromOtherProblem(inout node : BidirectionalSearch::ExtendedNode) : BidirectionalSearch::ExtendedNode
		ExtendedNode<S, A> result = explored.get(1 - node.getProblemIndex()).get(node.getState());

		// Caution: The goal test of the original problem should always include
		// the root node of the reverse problem as that node might not yet have
		// been explored yet. This is important if the reverse problem does not
		// provide reverse actions for all original problem actions.
		if (result == null && node.getProblemIndex() == ORG_P_IDX && node.getState() == goalStateNode.getState())
			result = goalStateNode;
		return result;
