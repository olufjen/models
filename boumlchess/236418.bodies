class PreferredMoveProcessor
!!!797442.java!!!	PreferredMoveProcessor(inout processNumber : Integer, in pname : String)
		super();
		this.processNumber = processNumber;
//		this.processNumber = processNumber;
		String pNumber = processNumber.toString();
		outputFileName = outputFileName + "preferredmove"+pname + pNumber+".txt";
		try {
			fw = new FileWriter(outputFileName, true);
		} catch (IOException e1) {

			e1.printStackTrace();
		}
	      writer = new PrintWriter(new BufferedWriter(fw));		

!!!797570.java!!!	processChessObject(inout action : ChessActionImpl, inout p : AgamePiece) : ApieceMove
		HashMap<String,Position> reacablePositions = null;
		HashMap<String,Position> bishopPositions = null;
		List<Position> queenscastlePositions = null;
		List<Position> queenbishopPositions = null;
		List<Position>opponentRemoved = action.getOpponentRemoved();
		removedPositions =  (List<Position>) action.getPositionRemoved(); // Removed positions are positions occupied by friendly pieces
		List<Position> availablePositions = (List<Position>) action.getAvailablePositions();
		List<Position> preferredPositions = new ArrayList<>();
		Position preferredPosition = null;
		Position from = p.getmyPosition();
		
		String name =action.getChessPiece().getMyPiece().getOntlogyName();
		String otherName = p.getMyPiece().getOntlogyName();
		
		if (name.equals(otherName) && name.contains("WhitePawn")){
			writer.println(name);
			HashMap<String,Position> attackPositions = p.getAttackPositions();
			List<Position> attackedPositions = new ArrayList(attackPositions.values());

			for (Position pos:attackedPositions) {
				writer.println("Attacking "+pos.toString());
			}
			
		}
/*		if (name.equals(otherName) && name.equals("WhiteBishop2")) {
			 System.out.println("PreferredMove: Checking bishop");
		}*/
		
		heldPosition = from;
		String color = p.getColor();
/*
 * Checking if piece is active: Added 21.04.20		
 */
		if (!p.isActive()) {
			writer.println("Piece taken 1: "+p.toString());
			return null;
		}
		if (!p.getMyPiece().isUse()) {
			writer.println("Piece taken 2: "+p.toString());
			p.setActive(false);
			return null;
		}
		List<Position> tempList = null;	
		APawn pn = null;
		ABishop b = null;
		ARook r = null;
		AQueen qt = null;
		AKnight kn = null;
		Aking king = null;
		tempList = new ArrayList<>();
		ChessPieceType pieceType = p.getChessType();
		boolean pawnType = false;
		if (pieceType instanceof Aking) {
			king = (Aking) pieceType; // Check if a castling position is not removed
			writer.println("Checking castle positions");
			List<Position> availableCastlePositions = king.checkRemovals(availablePositions,removedPositions);
			if (availableCastlePositions != null && !availableCastlePositions.isEmpty()) {
				availablePositions.addAll(availableCastlePositions);
				writer.println("Castle positions available");
			}
		}
		if (pieceType instanceof APawn) {
			String rName = p.getMyPiece().getOntlogyName();
//			List<Position>aposes = new ArrayList<Position>(p.getAttackPositions().values());
			if (rName.equals("WhitePawn3")) {
				writer.println("Removed before");
				for (Position ps:removedPositions) {
					writer.println(ps.toString());
				}
			}			
			pn = (APawn) pieceType;
			tempList = pn.checkPawnremovals(availablePositions, removedPositions);
			pawnType = true;
		}
		if (pieceType instanceof ABishop) {
			b = (ABishop) pieceType;
			setDirection(p, availablePositions); // Sets directions for all directions east,west south north, se,sw,ne,nw
			setDirection(p, removedPositions);
			tempList = b.checkRemovals(availablePositions, removedPositions);
			checkOpponentRemoved(opponentRemoved,from, tempList,availablePositions);
		}
		if (pieceType instanceof ARook) {
			r = (ARook) pieceType;
			setDirection(p, availablePositions);
			setDirection(p, removedPositions);
			setNSDirection(p, availablePositions);
			setNSDirection(p, removedPositions);
			List<Position>rooknorthsouthList = r.checkNorthSouthremovals(availablePositions, removedPositions);
			tempList.addAll(rooknorthsouthList);
			String rName = p.getMyPiece().getOntlogyName();
			checkOpponentRemoved(opponentRemoved,from, tempList,availablePositions);
			if (rName.contains("WhiteRook")) {
				writer.println("The white rook "+rName);
				writer.println("Piece "+p.toString());
			}
		}
		if (pieceType instanceof AQueen) {
			qt = (AQueen) pieceType;
			if (p.checkWhite()) {
				writer.println("The white queen");
			}
		
			setDirection(p, availablePositions);
			setDirection(p, removedPositions);
//			writer.println("the piece is a queen ");
			bishopRemoved = action.getBishopRemoved();
			bishopPositions = p.getBishopPositions();
			if (bishopPositions.isEmpty()) {
				writer.println("The bishop positions are empty !!!!");
			}
			reacablePositions = p.getReacablePositions();
			List<Position> queenAvailablepositions = p.getNewlistPositions();
			queenscastlePositions = new ArrayList(reacablePositions.values()); // The queen castle movements
			queenbishopPositions = new ArrayList(bishopPositions.values());		// The queen bishop movements
			setDirection(p, queenbishopPositions);
			setDirection(p,bishopRemoved);
			setNSDirection(p, queenscastlePositions);
			setNSDirection(p, removedPositions);
//			setDirection(p,queenscastlePositions);
			List<Position>queensTempList = qt.checkRemovals(queenbishopPositions, bishopRemoved);
			if (queensTempList.isEmpty()) {
				writer.println("The queens temp list is empty !!!!");
			}
			if (from.getPositionName().equals("b7")) {
				writer.println("The queens from position "+from.toString());
			}
			List<Position>queensnorthsouthList = qt.checkNorthSouthremovals(queenscastlePositions, removedPositions);
			tempList.addAll(queensTempList);
			tempList.addAll(queensnorthsouthList);
			checkOpponentRemoved(opponentRemoved,from, tempList,availablePositions);
			int pcol = from.getIntColumn();
			int prow = from.getIntRow();
		} // End instance of queen
		
		if (pieceType instanceof AKnight) {
			kn = (AKnight) pieceType;
		}

		for (Position temp:tempList) {
			String posName = temp.getPositionName();
//			logText.append(posName+"\n");
			Position posinTable =  (Position) removedPositions.stream().filter(c -> c.getPositionName().contains(posName)).findAny().orElse(null); // Do not put position in removed table if it is there already
			if (posinTable == null && !pawnType) {
				writer.println("Added removed position "+temp.toString()+" For "+name);
				removedPositions.add(temp);
			}

		}		
		p.setRemovedPositions(removedPositions);
		
/*		if (kn != null) {
			
		}*/
		for (Position availablePos:availablePositions) {
			boolean available = true;
			for (Position removedPos:removedPositions) {
				if (removedPos.getPositionName().equals(availablePos.getPositionName())) {
					available = false;
//					writer.println("Removed position "+removedPos.toString());
					break;
				}

			}
			if (available) {
				preferredPositions.add(availablePos);
			}
		}
		if (preferredPositions.isEmpty()) { // The list of preferred positions are all available positions that are not removed
			p.setPreferredPositions(null);
			writer.println("No preferred position\n"+"piece: "+p.toString());
			writer.close();
			return null;
		}
		p.setPreferredPositions(preferredPositions);
		for (Position preferredPos:preferredPositions) {
			if (preferredPos.isInUse() && pn == null) { // The active piece is not a pawn ?!
				preferredPosition = preferredPos;
			}
		}
		if (preferredPosition == null) {
			preferredPosition = preferredPositions.get(0); // For white pawns, this statement causes white pawn's preferred position to be an attack position.
			if (pawnType) {
				preferredPosition = pn.checkAttacks(availablePositions);
			}
		}
		ApieceMove move = new ApieceMove(preferredPosition,p);	
		move.setPreferredPositions(preferredPositions);
		resetDirections(availablePositions);
		resetDirections(removedPositions);
		writer.println("Move: "+move.toString()+"\n"+"piece: "+p.toString());
		writer.close();
		return move;
!!!797698.java!!!	getHeldPosition() : Position
		return heldPosition;
!!!1839106.java!!!	checkBishopnwest(inout availablePositions : List<Position>, inout tempList : List<Position>, inout removedPos : Position, inout piece : AgamePiece) : void
		List<XYLocation> nw = piece.getNorthWest();
		XYLocation loc = removedPos.getXyloc();
		int x = loc.getXCoOrdinate();
		int y = loc.getYCoOrdinate();
		for (XYLocation nwloc:nw) {
			int nwx = nwloc.getXCoOrdinate();
			int nwy = nwloc.getYCoOrdinate();
			if (nwx <= x && nwy >= y && removedPos.isNw()) { // If both x and y are less, then this position must be removed
				for (Position pos:availablePositions) {
					int ax = pos.getXyloc().getXCoOrdinate();
					int ay = pos.getXyloc().getYCoOrdinate();
					if (ax == nwx && ay == nwy && pos.isNw() && !pos.isOpponentRemove()) {
						tempList.add(pos);
					}
				}
			}
		}
!!!1839234.java!!!	checkBishopneast(inout availablePositions : List<Position>, inout tempList : List<Position>, inout removedPos : Position, inout piece : AgamePiece) : void
		List<XYLocation> nw = piece.getNorthEast();
		XYLocation loc = removedPos.getXyloc();
		int x = loc.getXCoOrdinate();
		int y = loc.getYCoOrdinate();
		for (XYLocation nwloc:nw) { // All available xylocations north east
			int nwx = nwloc.getXCoOrdinate();
			int nwy = nwloc.getYCoOrdinate();
			if (nwx >= x && nwy >= y && removedPos.isNe()) { // If both x and y are greater, then this position must be removed
				for (Position pos:availablePositions) { // Search all available positions
					int ax = pos.getXyloc().getXCoOrdinate();
					int ay = pos.getXyloc().getYCoOrdinate();
					if (ax == nwx && ay == nwy && pos.isNe() && !pos.isOpponentRemove()) { // If this position contains the current xylocation then
						tempList.add(pos); // remove it
					}
				}
			}
		}
!!!1839362.java!!!	checkBishopseast(inout availablePositions : List<Position>, inout tempList : List<Position>, inout removedPos : Position, inout piece : AgamePiece) : void
		List<XYLocation> nw = piece.getSouthEast();
		XYLocation loc = removedPos.getXyloc(); // The removed position must belong to the same direction.
		int x = loc.getXCoOrdinate();
		int y = loc.getYCoOrdinate();
		for (XYLocation nwloc:nw) {
			int nwx = nwloc.getXCoOrdinate();
			int nwy = nwloc.getYCoOrdinate();
			if (nwx >= x && nwy <= y && removedPos.isSe()) { // If x is greater and y is less, then this position must be removed
				for (Position pos:availablePositions) {
					int ax = pos.getXyloc().getXCoOrdinate();
					int ay = pos.getXyloc().getYCoOrdinate();
					if (ax == nwx && ay == nwy && pos.isSe() && !pos.isOpponentRemove()) {
						tempList.add(pos);
					}
				}
			}
		}
!!!1839490.java!!!	checkBishopswest(inout availablePositions : List<Position>, inout tempList : List<Position>, inout removedPos : Position, inout piece : AgamePiece) : void
		List<XYLocation> nw = piece.getSouthWest();
		XYLocation loc = removedPos.getXyloc();
		int x = loc.getXCoOrdinate();
		int y = loc.getYCoOrdinate();
		for (XYLocation nwloc:nw) {
			int nwx = nwloc.getXCoOrdinate();
			int nwy = nwloc.getYCoOrdinate();
			if (nwx <= x && nwy <= y && removedPos.isSw()) { // If both x and y are less, then this position must be removed
				for (Position pos:availablePositions) {
					int ax = pos.getXyloc().getXCoOrdinate();
					int ay = pos.getXyloc().getYCoOrdinate();
					if (ax == nwx && ay == nwy && pos.isSw() && !pos.isOpponentRemove()) {
						tempList.add(pos);
					}
				}
			}
		}
!!!1992194.java!!!	checkOpponentRemoved(inout removedPositions : List<Position>, inout heldPosition : Position, inout tempList : List<Position>, inout availablePos : List<Position>) : void
		Position pos = availablePos.get(0);
		// For all such directions:
		List<Position>directionNorthRemoved = removedPositions.stream().filter(p -> pos.getNorthDirection() == p.getMydirection()).collect(Collectors.toList());
		List<Position>directionSouthRemoved = removedPositions.stream().filter(p -> pos.getSouthDirection() == p.getMydirection()).collect(Collectors.toList());
		List<Position>directionEastRemoved = removedPositions.stream().filter(p -> pos.getEastDirection() == p.getMydirection()).collect(Collectors.toList());
		List<Position>directionWestRemoved = removedPositions.stream().filter(p -> pos.getWestDirection() == p.getMydirection()).collect(Collectors.toList());
		List<Position>directionNERemoved = removedPositions.stream().filter(p -> pos.getNeDirection() == p.getMydirection()).collect(Collectors.toList());
		List<Position>directionSERemoved = removedPositions.stream().filter(p -> pos.getSeDirection() == p.getMydirection()).collect(Collectors.toList());
		List<Position>directionNWRemoved = removedPositions.stream().filter(p -> pos.getnWDirection() == p.getMydirection()).collect(Collectors.toList());
		List<Position>directionSWRemoved = removedPositions.stream().filter(p -> pos.getSwDirection() == p.getMydirection()).collect(Collectors.toList());
		List<Position>directionNorthavailable = availablePos.stream().filter(p -> pos.getNorthDirection() == p.getMydirection()).collect(Collectors.toList());
		List<Position>directionSouthavailable = availablePos.stream().filter(p -> pos.getSouthDirection() == p.getMydirection()).collect(Collectors.toList());
		List<Position>directionEastavailable = availablePos.stream().filter(p -> pos.getEastDirection() == p.getMydirection()).collect(Collectors.toList());
		List<Position>directionWestavailable = availablePos.stream().filter(p -> pos.getWestDirection() == p.getMydirection()).collect(Collectors.toList());
		List<Position>directionNEavailable = availablePos.stream().filter(p -> pos.getNeDirection() == p.getMydirection()).collect(Collectors.toList());
		List<Position>directionSEavailable = availablePos.stream().filter(p -> pos.getSeDirection() == p.getMydirection()).collect(Collectors.toList());
		List<Position>directionNWavailable = availablePos.stream().filter(p -> pos.getnWDirection() == p.getMydirection()).collect(Collectors.toList());
		List<Position>directionSWavailable = availablePos.stream().filter(p -> pos.getSwDirection() == p.getMydirection()).collect(Collectors.toList());
		Optional<Position> minpos = calculatePositiondif(directionNorthRemoved);
		calculateRemdif(minpos,directionNorthRemoved, tempList, heldPosition);
		calculateRemdif(minpos,directionNorthavailable, tempList, heldPosition);
		Optional<Position> minpossouth = calculatePositiondif(directionSouthRemoved);
		calculateRemdif(minpossouth,directionSouthRemoved, tempList, heldPosition);
		calculateRemdif(minpossouth,directionSouthavailable, tempList, heldPosition);

		Optional<Position> minposeast = calculatePositiondif(directionEastRemoved);
		calculateRemdif(minposeast,directionEastRemoved, tempList, heldPosition);
		calculateRemdif(minposeast,directionEastavailable, tempList, heldPosition);
		Optional<Position> minposwest = calculatePositiondif(directionWestRemoved);
		calculateRemdif(minposwest,directionWestRemoved, tempList, heldPosition);
		calculateRemdif(minposwest,directionWestavailable, tempList, heldPosition);


		Optional<Position> minposse = calculatePositiondif(directionSERemoved);
		calculateRemdif(minposse,directionSERemoved, tempList, heldPosition);
		calculateRemdif(minposse,directionSEavailable, tempList, heldPosition);
		Optional<Position> minposne = calculatePositiondif(directionNERemoved);
		calculateRemdif(minposne,directionNERemoved, tempList, heldPosition);
		calculateRemdif(minposne,directionNEavailable, tempList, heldPosition);
		Optional<Position> minposnw = calculatePositiondif(directionNWRemoved);
		calculateRemdif(minposnw,directionNWRemoved, tempList, heldPosition);
		calculateRemdif(minposnw,directionNWavailable, tempList, heldPosition);
		Optional<Position> minpossw = calculatePositiondif(directionSWRemoved);
		calculateRemdif(minpossw,directionSWRemoved, tempList, heldPosition);
		calculateRemdif(minpossw,directionSWavailable, tempList, heldPosition);
!!!1992322.java!!!	calculatePositiondif(inout removedPositions : List<Position>) : Position
		int dx = 0;
		int dy = 0;
		XYLocation heldLoc = heldPosition.getXyloc();
		int x = heldLoc.getXCoOrdinate();
		int y = heldLoc.getYCoOrdinate();
		for (Position removed:removedPositions) {
			XYLocation remloc = removed.getXyloc();
			int tx = dx;int ty = dy;
			int rx = remloc.getXCoOrdinate();
			int ry = remloc.getYCoOrdinate();
			int diffx = Math.abs(x-rx);
			int diffy = Math.abs(y-ry);
			Integer sumDif = new Integer(diffx+diffy);
			removed.setSumDif(sumDif);

//			remlocs.add(sumDif);
		}

		Optional<Position> minpos = removedPositions.stream().reduce((p1,p2) -> p1.getSumDif() < p2.getSumDif() ? p1 : p2);
		return minpos;
!!!1992450.java!!!	calculateRemdif(inout minpos : Optional<Position>, inout removedPositions : List<Position>, inout tempList : List<Position>, inout heldPosition : Position) : void

		if (minpos.isPresent()) {
			Position minx = minpos.get();
			writer.println("CheckOpponentremove The min position: "+minx.toString());
			List<Position>finalRemoved = removedPositions.stream().filter(p -> minx.getMydirection() == p.getMydirection()).collect(Collectors.toList());
//			List<Position>finalAvailable = availablePos.stream().filter(p -> minx.getMydirection() == p.getMydirection()).collect(Collectors.toList());
//			finalRemoved.addAll(finalAvailable);
			for (Position rem:finalRemoved) {
				int remdiff = 1;
				if (rem.getSumDif() == null) {
					writer.println("CheckOpponentremove no rem sumdif: "+rem.toString());
				}else{
					remdiff = rem.getSumDif().intValue();
				}
				int mindiff = 0;
				if (minx.getSumDif() == null) {
					writer.println("CheckOpponentremove no minx sumdif: "+minx.toString());
				}else {
					mindiff = minx.getSumDif().intValue(); // OBS nullpointer
				}
				 
				if (rem != minx && remdiff > mindiff) {
					tempList.add(rem);
					writer.println("CheckOpponentremove: "+rem.toString()+" added to remove list");
				}
//				rem.setSumDif(null);
			}
		}
		
//		return null;
!!!1839618.java!!!	setDirection(inout piece : AgamePiece, inout positions : List<Position>) : void
		List<XYLocation> nw = piece.getNorthWest();
//		Position pos =  (Position) removedPositions.stream().filter(c -> c.getPositionName().contains(posName)).findAny().orElse(null);
		calculateDirections(nw,0,positions);
		List<XYLocation> ne = piece.getNorthEast();
		calculateDirections(ne,1,positions);
		List<XYLocation> sw = piece.getSouthWest();
		calculateDirections(sw,2,positions);
		List<XYLocation> se = piece.getSouthEast();
		calculateDirections(se,3,positions);
!!!1992578.java!!!	setNSDirection(inout piece : AgamePiece, inout positions : List<Position>) : void
		List<XYLocation> north = piece.getNorth();
		calculateNorthSouth(north, 0, positions);
		List<XYLocation> south = piece.getSouth();
		calculateNorthSouth(south, 1, positions);	
		List<XYLocation> east = piece.getEast();
		calculateNorthSouth(east, 2, positions);
		List<XYLocation> west = piece.getWest();
		calculateNorthSouth(west, 3, positions);
!!!1992706.java!!!	calculateNorthSouth(inout nw : List<XYLocation>, in dr : int, inout positions : List<Position>) : void
		for (Position pos:positions) {
			XYLocation loc = pos.getXyloc();
			int x = loc.getXCoOrdinate();
			int y = loc.getYCoOrdinate();
			for (XYLocation nwloc:nw) {
				int nwx = nwloc.getXCoOrdinate();
				int nwy = nwloc.getYCoOrdinate();
				switch(dr) {
				case 0: //North
					if (y == nwy) {
						pos.setNorth(true);
					}
					break;
				case 1: //South
					if (y == nwy) {
						pos.setSouth(true);
					}
					break;
				case 2: //East
					if (x == nwx) {
						pos.setEast(true);
					}
					break;
				case 3: //West
					if (x == nwx) {
						pos.setWest(true);
					}
					break;					
				}
			}
		}
!!!1839746.java!!!	calculateDirections(inout nw : List<XYLocation>, in dr : int, inout positions : List<Position>) : void
		for (Position pos:positions) {
			XYLocation loc = pos.getXyloc();
			int x = loc.getXCoOrdinate();
			int y = loc.getYCoOrdinate();
			for (XYLocation nwloc:nw) {
				int nwx = nwloc.getXCoOrdinate();
				int nwy = nwloc.getYCoOrdinate();
				if (x == nwx && y == nwy && dr == 0)
					pos.setNw(true);
				if (x == nwx && y == nwy && dr == 1)
					pos.setNe(true);
				if (x == nwx && y == nwy && dr == 2)
					pos.setSw(true);
				if (x == nwx && y == nwy && dr == 3)
					pos.setSe(true);
			}
		}
!!!1839874.java!!!	resetDirections(inout positions : List<Position>) : void
		for (Position pos:positions) {
			pos.setNe(false);
			pos.setNw(false);
			pos.setSe(false);
			pos.setSw(false);
			pos.setNorth(false);
			pos.setSouth(false);
			pos.setWest(false);
			pos.setEast(false);
			pos.setDefaultdirection();
		}
