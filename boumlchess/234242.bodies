class ChessActionImpl
!!!784386.java!!!	ChessActionImpl(inout positions : HashMap<String, Position>, inout chessPiece : AgamePiece, inout player : APlayer, inout opponent : APlayer)
		super();
		this.positions = positions;
		this.chessPiece = chessPiece;
		this.player = player;
		this.opponent = opponent;
		pieceType = chessPiece.getChessType();
		type = chessPiece.getPieceType();
		this.availablePositions = getActions(); // The positionRemoved are also created and filled. They are positions occupied by other pieces owned by the player
		String name = this.chessPiece.getMyPiece().getPieceName();
		pn = this.chessPiece.getMyPosition().getIntRow()*10;
		pny = this.chessPiece.getMyPosition().getIntColumn();
		Integer prn = new Integer(pn+pny);
		PreferredMoveProcessor pr = new PreferredMoveProcessor(prn,name);
		myProcessor = pr;
		possibleMove = ChessFunctions.processChessgame(this,chessPiece, pr); // The processor can be replaced by a lambda expression?
		if (possibleMove != null)
			preferredPosition = possibleMove.getToPosition();
//		preferredPosition = player.calculatePreferredPosition(chessPiece,this);      
		player.getHeldPositions().add(pr.getHeldPosition()); // This is the position held by the piece under consideration
		actionName = this.chessPiece.getMyPiece().getOntlogyName();
!!!1797250.java!!!	getOpponent() : APlayer
		return opponent;
!!!1797378.java!!!	setOpponent(inout opponent : APlayer) : void
		this.opponent = opponent;
!!!1797506.java!!!	getEvaluationValue() : Double
		return evaluationValue;
!!!1797634.java!!!	setEvaluationValue(inout evaluationValue : Double) : void
		this.evaluationValue = evaluationValue;
!!!1780226.java!!!	getActionName() : String
		return actionName;
!!!1780354.java!!!	setActionName(in actionName : String) : void
		this.actionName = actionName;
!!!1780482.java!!!	getActionValue() : Integer
		return actionValue;
!!!1780610.java!!!	setActionValue(inout actionValue : Integer) : void
		this.actionValue = actionValue;
!!!964994.java!!!	processPositions() : void
		Position movePos = null;
		if (possibleMove != null) {
			movePos = possibleMove.getToPosition();
		}
		ApieceMove newMove = ChessFunctions.processChessgame(this,chessPiece, myProcessor);
		if (possibleMove != null && newMove != null) {
			possibleMove = newMove;
			possibleMove.setToPosition(movePos);
		}
		if (newMove == null) {
			System.out.println("Action.processPosition new move is null "+possibleMove.toString());
		}
			
!!!784514.java!!!	getAttackedPositions() : Position
		return attackedPositions;
!!!784642.java!!!	setAttackedPositions(inout attackedPositions : List<Position>) : void
		this.attackedPositions = attackedPositions;
!!!784770.java!!!	getNotAttackedPos() : Position
		return notAttackedPos;
!!!784898.java!!!	setNotAttackedPos(inout notAttackedPos : List<Position>) : void
		this.notAttackedPos = notAttackedPos;
!!!785026.java!!!	getNotProtected() : Position
		return notProtected;
!!!785154.java!!!	setNotProtected(inout notProtected : List<Position>) : void
		this.notProtected = notProtected;
!!!785282.java!!!	getProtectedPositions() : Position
		return protectedPositions;
!!!785410.java!!!	setProtectedPositions(inout protectedPositions : List<Position>) : void
		this.protectedPositions = protectedPositions;
!!!1797762.java!!!	getBishopRemoved() : Position
		return bishopRemoved;
!!!1797890.java!!!	setBishopRemoved(inout bishopRemoved : List<Position>) : void
		this.bishopRemoved = bishopRemoved;
!!!785538.java!!!	getAttacked() : AgamePiece
		return attacked;
!!!785666.java!!!	setAttacked(inout attacked : List<AgamePiece>) : void
		this.attacked = attacked;
!!!785794.java!!!	getOtherattackedPositions() : Position
		return otherattackedPositions;
!!!785922.java!!!	setOtherattackedPositions(inout otherattackedPositions : List<Position>) : void
		this.otherattackedPositions = otherattackedPositions;
!!!786050.java!!!	getOtherprotectedPositions() : Position
		return otherprotectedPositions;
!!!786178.java!!!	setOtherprotectedPositions(inout otherprotectedPositions : List<Position>) : void
		this.otherprotectedPositions = otherprotectedPositions;
!!!786562.java!!!	isBlocked() : boolean
		return blocked;
!!!786690.java!!!	setBlocked(inout blocked : boolean) : void
		this.blocked = blocked;
!!!786818.java!!!	getStrikePosition() : Position
		return strikePosition;
!!!786946.java!!!	setStrikePosition(inout strikePosition : Position) : void
		this.strikePosition = strikePosition;
!!!787074.java!!!	isStrike() : boolean
		return strike;
!!!787202.java!!!	setStrike(inout strike : boolean) : void
		this.strike = strike;
!!!787330.java!!!	getPossibleMove() : ApieceMove
		return possibleMove;
!!!787458.java!!!	setPossibleMove(inout possibleMove : ApieceMove) : void
		this.possibleMove = possibleMove;
!!!787586.java!!!	getPositionRemoved() : Position
		return positionRemoved;
!!!1835138.java!!!	getOpponentRemoved() : Position
		return opponentRemoved;
!!!1835266.java!!!	setOpponentRemoved(inout opponentRemoved : List<Position>) : void
		this.opponentRemoved = opponentRemoved;
!!!787714.java!!!	setPositionRemoved(inout positionRemoved : List<Position>) : void
		this.positionRemoved = positionRemoved;
!!!787842.java!!!	getPlayer() : APlayer
		return player;
!!!787970.java!!!	setPlayer(inout player : APlayer) : void
		this.player = player;
!!!788098.java!!!	getChessPiece() : AgamePiece
		return chessPiece;
!!!788226.java!!!	setChessPiece(inout chessPiece : AgamePiece) : void
		this.chessPiece = chessPiece;
!!!788354.java!!!	setPositions(inout positions : HashMap<String, Position>) : void
		this.positions = positions;
!!!788482.java!!!	getPositions() : Position
		return positions;
!!!788610.java!!!	getAvailablePositions() : Position
		return availablePositions;
!!!788738.java!!!	setAvailablePositions(inout availablePositions : List<Position>) : void
		this.availablePositions = availablePositions;
!!!788866.java!!!	getPreferredPosition() : Position
		if (preferredPosition == null) {
			preferredPosition = player.calculatePreferredPosition(chessPiece,this);
		}
		return preferredPosition;
!!!788994.java!!!	setPreferredPosition(inout preferredPosition : Position) : void
		this.preferredPosition = preferredPosition;
!!!789122.java!!!	getActions() : Position
		if (availablePositions != null) {
			availablePositions.clear();
			availablePositions = null;
		}
		if (positionRemoved != null) {
			positionRemoved.clear();
			positionRemoved = null;
		}
		if (bishopRemoved != null) {
			bishopRemoved.clear();
			bishopRemoved = null;
		}
		if (opponentRemoved != null) {
			opponentRemoved.clear();
			opponentRemoved = null;
		}
		ChessPieceType pieceType = chessPiece.getChessType();
		availablePositions = new ArrayList(positions.values());
		if (pieceType instanceof AQueen) {
			List<Position> bishopPositions = new ArrayList(chessPiece.getBishopPositions().values());
			availablePositions.addAll(bishopPositions);
		}
		
		positionRemoved = new ArrayList();
		opponentRemoved = new ArrayList();
		bishopRemoved = new ArrayList();
		List<Position> castlePositions = null;
		Position castlePosition = null;
		
		if (pieceType instanceof Aking) {
			castlePositions = new ArrayList(chessPiece.getCastlePositions().values());
			castlePosition = castlePositions.get(0);
		}
		if (pieceType instanceof ARook) {
			castlePositions = new ArrayList(chessPiece.getCastlePositions().values());
			castlePosition = castlePositions.get(0);
		}
		boolean bKnight = false;
		if (pieceType instanceof AKnight) {
			bKnight = true;
		}
		List<AgamePiece> pieces = player.getMygamePieces(); 
		for (Position position:availablePositions) {
			for (AgamePiece otherPiece:pieces) {
				boolean inuse = otherPiece.getMyPiece().isUse();// inuse is false if a piece is removed permanently olj 1.08.20
				if (inuse && otherPiece.isActive() && otherPiece != chessPiece) { // Added 31.07.20 Check if piece is active
					Position pos = otherPiece.getMyPosition();
//					pos.setFriendlyPosition(false);
					if (pos != null) {
						if (pos.isInUse()) { // OBS: Added 14.05.20 Are never active !! ??
							if (otherPiece.getMyPosition().getPositionName().equals(position.getPositionName())) {
								String name = otherPiece.getMyPosition().getPositionName();
								String pName = otherPiece.getMyPiece().getOntlogyName();
/*								if (pieceType instanceof AQueen)
									System.out.println("!!!!!! piece and position "+pName+" "+name);*/
								Position posinTable =  (Position) positionRemoved.stream().filter(c -> c.getPositionName().contains(name)).findAny().orElse(null); // Do not put position in removed table if it is there already
								if (posinTable == null && !checkQueen(pos) && ! bKnight) { //The bKnight added nov. 21. All positions are available to the knight
									positionRemoved.add(position);
									chessPiece.determinFriendPosition(pos);
									//position.setFriendlyPosition(true);
								}
								if (posinTable == null && bKnight) { // If piece is a Knight
//									positionRemoved.add(position);
//									String posName = position.getPositionName();
									chessPiece.determinFriendPosition(pos);
								}
							}
							if (castlePosition != null) 
								checkCastling(pos, castlePositions);
						}else {
							 System.out.println("??????? piece has position that is not in use ?????????????? "+otherPiece.toString()+"\n Posisjon: "+pos.toString()+"\n"+this.toString());
						}

					}
				}
			}

		
		}

		checkOpponent();
		return availablePositions;
		
!!!1798018.java!!!	checkOpponent() : void
		List<AgamePiece> pieces = opponent.getMygamePieces(); 
		for (Position position:availablePositions) {
			position.setOpponentRemove(false);
			for (AgamePiece otherPiece:pieces) {
				boolean inuse = otherPiece.getMyPiece().isUse();// inuse is false if a piece is removed permanently olj 1.08.20
				if (inuse) {
					Position pos = otherPiece.getMyPosition();
					if (otherPiece.getMyPosition().getPositionName().equals(position.getPositionName())) {
						if (type != type.KNIGHT) { // !checkQueen(pos) &&  the check for queen is removed !!! olj 06.10.21
							opponentRemoved.add(position);
							position.setOpponentRemove(true);
							String playerId = opponent.getPlayerId();
							if (type == type.BISHOP && playerId.equals("WHITE")) {
								System.out.println("=== Opponent removed === "+position.toString());
							}
						}
						if (type == type.PAWN)
							positionRemoved.add(position);
					}
				}
			}
		}
!!!1798146.java!!!	checkQueen(inout pos : Position) : boolean
		boolean queen = false;
		if (pieceType instanceof AQueen) {
			List<Position>bishopPositions = new ArrayList(chessPiece.getBishopPositions().values());
			String name = pos.getPositionName();
/*			if (name.equals("c2") || name.equals("e2")) {
				System.out.println("Pos !!! "+name);
			}*/
			Position posinTable =  (Position)bishopPositions.stream().filter(c -> c.getPositionName().contains(name)).findAny().orElse(null);
			if (posinTable != null) { // If position is a bishopPosition remove it
				bishopRemoved.add(pos);
				chessPiece.determinFriendPosition(pos); // Only friendly positions
				queen = true;
			}
	
		}
		chessPiece.setBishopRemoved(bishopRemoved);
		return queen;
!!!1780738.java!!!	checkCastling(inout otherPos : Position, inout castlePositions : List<Position>) : void
	
		for (Position castlePos:castlePositions) {
			if (otherPos.getPositionName().equals(castlePos.getPositionName())) {
				String name = otherPos.getPositionName();
				Position posinTable =  (Position) positionRemoved.stream().filter(c -> c.getPositionName().contains(name)).findAny().orElse(null); // Do not put position in removed table if it is there already
				if (posinTable == null) {
					positionRemoved.add(castlePos);
					chessPiece.determinFriendPosition(castlePos);
	//				System.out.println("Castle position: "+castlePos.toString());
				}
			}
		}
/*	
		for (Position removed:positionRemoved) {
			System.out.println(removed.toString());
		}*/

!!!789250.java!!!	getActions(inout theplayer : APlayer) : Position

		List<AgamePiece> pieces = theplayer.getMygamePieces(); 
		if (theplayer == player) {
			if (availablePositions != null) {
				availablePositions.clear();
				availablePositions = null;
			}
			if (positionRemoved != null) {
				positionRemoved.clear();
				positionRemoved = null;
			}
			availablePositions = new ArrayList(positions.values());
			positionRemoved = new ArrayList();
			
			List<Position> castlePositions = null;
			Position castlePosition = null;
			ChessPieceType pieceType = chessPiece.getChessType();
			if (pieceType instanceof Aking) {
				castlePositions = new ArrayList(chessPiece.getCastlePositions().values());
				castlePosition = castlePositions.get(0);
			}
			if (pieceType instanceof ARook) {
				castlePositions = new ArrayList(chessPiece.getCastlePositions().values());
				castlePosition = castlePositions.get(0);
			}
			
			for (Position position:availablePositions) {
				for (AgamePiece otherPiece:pieces) {
					if (otherPiece != chessPiece && otherPiece.isActive()) {
						Position pos = otherPiece.getMyPosition();
						if (pos != null) {
							if (otherPiece.getMyPosition().getPositionName().equals(position.getPositionName())) {
								positionRemoved.add(position);
							}
							if (castlePosition != null)
								checkCastling(pos, castlePositions);
						}
					}
				}

			
			}
		}

		return availablePositions;
		
!!!789378.java!!!	toString() : String
		String posName = "Unknown";
		String pMove = " === No move ===";
		if (possibleMove != null)
			pMove = possibleMove.toString();
		if (preferredPosition != null)
			posName = preferredPosition.getPositionName();
		StringBuffer logText = new StringBuffer(actionName + " Preferred Position " + posName+ " Piece " + chessPiece.toString()+" Possible move "+pMove);
		return logText.toString();
!!!789506.java!!!	isNoOp() : boolean
		// TODO Auto-generated method stub
		return false;
