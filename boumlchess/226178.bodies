class ChessSearchImpl
!!!667778.java!!!	ChessSearchImpl(inout game : ChessGame, in utilMax : double, in utilMin : double, in time : int)
			super();
			this.game = game;
			this.utilMax = utilMax;
			this.utilMin = utilMin;
	      this.timer = new Timer(time);
!!!667906.java!!!	createFor(inout game : ChessGame, in utilMin : double, in utilMax : double, in time : int) : ChessSearchImpl
	    	
	        return new ChessSearchImpl(game, utilMin, utilMax, time);
!!!668034.java!!!	makeDecision(inout state : ChessState) : ChessAction
	      metrics = new Metrics();
	        StringBuffer logText = null;
	        ChessPlayer player =  (ChessPlayer) game.getPlayer(state);
	        List<ChessAction> results =  orderActions(state, game.getActions(state), player, 0);
	        timer.start();
	        currDepthLimit = 1;
	        do {
	            incrementDepthLimit();
	            if (logEnabled)
	                logText = new StringBuffer("depth " + currDepthLimit + ": \n");
	            heuristicEvaluationUsed = false;
	            ActionStore<ChessAction> newResults = new ActionStore<>();
	            for (ChessAction action : results) {
	                double value = minValue((ChessState) game.getResult(state, action), player, Double.NEGATIVE_INFINITY,
	                        Double.POSITIVE_INFINITY, 1);
	/*                if (timer.timeOutOccurred())
	                    break; // exit from action loop
	*/                newResults.add(action, value);
	                if (logEnabled)
	                    logText.append(action).append("-> ").append(value).append(" Metrics ").append(metrics).append("\n").append("From action store:\n");
	            }
	            if (logEnabled) {
	            	 if (newResults.size() > 0) {
	            		 logText.append(newResults.actions.get(0)).append(" Utilvalue ").append(newResults.utilValues.get(0)).append("\n");
	            	 }
	            }
	            System.out.println(logText);
	            if (newResults.size() > 0) {
	                results = newResults.actions;
//	                if (!timer.timeOutOccurred()) {
	                   if (hasSafeWinner(newResults.utilValues.get(0)))
	                       break; // exit from iterative deepening loop
	                   else if (newResults.size() > 1
	                           && isSignificantlyBetter(newResults.utilValues.get(0), newResults.utilValues.get(1)))
	                       break; // exit from iterative deepening loop
//	                }
	            }
	        } while (!timer.timeOutOccurred() && heuristicEvaluationUsed);
	        return results.get(0);

!!!668162.java!!!	incrementDepthLimit() : void
        currDepthLimit++;
!!!668290.java!!!	isSignificantlyBetter(in newUtility : double, in utility : double) : boolean
        return false;
!!!668418.java!!!	hasSafeWinner(in resultUtility : double) : boolean
        return resultUtility <= utilMin || resultUtility >= utilMax;
!!!668546.java!!!	getMetrics() : Metrics
		
		return metrics;
!!!668674.java!!!	setLogEnabled(inout b : boolean) : void
		logEnabled = b;

!!!668802.java!!!	orderActions(inout state : ChessState, inout actions : List<ChessAction<?, ?, ?, ?, ?>>, inout player : ChessPlayer, in depth : int) : ChessAction
    	ActionStore<ChessAction> newResults = new ActionStore<>();
        
    	for (ChessAction action:actions) {
  
    		double rank = game.analyzePieceandPosition(action);
    		newResults.add(action, rank);
    	}
  
        return  newResults.actions;
!!!668930.java!!!	updateMetrics(in depth : int) : void
        metrics.incrementInt(METRICS_NODES_EXPANDED);
        metrics.set(METRICS_MAX_DEPTH, Math.max(metrics.getInt(METRICS_MAX_DEPTH), depth));
!!!669058.java!!!	maxValue(inout state : ChessState, inout player : ChessPlayer, in alpha : double, in beta : double, in depth : int) : double
        updateMetrics(depth);
        if (game.isTerminal(state) || depth >= currDepthLimit || timer.timeOutOccurred()) {
            return eval(state, player);
        } else {
            double value = Double.NEGATIVE_INFINITY;
            List<ChessAction> actions = orderActions(state, (List<ChessAction<?, ?, ?, ?, ?>>) game.getActions(state), player, depth);
            for (ChessAction action :actions) {
                value = Math.max(value, minValue((ChessState) game.getResult(state, action), //
                        player, alpha, beta, depth + 1));
                if (value >= beta)
                    return value;
                alpha = Math.max(alpha, value);
            }
            return value;
        }

!!!669186.java!!!	minValue(inout state : ChessState, inout player : ChessPlayer, in alpha : double, in beta : double, in depth : int) : double
        updateMetrics(depth);
        if (game.isTerminal(state) || depth >= currDepthLimit || timer.timeOutOccurred()) {
            return eval(state, player);
        } else {
            double value = Double.POSITIVE_INFINITY;
            for (ChessAction action : orderActions(state,(List<ChessAction<?, ?, ?, ?, ?>>)  game.getActions(state), player, depth)) {
                value = Math.min(value, maxValue((ChessState) game.getResult(state, action), //
                        player, alpha, beta, depth + 1));
                if (value <= alpha)
                    return value;
                beta = Math.min(beta, value);
            }
            return value;
        }

!!!669314.java!!!	eval(inout state : ChessState, inout player : ChessPlayer) : double
	       if (game.isTerminal(state)) {
	            return game.getUtility(state, player);
	        } else {
	          heuristicEvaluationUsed = true;
	      
	          List<ChessAction> chessActions = state.getActions();
	          ChessAction action = state.getAction();
	        
	          if (action != null)
	        	  return game.analyzePieceandPosition(action);
	          else
	        	  return 0;

	        }

