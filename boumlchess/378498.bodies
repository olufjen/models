class CYK
!!!1820418.java!!!	parse(inout words : List<String>, inout grammar : ProbCNFGrammar) : float
		final int N = length(words);
		final int M = grammar.vars.size(); 
		float[][][] P = new float[M][N][N]; // initialised to 0.0
		for (int i=0; i < N; i++) {
		   //for each rule of form( X -> words<sub>i</sub>[p]) do
			//   P[X,i,1] <- p
			for (int j=0; j < grammar.rules.size(); j++) {
				Rule r = (Rule) grammar.rules.get(j);
				if( r.derives(words.get(i))) { 				 	// rule is of form X -> w, where w = words[i]
					int x = grammar.vars.indexOf(r.lhs.get(0)); // get the index of rule's LHS variable
					P[x][i][0] = r.PROB; 						// not P[X][i][1] because we use 0-based indexing
				}
			}
		}
		for (int length=2; length <= N; length++) {
			for (int start=1; start <= N - length + 1; start++) {
				for (int len1=1; len1 <= length -1; len1++) { // N.B. the book incorrectly has N-1 instead of length-1
					int len2 = length - len1;
					// for each rule of the form X -> Y Z, where Y,Z are variables of the grammar
					for (Rule r : grammar.rules) {
						if(r.rhs.size() == 2) {
							// get index of rule's variables X, Y, and Z
							int x = grammar.vars.indexOf(r.lhs.get(0));
							int y = grammar.vars.indexOf(r.rhs.get(0));
							int z = grammar.vars.indexOf(r.rhs.get(1));
							P[x][start-1][length-1] = Math.max( P[x][start-1][length-1],
												  			P[y][start-1][len1-1] * 
												  			P[z][start+len1-1][len2-1] * r.PROB);
						}
					}
				}
			}
		}
		return P;
!!!1820546.java!!!	length(inout ls : List<String>) : int
		return ls.size();
!!!1820674.java!!!	printProbTable(inout probTable : float [[][][]], inout words : List<String>, inout g : ProbUnrestrictedGrammar) : void
		final int N = words.size();
		final int M = g.vars.size(); // num non-terminals in grammar
		
		for (int i=0; i < M; i++) {
			System.out.println("Table For : " + g.vars.get(i) + "(" + i + ")");
			for (int j=0; j < N; j++) {
				System.out.print(j + "| ");
				for (int k=0; k < N; k++)
					System.out.print(probTable[i][j][k] + " | ");
				System.out.println();
			}
			System.out.println();
		}
!!!1820802.java!!!	getMostProbableDerivation(inout probTable : float [[][][]], inout g : ProbUnrestrictedGrammar) : ArrayList<String>
		// TODO
		return null;
