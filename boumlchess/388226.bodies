class AgamePiece
!!!1869826.java!!!	AgamePiece(inout myPosition : Position)
		super();
		this.myPosition = myPosition;
		
!!!1869954.java!!!	AgamePiece(inout myPosition : Position, inout myPiece : ChessPiece)
		super();
		this.myPosition = myPosition;
		this.myPiece = myPiece;
		heldPositions = new Stack();
		moveNumbers = new ArrayList<Integer>();
		predicates = new ArrayList<String>();
		northEast = new ArrayList<XYLocation>();
		northWest = new ArrayList<XYLocation>();
		southEast = new ArrayList<XYLocation>();
		southWest = new ArrayList<XYLocation>();
//		determinePieceType(); Moved to setOntologyPositions: Then new available positions are replaced by ontology positions
!!!1870082.java!!!	AgamePiece()
		super();
		
!!!1870210.java!!!	getNorthWest() : XYLocation
		return northWest;
!!!1870338.java!!!	setNorthWest(inout northWest : List<XYLocation>) : void
		this.northWest = northWest;
!!!1870466.java!!!	getNorthEast() : XYLocation
		return northEast;
!!!1870594.java!!!	setNorthEast(inout northEast : List<XYLocation>) : void
		this.northEast = northEast;
!!!1870722.java!!!	getSouthWest() : XYLocation
		return southWest;
!!!1870850.java!!!	setSouthWest(inout southWest : List<XYLocation>) : void
		this.southWest = southWest;
!!!1870978.java!!!	getSouthEast() : XYLocation
		return southEast;
!!!1871106.java!!!	setSouthEast(inout southEast : List<XYLocation>) : void
		this.southEast = southEast;
!!!1871234.java!!!	getBishopRemoved() : List<Position>
		return bishopRemoved;
!!!1871362.java!!!	setBishopRemoved(inout bishopRemoved : List<Position>) : void
		this.bishopRemoved = bishopRemoved;
!!!1871490.java!!!	isCastlingMove() : boolean
		return castlingMove;
!!!1871618.java!!!	setCastlingMove(inout castlingMove : boolean) : void
		this.castlingMove = castlingMove;
!!!1871746.java!!!	getPredicate() : String
		return predicate;
!!!1871874.java!!!	setPredicate(in predicate : String) : void
		this.predicate = predicate;
		String str[] = this.predicate.split(";");
		predicates = Arrays.asList(str);
!!!1872002.java!!!	returnPredicate() : String
		String pred = predicates.get(0);
		String endPredicate[] = pred.split(":");
		return endPredicate[0];
!!!1872130.java!!!	getPredicates() : List<String>
		return predicates;
!!!1872258.java!!!	setPredicates(inout predicates : List<String>) : void
		this.predicates = predicates;
!!!1872386.java!!!	getOntologyPositions() : HashMap<String, Position>
		return ontologyPositions;
!!!1872514.java!!!	getCastlePositions() : HashMap<String, Position>
		return castlePositions;
!!!1872642.java!!!	setCastlePositions(inout castlePositions : HashMap<String, Position>) : void
		this.castlePositions = castlePositions;
!!!1872770.java!!!	getBishopPositions() : HashMap<String, Position>
		return bishopPositions;
!!!1872898.java!!!	setBishopPositions(inout bishopPositions : HashMap<String, Position>) : void
		this.bishopPositions = bishopPositions;
!!!1873026.java!!!	setOntologyPositions(inout ontologyPositions : HashMap<String, Position>) : void
		this.ontologyPositions = ontologyPositions;
		determinePieceType();
!!!1873154.java!!!	getNofMoves() : int
		return nofMoves;
!!!1873282.java!!!	setNofMoves(in nofMoves : int) : void
		this.nofMoves = this.nofMoves + 1;
!!!1873410.java!!!	getMoveNumbers() : List<Integer>
		return moveNumbers;
!!!1873538.java!!!	setMoveNumbers(inout moveNumbers : List<Integer>) : void
		this.moveNumbers = moveNumbers;
!!!1873666.java!!!	isActive() : boolean
		return active;
!!!1873794.java!!!	getRemovedPositions() : List<Position>
		return removedPositions;
!!!1873922.java!!!	setRemovedPositions(inout removedPositions : List<Position>) : void
		this.removedPositions = removedPositions;
!!!1874050.java!!!	checkRemoved(inout pos : Position) : boolean
		boolean removed = false;
		String posName = pos.getPositionName();
		if (removedPositions != null) {
			for (Position position:removedPositions) {
				String pName = position.getPositionName();
				if (pos == position) {
					removed = true;
					break;
				}
				if (posName.equals(pName)) {
					removed = true;
					break;
				}
			}
		}

		return removed;
!!!1874178.java!!!	setActive(inout active : boolean) : void
		this.active = active;
!!!1874306.java!!!	restoreValue() : void
		value = orgValue;
!!!1874434.java!!!	getLocalColor() : AbstractGamePiece::pieceColor
		return localColor;
!!!1874562.java!!!	setLocalColor(inout localColor : AbstractGamePiece::pieceColor) : void
		this.localColor = localColor;
!!!1874690.java!!!	getChessType() : ChessPieceType
		return chessType;
!!!1874818.java!!!	setChessType(inout chessType : ChessPieceType) : void
		this.chessType = chessType;
!!!1874946.java!!!	checkBlack() : boolean
		return localColor == pieceColor.BLACK;
!!!1875074.java!!!	checkWhite() : boolean
		return localColor == pieceColor.WHITE;
!!!1875202.java!!!	getAttackPositions() : HashMap<String, Position>
		return attackPositions;
!!!1875330.java!!!	setAttackPositions(inout attackPositions : HashMap<String, Position>) : void
		this.attackPositions = attackPositions;
!!!1875458.java!!!	createPosition(inout newPositions : HashMap<String,Position>) : void
//		XYLocation newloc = new XYLocation(x,y);
		List<Position> tempPositions = new ArrayList(newPositions.values());
		for (Position pos : tempPositions) {
			String name = pos.getPositionName();
			Position ontPosition = ontologyPositions.get(name);
			if (ontPosition != null) {
				newPositions.put(name, ontPosition);
			}
		}

!!!1875586.java!!!	determinMytype() : void
		ChessPieceType king = new Aking();
		king.test(this);
		
		
!!!1875714.java!!!	giveNewdirections() : void
		if (myType == myType.BISHOP || myType == myType.QUEEN) {
			calculateDirections();
		}
!!!1875842.java!!!	calculateDirections() : void
		XYLocation myLocation = myPosition.getXyloc();
		northWest.clear();
		northEast.clear();
		southWest.clear();
		southEast.clear();
		int ocol = myLocation.getXCoOrdinate();
		int orow = myLocation.getYCoOrdinate();
		int col = ocol; int row = orow;
		boolean nWest = col > 0 && row < 7;
		while (nWest) {
			col--;row++;
			XYLocation nwest = new XYLocation(col,row);
			northWest.add(nwest);
			nWest = col > 0 && row < 7;
		}
		col = ocol;row = orow;
		boolean nEast = col < 7 && row < 7;
		while (nEast) {
			col++;row++;
			XYLocation neast = new XYLocation(col,row);
			northEast.add(neast);
			nEast = col < 7 && row < 7;
		}
		col = ocol;row = orow;
		boolean sw = col > 0 && row > 0;
		while(sw) {
			col--;row--;
			XYLocation swest = new XYLocation(col,row);
			southWest.add(swest);
			sw = col > 0 && row > 0;
		}
		col = ocol;row = orow;
		boolean se = col < 7 && row > 0;
		while(se) {
			col++;row--;
			XYLocation seast = new XYLocation(col,row);
			southEast.add(seast);
			se = col < 7 && row > 0;
		}
		
!!!1875970.java!!!	determinePieceType() : void
		String name = myPiece.getPieceName();
		color = myPiece.getColor();
		if (color.equals("w"))
			localColor = pieceColor.WHITE;
		else
			localColor = pieceColor.BLACK;
		GamePiece gamePiece = null;
		switch(name) {
		
			case "P":
				myType = pieceType.PAWN;
				chessType = new APawn(myPosition,myPiece);
				APawn pawn = (APawn) chessType;
//				pawn.setMother(this);
				attackPositions = pawn.getAttackPositions();
				gamePiece = (GamePiece) chessType;
//				gamePiece.g
				reacablePositions = gamePiece.getNewPositions();
				createPosition(reacablePositions); // To replace created positions with ontology positions
				gamePiece.setOntologyPositions(ontologyPositions);
				newlistPositions = new ArrayList(reacablePositions.values());
/*				for (Position pos:newlistPositions) {
					System.out.println("Pawn positions: "+pos.getPositionName() + " " + pos.getPositionColor());
				}*/
				break;
			case"B":	
				myType = pieceType.BISHOP;
				chessType = new ABishop(myPosition,myPiece);
				String pieceColorB = myPiece.getColor();
				gamePiece = (GamePiece) chessType;
				reacablePositions = gamePiece.getNewPositions();
				createPosition(reacablePositions); // To replace created positions with ontology positions
				gamePiece.setOntologyPositions(ontologyPositions);
//				reacablePositions = chessType.getNewPositions();
				newlistPositions = new ArrayList(reacablePositions.values());
				calculateDirections();
/*				for (Position pos:newlistPositions) {
					System.out.println(pieceColorB+" Bishop positions: "+pos.getPositionName() + " " + pos.getPositionColor());
				}*/
				break;	
			case "N":
				myType = pieceType.KNIGHT;
				chessType = new AKnight(myPosition,myPiece);
				String pieceColorK = myPiece.getColor();
				gamePiece = (GamePiece) chessType;
				reacablePositions = gamePiece.getNewPositions();
				createPosition(reacablePositions); // To replace created positions with ontology positions
				gamePiece.setOntologyPositions(ontologyPositions);
//				reacablePositions = chessType.getNewPositions();
				newlistPositions = new ArrayList(reacablePositions.values());
/*				for (Position pos:newlistPositions) {
					System.out.println("Knight positions: "+pos.getPositionName() + " " + pos.getPositionColor());
				}	*/
				break;
			case "K":
				myType = pieceType.KING;
				chessType = new Aking(myPosition,myPiece);
				gamePiece = (GamePiece) chessType;
				Aking king = (Aking) chessType;
				reacablePositions = gamePiece.getNewPositions();
				createPosition(reacablePositions); // To replace created positions with ontology positions
				gamePiece.setOntologyPositions(ontologyPositions);
//				reacablePositions = chessType.getNewPositions();
				newlistPositions = new ArrayList(reacablePositions.values());
				if (nofMoves == 0) {
					king.makeCastlemove();
					castlePositions = king.getCastlePositions();
				}
/*				for (Position pos:newlistPositions) {
					System.out.println("King positions: "+pos.getPositionName() + " " + pos.getPositionColor());
				}*/
				break;
			case "R":
				myType = pieceType.ROOK;
				chessType = new ARook(myPosition,myPiece);
				String pieceColorR = myPiece.getColor();
				gamePiece = (GamePiece) chessType;
				ARook rook = (ARook) chessType;
				reacablePositions = gamePiece.getNewPositions();
				createPosition(reacablePositions); // To replace created positions with ontology positions
				gamePiece.setOntologyPositions(ontologyPositions);
				if (nofMoves == 0) {
					rook.makeCastlemove();
					castlePositions = rook.getCastlePositions();
				}				
//				reacablePositions = chessType.getNewPositions();
				newlistPositions = new ArrayList(reacablePositions.values());
/*				for (Position pos:newlistPositions) {
					System.out.println(pieceColorR+" Rook positions: "+pos.getPositionName() + " " + pos.getPositionColor());
				}*/
				break;
			case "Q":
				myType = pieceType.QUEEN;
				chessType = new AQueen(myPosition,myPiece);
				String pieceColorQ = myPiece.getColor();
				gamePiece = (GamePiece) chessType;
				AQueen queen = (AQueen) chessType;
				reacablePositions = gamePiece.getNewPositions();
				bishopPositions = queen.getBishopPositions();
				createPosition(reacablePositions); // To replace created positions with ontology positions
				createPosition(bishopPositions);
				gamePiece.setOntologyPositions(ontologyPositions);
//				reacablePositions = chessType.getNewPositions();
				newlistPositions = new ArrayList(reacablePositions.values());
				newlistPositions.addAll(bishopPositions.values());
				calculateDirections();
/*				for (Position pos:newlistPositions) {
					System.out.println(pieceColorQ+" Queens positions: "+pos.getPositionName() + " " + pos.getPositionColor());
				}*/				
				break;
			default:
				myType = pieceType.PAWN;
				break;
		}
!!!1876098.java!!!	getPreferredPositions() : List<Position>
		return preferredPositions;
!!!1876226.java!!!	setPreferredPositions(inout preferredPositions : List<Position>) : void
		this.preferredPositions = preferredPositions;
!!!1876354.java!!!	getLegalmoves() : HashMap<String,Position>
			return (HashMap<String, Position>) reacablePositions;
!!!1876482.java!!!	getmyPosition() : Position
		return (Position) myPosition;
		
!!!1876610.java!!!	getMyPosition() : Position
		return myPosition;
!!!1876738.java!!!	setMyPosition(inout newPosition : Position) : void
		if (this.myPosition != null) {
			heldPositions.push(this.myPosition);
			this.heldPosition = myPosition;
		}
		this.myPosition = newPosition;
!!!1876866.java!!!	setMypositionEmpty(inout position : Position) : void
		heldPosition = myPosition;
		myPosition = position;
		if (myPosition == null && heldPosition == null) {
			System.out.println("Both positions empty !!--");
		}
!!!1876994.java!!!	restorePosition() : void
/*		if (active && heldPositions != null) {
			heldPositions.clear();
		}*/
		if (heldPositions != null && !heldPositions.isEmpty())
			this.myPosition = heldPositions.pop();
		if (myPosition != null) // Added 1.08.20
			active = true;
		
//		myPosition = heldPosition;
!!!1877122.java!!!	getHeldPosition() : Position
		if (heldPosition == null && heldPositions == null)
			return null;
		if (heldPosition == null && heldPositions.isEmpty())
			return null;
		if (!heldPositions.isEmpty())
			heldPosition = heldPositions.pop();
		return heldPosition;
!!!1877250.java!!!	setHeldPosition(inout heldPosition : Position) : void
		this.heldPosition = heldPosition;
		if (heldPosition == null) {
			heldPositions.clear();
		}
		if (heldPosition != null) {
			heldPositions.push(heldPosition);
		}
!!!1877378.java!!!	getMyPiece() : ChessPiece
		return myPiece;
!!!1877506.java!!!	setMyPiece(inout myPiece : ChessPiece) : void
		this.myPiece = myPiece;
!!!1877634.java!!!	getPieceType() : AbstractGamePiece::pieceType
		
		return myType;
!!!1877762.java!!!	getColor() : String
		return color;
!!!1877890.java!!!	setColor(in color : String) : void
		this.color = color;
!!!1878018.java!!!	getMyType() : AbstractGamePiece::pieceType
		return myType;
!!!1878146.java!!!	setMyType(inout myType : AbstractGamePiece::pieceType) : void
		this.myType = myType;
!!!1878274.java!!!	getReacablePositions() : HashMap<String, Position>
		return reacablePositions;
!!!1878402.java!!!	setReacablePositions(inout reacablePositions : HashMap<String, Position>) : void
		this.reacablePositions = reacablePositions;
!!!1878530.java!!!	setNewlistPositions(inout newPositions : ArrayList<Position>) : void
		this.newlistPositions = newPositions;
!!!1878658.java!!!	getNewlistPositions() : ArrayList<Position>
		return newlistPositions;
!!!1878786.java!!!	toString() : String
		StringBuilder result = new StringBuilder();
		String posName = "Removed!!!";
		XYLocation localXY = new XYLocation(0,0);
		String pActive = " Active";
		if (!active)
			pActive = " Taken!!!";
		if (myPosition != null) {
			posName = myPosition.getPositionName();
			localXY = myPosition.getXyloc();
		}
		
		result.append("Piece position "+posName + " X, Y "+localXY.toString()  + " "+myPiece.getName()+ " "+myPiece.getPosition().toString()+" "+ myType+pActive);
	
		String na = myPiece.getPieceName();
		result.append("Name " + na + "\n" + "Available positions\n");
		for (Position pos:newlistPositions) {
			result.append("Position: "+pos.getPositionName() + " " + pos.getPositionColor() + " X, Y "+pos.getXyloc().toString() );
			if (pos.isInUse()) {
				result.append(" Occupied by: "+pos.getUsedBy().getOntlogyName() + "\n");
			}else {
				result.append("\n");
			}
		}
		result.append("Removed positions\n");
		if (removedPositions != null && !removedPositions.isEmpty()) {
			for (Position pos:removedPositions) {
				result.append("Position: "+pos.getPositionName() + " " + pos.getPositionColor() + " X, Y "+pos.getXyloc().toString());
				if (pos.isInUse()) {
					result.append(" Occupied by: "+pos.getUsedBy().getOntlogyName() + "\n");
				}else {
					result.append("\n");
				}

			}	
		}
		result.append("Northwest positions\n");
		if (northWest != null && !northWest.isEmpty()) {
			for (XYLocation pos:northWest) {
				result.append(" X, Y "+pos.toString());
				}

		}	
		result.append("\nNortheast positions\n");
		if (northEast != null && !northEast.isEmpty()) {
			for (XYLocation pos:northEast) {
				result.append(" X, Y "+pos.toString());
				}

		}
		result.append("\nSoutheast positions\n");
		if (southEast != null && !southEast.isEmpty()) {
			for (XYLocation pos:southEast) {
				result.append(" X, Y "+pos.toString());
				}

		}	
		result.append("\nSouthwest positions\n");
		if (southWest != null && !southWest.isEmpty()) {
			for (XYLocation pos:southWest) {
				result.append(" X, Y "+pos.toString());
				}

		}	
		if(castlePositions != null && !castlePositions.isEmpty() && (myType == myType.KING || myType == myType.ROOK) && nofMoves == 0) {
			List<Position> castle = new ArrayList(castlePositions.values());
			result.append("castle positions\n");
			for (Position pos:castle) {
				result.append("Position: "+pos.getPositionName() + " " + pos.getPositionColor() + " X, Y "+pos.getXyloc().toString());
				if (pos.isInUse()) {
					result.append(" Occupied by: "+pos.getUsedBy().getOntlogyName() + "\n");
				}else {
					result.append("\n");
				}
			}
		}
	
		return result.toString();
!!!1878914.java!!!	test(inout piece : GamePiece) : boolean
		// TODO Auto-generated method stub
		return false;
!!!1879042.java!!!	checkName(in name : String) : boolean
		// TODO Auto-generated method stub
		return false;
!!!1879170.java!!!	getLegalmoves(inout position : Position) : void
		AgamePiece localpiece = (AgamePiece) chessType;
		localpiece.setMyPosition(position);
		localpiece.produceLegalmoves(position);
		reacablePositions = localpiece.getNewPositions();
//		reacablePositions =  chessType.getNewPositions();
		newlistPositions = null;
		newlistPositions = new ArrayList(reacablePositions.values());
//		newlistPositions =  (List<Position>) reacablePositions.values();
!!!1879298.java!!!	produceLegalmoves(inout position : Position) : void

		if (chessType instanceof APawn) {
			APawn p = (APawn) chessType;
			p.produceLegalmoves(position);
			attackPositions = p.getAttackPositions();
		}
		if (chessType instanceof AKnight) {
			AKnight p = (AKnight) chessType;
			p.produceLegalmoves(position);
		}
		if (chessType instanceof ARook) {
			ARook p = (ARook) chessType;
			p.produceLegalmoves(position);
		}	
		if (chessType instanceof ABishop) {
			ABishop p = (ABishop) chessType;
			p.produceLegalmoves(position);
		}
		if (chessType instanceof AQueen) {
			AQueen p = (AQueen) chessType;
			p.produceLegalmoves(position);
		}
		if (chessType instanceof Aking) {
			Aking p = (Aking) chessType;
			p.produceLegalmoves(position);
		}

/*		Optional<ARook> r = Optional.ofNullable((ARook) chessType);
		Optional<AKnight> n = Optional.ofNullable((AKnight) chessType);
		Optional<AQueen> q = Optional.ofNullable((AQueen) chessType);
		Optional<Aking> k = Optional.ofNullable((Aking) chessType);*/
/*		Optional<APawn> p = Optional.ofNullable(ChessFunctions.findpieceType(localpiece,(APawn piece) -> piece.getPieceType() == pieceType.PAWN));
		ABishop b = ChessFunctions.findpieceType(localpiece,(AgamePiece piece) -> piece.getPieceType() == pieceType.BISHOP);
		ARook r = ChessFunctions.findpieceType(localpiece,(AgamePiece piece) -> piece.getPieceType() == pieceType.ROOK);
		AKnight n = ChessFunctions.findpieceType(localpiece,(AgamePiece piece) -> piece.getPieceType() == pieceType.KNIGHT);
		AQueen q = ChessFunctions.findpieceType(localpiece,(AgamePiece piece) -> piece.getPieceType() == pieceType.QUEEN);
		Aking k = ChessFunctions.findpieceType(localpiece,(AgamePiece piece) -> piece.getPieceType() == pieceType.KING);
		if (k != null)
			k.produceLegalmoves(position);*/
		GamePiece gamePiece = (GamePiece) chessType;
		reacablePositions = gamePiece.getNewPositions();	
//		reacablePositions =  chessType.getNewPositions();
		newlistPositions = null;
		newlistPositions = new ArrayList(reacablePositions.values());
		
!!!1879426.java!!!	checkPositions() : boolean
		boolean newPos = false;
		if (newlistPositions == null || newlistPositions.isEmpty()) {
			newlistPositions = null;
			newlistPositions = new ArrayList(reacablePositions.values());
			newPos = true;
		}
		return newPos;
!!!1879554.java!!!	getPieceColor() : AbstractGamePiece::pieceColor
		// TODO Auto-generated method stub
		return null;
!!!1879682.java!!!	getNewPositions() : HashMap<String, Position>
		
		return reacablePositions;
