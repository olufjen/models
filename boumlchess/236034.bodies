class AQueen
!!!776578.java!!!	AQueen()
		super();
		reachablesqueres = new int[size][size];
		reachablepiecePosition = new String[size][size];
		for (int i = 0; i < size; i++) {
			for (int j = 0; j < size; j++) {
				reachablesqueres[i][j] = 0;
			}
		}
		for (int i = 0; i < size; i++) {
			for (int j = 0; j < size; j++) {
				reachablepiecePosition[i][j] = null;
			}
		}
		friendPositions = new HashMap<String,Position>();
!!!776706.java!!!	AQueen(inout myPosition : Position, inout myPiece : ChessPiece)
		super();
		color = myPiece.getColor();
		if (color.equals("w"))
			localColor = pieceColor.WHITE;
		else
			localColor = pieceColor.BLACK;
		this.myPiece = myPiece;
		this.myPosition = myPosition;
		value= 9;
		reachablesqueres = new int[size][size];
		reachablepiecePosition = new String[size][size];
		for (int i = 0; i < size; i++) {
			for (int j = 0; j < size; j++) {
				reachablesqueres[i][j] = 0;
			}
		}
		for (int i = 0; i < size; i++) {
			for (int j = 0; j < size; j++) {
				reachablepiecePosition[i][j] = null;
			}
		}
		friendPositions = new HashMap<String,Position>();
		getLegalmoves(myPosition);
!!!776834.java!!!	AQueen(inout myPosition : Position)
		super();
		reachablesqueres = new int[size][size];
		reachablepiecePosition = new String[size][size];
		for (int i = 0; i < size; i++) {
			for (int j = 0; j < size; j++) {
				reachablesqueres[i][j] = 0;
			}
		}
		for (int i = 0; i < size; i++) {
			for (int j = 0; j < size; j++) {
				reachablepiecePosition[i][j] = null;
			}
		}
		friendPositions = new HashMap<String,Position>();
		getLegalmoves(myPosition);
!!!2046850.java!!!	getChesstype() : String
		return chessType;
!!!776962.java!!!	getColor() : String
		return color;
!!!777090.java!!!	setColor(in color : String) : void
		this.color = color;
!!!777218.java!!!	getMyPiece() : ChessPiece
		return myPiece;
!!!777346.java!!!	setMyPiece(inout myPiece : ChessPiece) : void
		this.myPiece = myPiece;
!!!2000898.java!!!	getFriendPositions() : Position
		return friendPositions;
!!!2001026.java!!!	setFriendPositions(inout friendPositions : HashMap<String, Position>) : void
		this.friendPositions = friendPositions;
!!!777474.java!!!	getMyPosition() : Position
		return myPosition;
!!!777602.java!!!	setMyPosition(inout myPosition : Position) : void
		this.myPosition = myPosition;
!!!777730.java!!!	checkName(in name : String) : boolean
		// TODO Auto-generated method stub
		return false;
!!!777858.java!!!	test(inout piece : GamePiece) : boolean
		return piece.getPieceType() == localType;
!!!777986.java!!!	getSize() : int
		return reachablesqueres.length;
!!!778114.java!!!	clear() : void
		for (int i = 0; i < getSize(); i++) {
			for (int j = 0; j < getSize(); j++) {
				reachablesqueres[i][j] = 0;
			}
		}
		for (int i = 0; i < getSize(); i++) {
			for (int j = 0; j < getSize(); j++) {
				reachablepiecePosition[i][j] = null;
			}
		}
!!!1796866.java!!!	getBishopPositions() : Position
		return bishopPositions;
!!!1796994.java!!!	setBishopPositions(inout bishopPositions : HashMap<String, Position>) : void
		this.bishopPositions = bishopPositions;
!!!1797122.java!!!	setNewPositions(inout newPositions : HashMap<String, Position>) : void
		this.newPositions = newPositions;
!!!778242.java!!!	getLocalType() : AbstractGamePiece::pieceType
		return localType;
!!!778370.java!!!	setLocalType(inout localType : AbstractGamePiece::pieceType) : void
		this.localType = localType;
!!!778498.java!!!	getReachablesqueres() : int
		return reachablesqueres;
!!!778626.java!!!	setReachablesqueres(inout reachablesqueres : int [[][]]) : void
		this.reachablesqueres = reachablesqueres;
!!!778754.java!!!	getReachablepiecePosition() : String
		return reachablepiecePosition;
!!!778882.java!!!	setReachablepiecePosition(inout reachablepiecePosition : String [[][]]) : void
		this.reachablepiecePosition = reachablepiecePosition;
!!!779010.java!!!	getLegalmoves(inout position : Position) : void
		XYLocation loc = position.getXyloc();
		String posName = position.getPositionName();
		ARookMoveRule moveRule = new ARookMoveRule();
		ABishopMoveRule bmoveRule = new ABishopMoveRule();
		List<XYLocation> locations = ChessFunctions.moveRule(this, moveRule);
		List<XYLocation> blocations = ChessFunctions.moveRule(this, bmoveRule);
		
		if (newPositions == null)
			newPositions = new HashMap();
		if (bishopPositions == null)
			bishopPositions = new HashMap();
		for (XYLocation xloc:locations) {
			int x = xloc.getXCoOrdinate();
			int y = xloc.getYCoOrdinate();
			reachablesqueres[x][y] = 1;
			reachablepiecePosition[x][y] = "P";
			createPosition(newPositions, xloc);
		}
		for (XYLocation xloc:blocations) {
			int x = xloc.getXCoOrdinate();
			int y = xloc.getYCoOrdinate();
			reachablesqueres[x][y] = 1;
			reachablepiecePosition[x][y] = "P";
			createPosition(bishopPositions,xloc);
		}		
		
/*		
		int x = loc.getXCoOrdinate();
		int y = loc.getYCoOrdinate();
		int j = x + 1;
		if (j<7) {
			for (int i = y+1;i<7;i++) {
				reachablesqueres[j][i] = 1;
				reachablepiecePosition[j][i] = "Q";
				createPosition(newPositions, j,i);
				if (j<7)
					j++;
				else
					break;
			} 
		}
		j = x -1;
		if (j>0) {
			for (int i = y+1;i<7;i++) {
				reachablesqueres[j][i] = 1;
				reachablepiecePosition[j][i] = "Q";
				createPosition(newPositions, j,i);
				if (j>0)
					j--;
				else
					break;
			} 
		}
		j = x + 1;
		if (j <7 && y>0) {
			for (int i = y-1;i>0;i--) {
				reachablesqueres[j][i] = 1;
				reachablepiecePosition[j][i] = "Q";
				createPosition(newPositions, j,i);
				if (j<7)
					j++;
				else
					break;
			}
		}		
		j = x -1;
		if (j > 0 && y>0) {
			for (int i = y-1;i>0;i--) {
				reachablesqueres[j][i] = 1;
				reachablepiecePosition[j][i] = "Q";
				createPosition(newPositions, j,i);
				if (j>0)
					j--;
				else
					break;
			}
		}
		
		for (int i = y;i<8;i++) {
			reachablesqueres[x][i] = 1;
			reachablepiecePosition[x][i] = "Q";
			createPosition(newPositions, x,i);
		}
		for (int i = x;i<8;i++) {
			reachablesqueres[i][y] = 1;
			reachablepiecePosition[i][y] = "Q";
			createPosition(newPositions,i,y);
		}		
		for (int i = y;i>0;i--) {
			reachablesqueres[x][i] = 1;
			reachablepiecePosition[x][i] = "Q";
			createPosition(newPositions, x,i);
		}
		for (int i = x;i>0;i--) {
			reachablesqueres[i][y] = 1;
			reachablepiecePosition[i][y] = "Q";
			createPosition(newPositions, i,y);
		}
		*/
!!!779138.java!!!	createPosition(inout newPositions : HashMap<String,Position>, inout newloc : XYLocation) : void
//		XYLocation newloc = new XYLocation(x,y);
		Position newPosxyp = new Position(newloc,false,null);
		newPositions.put(newPosxyp.getPositionName(), newPosxyp);
!!!1991042.java!!!	checkRemovals(inout availablePositions : List<Position>, inout removedPositions : List<Position>) : Position
		List<Position>tempList = new ArrayList<Position>();
		List<Position>tempAvail = new ArrayList<Position>();
		List<Integer>remlocs = new ArrayList();
		Map<Enum,List<Position>> remDirections = new HashMap();
		Map<Enum,List<Position>> availDirection = new HashMap();
		Map<Enum,Integer>remlocMaps = new HashMap();
		XYLocation heldLoc = myPosition.getXyloc();
		int x = heldLoc.getXCoOrdinate();
		int y = heldLoc.getYCoOrdinate();
		int dx = 0;
		int dy = 0;
		for (Position removed:removedPositions) {
			XYLocation remloc = removed.getXyloc();
			int tx = dx;int ty = dy;
			int rx = remloc.getXCoOrdinate();
			int ry = remloc.getYCoOrdinate();
			int diffx = Math.abs(x-rx);
			int diffy = Math.abs(y-ry);
			Integer sumDif = new Integer(diffx+diffy);
			removed.setSumDif(sumDif);
			remlocs.add(sumDif);
			remlocMaps.put(removed.getMydirection(), sumDif);
			removed.setLastDirection(removed.getNeDirection());
		}
		for (Position avail:availablePositions) {
			XYLocation remloc = avail.getXyloc();
			int tx = dx;int ty = dy;
			int rx = remloc.getXCoOrdinate();
			int ry = remloc.getYCoOrdinate();
			int diffx = Math.abs(x-rx);
			int diffy = Math.abs(y-ry);
			Integer sumDif = new Integer(diffx+diffy);
			avail.setSumDif(sumDif);
			remlocs.add(sumDif);
			remlocMaps.put(avail.getMydirection(), sumDif);
//			avail.setLastDirection(avail.getNeDirection());
		}		
		List<Position>northesRemoved = removedPositions.stream().filter(p -> p.getMydirection() == p.getLastDirection()).collect(Collectors.toList());
		tempList.addAll(addPositions(availablePositions,northesRemoved));
		for (Position removed:removedPositions) {
			removed.setLastDirection(removed.getnWDirection());
		}
		List<Position>northweRemoved = removedPositions.stream().filter(p -> p.getMydirection() == p.getLastDirection()).collect(Collectors.toList());
		tempList.addAll(addPositions(availablePositions,northweRemoved));
		for (Position removed:removedPositions) {
			removed.setLastDirection(removed.getSeDirection());
		}
		List<Position>southseRemoved = removedPositions.stream().filter(p -> p.getMydirection() == p.getLastDirection()).collect(Collectors.toList());
		tempList.addAll(addPositions(availablePositions,southseRemoved));
		for (Position removed:removedPositions) {
			removed.setLastDirection(removed.getSwDirection());
		}
		List<Position>southswRemoved = removedPositions.stream().filter(p -> p.getMydirection() == p.getLastDirection()).collect(Collectors.toList());
		tempList.addAll(addPositions(availablePositions,southswRemoved));
		return tempList;
!!!1991170.java!!!	addPositions(inout availablePositions : List<Position>, inout removedPositions : List<Position>) : Position
		Optional<Position> minpos = Optional.empty();
		Optional<Position> availmin = Optional.empty();
		List<Position>friendlyList = new ArrayList<Position>();
		List<Position>tempAvail2 = new ArrayList();
		List<Position>tempAvail = new ArrayList<Position>();
		List<Position>tempList = new ArrayList<Position>();
		if (removedPositions != null && !removedPositions.isEmpty()) {
			minpos = removedPositions.stream().reduce((p1,p2) -> p1.getSumDif() < p2.getSumDif() ? p1 : p2);
		}
		if (minpos.isPresent()) {
			Position minx = minpos.get();
			if (localColor == pieceColor.WHITE) {
				System.out.println("CheckRemovals The min position: "+minx.toString());
			}
			tempList = removedPositions.stream().filter(p -> minx.getMydirection() == p.getMydirection()).collect(Collectors.toList());
			// Find all available positions that have the same direction:
			tempAvail = availablePositions.stream().filter(p -> minx.getMydirection() == p.getMydirection()).collect(Collectors.toList());
			if (tempAvail != null && !tempAvail.isEmpty()) {
				tempAvail2 = tempAvail.stream().filter(p -> minx.getSumDif() < p.getSumDif()).collect(Collectors.toList());
			}
			if (tempAvail2 != null && !tempAvail2.isEmpty()) {
				availmin = tempAvail2.stream().reduce((p1,p2) -> p1.getSumDif() < p2.getSumDif() ? p1 : p2);
			}
			if (availmin.isPresent()){
				Position availx = availmin.get();
				int nx = minx.getSumDif().intValue();
				int ny = availx.getSumDif().intValue();
				if (tempAvail != null && !tempAvail.isEmpty()) {
					friendlyList = tempAvail.stream().filter(p -> availx.getSumDif() < p.getSumDif()).collect(Collectors.toList());
				}
				if (nx < ny) {
					friendlyList = null;
					friendlyList = tempAvail.stream().filter(p -> minx.getSumDif() < p.getSumDif()).collect(Collectors.toList());
				}
				if (friendlyList != null && !friendlyList.isEmpty()) {
					for (Position friend:friendlyList) {
						String name = friend.getPositionName();
						friendPositions.remove(name);
					//	friend.setFriendlyPosition(false);
					}
				}
			}
			tempList.addAll(tempAvail2);
			// must do the same with available positions !!!!
		}

	
		return tempList;
!!!1991298.java!!!	checkNorthSouthremovals(inout availablePositions : List<Position>, inout removedPositions : List<Position>) : Position
		List<Position>tempList = new ArrayList<Position>();
//		List<Position>tempAvail = new ArrayList<Position>();
		XYLocation heldLoc = myPosition.getXyloc();
		int x = heldLoc.getXCoOrdinate();
		int y = heldLoc.getYCoOrdinate();
		for (Position removed:removedPositions) {
			XYLocation remloc = removed.getXyloc();
			int ry = remloc.getYCoOrdinate();
			int ydiff = y - ry;//Math.abs(y-ry);
			Integer sumDif = new Integer(Math.abs(ydiff));
			if (ydiff < 0) {
				removed.setSumNorth(ydiff);
				removed.setSumDif(sumDif);
			}
			if (ydiff > 0) {
				removed.setSumSouth(ydiff);
				removed.setSumDif(sumDif);
			}
			int rx = remloc.getXCoOrdinate();
			int xdiff = x - rx;
			Integer sumdifx = new Integer(Math.abs(xdiff));
			if (xdiff < 0) {
				removed.setSumWest(xdiff);
				removed.setSumDif(sumdifx);
			}
			if (xdiff > 0) {
				removed.setSumEast(xdiff);	
				removed.setSumDif(sumdifx);
			}
			removed.setLastDirection(removed.getNorthDirection());
		}
		for (Position avail:availablePositions) {
			XYLocation remloc = avail.getXyloc();
			int rx = remloc.getXCoOrdinate();
			int ry = remloc.getYCoOrdinate();
			int ydiff = y - ry;//Math.abs(y-ry);
			Integer sumDif = new Integer(Math.abs(ydiff));
			if (ydiff < 0) {
				avail.setSumNorth(ydiff);
				avail.setSumDif(sumDif);
			}
			if (ydiff > 0) {
				avail.setSumSouth(ydiff);
				avail.setSumDif(sumDif);
			}
			int xdiff = x - rx;
			Integer sumdifx = new Integer(Math.abs(xdiff));
			if (xdiff < 0) {
				avail.setSumWest(xdiff);
				avail.setSumDif(sumdifx);
			}
			if (xdiff > 0) {
				avail.setSumEast(xdiff);
				avail.setSumDif(sumdifx);
			}
		}
		List<Position>northRemoved = removedPositions.stream().filter(p -> p.getMydirection() == p.getLastDirection()).collect(Collectors.toList());
		tempList.addAll(addPositions(availablePositions,northRemoved));
		for (Position removed:removedPositions) {
			removed.setLastDirection(removed.getWestDirection());
		}
		List<Position>westRemoved = removedPositions.stream().filter(p -> p.getMydirection() == p.getLastDirection()).collect(Collectors.toList());
		tempList.addAll(addPositions(availablePositions,westRemoved));
		for (Position removed:removedPositions) {
			removed.setLastDirection(removed.getEastDirection());
		}
		List<Position>eastRemoved = removedPositions.stream().filter(p -> p.getMydirection() == p.getLastDirection()).collect(Collectors.toList());
		tempList.addAll(addPositions(availablePositions,eastRemoved));
		for (Position removed:removedPositions) {
			removed.setLastDirection(removed.getSouthDirection());
		}
		List<Position>southRemoved = removedPositions.stream().filter(p -> p.getMydirection() == p.getLastDirection()).collect(Collectors.toList());
		tempList.addAll(addPositions(availablePositions,southRemoved));
		return tempList;
!!!779266.java!!!	getNewPositions() : Position
		return newPositions;
!!!779394.java!!!	getLegalmoves() : HashMap
		return newPositions;
		
!!!779522.java!!!	getPieceType() : AbstractGamePiece::pieceType
		// TODO Auto-generated method stub
		return localType;
!!!779650.java!!!	getmyPosition() : Position

		return myPosition;
!!!779778.java!!!	produceLegalmoves(inout position : Position) : void
		newPositions.clear();
		bishopPositions.clear();
		myPosition = position;
		getLegalmoves(position);
		createontPosition(newPositions);
		createontPosition(bishopPositions);
!!!779906.java!!!	createontPosition(inout newPositions : HashMap<String,Position>) : void
//		XYLocation newloc = new XYLocation(x,y);
		List<Position> tempPositions = new ArrayList(newPositions.values());
		for (Position pos : tempPositions) {
			String name = pos.getPositionName();
			Position ontPosition = ontologyPositions.get(name);
			if (ontPosition != null) {
				newPositions.put(name, ontPosition);
			}
		}

!!!780034.java!!!	getPieceColor() : AbstractGamePiece::pieceColor
	
		return localColor;
!!!780162.java!!!	getOntologyPositions() : Position
		
		return this.ontologyPositions;
!!!780290.java!!!	setOntologyPositions(inout ontologyPositions : HashMap<String, Position>) : void
		this.ontologyPositions = ontologyPositions;
		
