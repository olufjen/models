class OnlineDFSAgent
!!!490370.java!!!	OnlineDFSAgent(inout problem : OnlineSearchProblem, inout ptsFn : Function<Percept, S>)
		setProblem(problem);
		setPerceptToStateFunction(ptsFn);
!!!490498.java!!!	getProblem() : OnlineSearchProblem
		return problem;
!!!490626.java!!!	setProblem(inout problem : OnlineSearchProblem) : void
		this.problem = problem;
		init();
!!!490754.java!!!	getPerceptToStateFunction() : Percept
		return ptsFn;
!!!490882.java!!!	setPerceptToStateFunction(inout ptsFn : Function<Percept, S>) : void
		this.ptsFn = ptsFn;
!!!491010.java!!!	execute(inout psPrimed : Percept) : Action
		S sPrimed = ptsFn.apply(psPrimed);
		// if GOAL-TEST(s') then return stop
		if (problem.testGoal(sPrimed)) {
			a = null;
		} else {
			// if s' is a new state (not in untried) then untried[s'] <-
			// ACTIONS(s')
			if (!untried.containsKey(sPrimed)) {
				untried.put(sPrimed, problem.getActions(sPrimed));
			}

			// if s is not null then do
			if (null != s) {
				// Note: If I've already seen the result of this
				// [s, a] then don't put it back on the unbacktracked
				// list otherwise you can keep oscillating
				// between the same states endlessly.
				if (!(sPrimed.equals(result.get(s, a)))) {
					// result[s, a] <- s'
					result.put(s, a, sPrimed);

					// Ensure the unbacktracked always has a list for s'
					if (!unbacktracked.containsKey(sPrimed)) {
						unbacktracked.put(sPrimed, new ArrayList<>());
					}

					// add s to the front of the unbacktracked[s']
					unbacktracked.get(sPrimed).add(0, s);
				}
			}
			// if untried[s'] is empty then
			if (untried.get(sPrimed).isEmpty()) {
				// if unbacktracked[s'] is empty then return stop
				if (unbacktracked.get(sPrimed).isEmpty()) {
					a = null;
				} else {
					// else a <- an action b such that result[s', b] =
					// POP(unbacktracked[s'])
					S popped = unbacktracked.get(sPrimed).remove(0);
					for (Pair<S, A> sa : result.keySet()) {
						if (sa.getFirst().equals(sPrimed) && result.get(sa).equals(popped)) {
							a = sa.getSecond();
							break;
						}
					}
				}
			} else {
				// else a <- POP(untried[s'])
				a = untried.get(sPrimed).remove(0);
			}
		}

		if (a == null) {
			// I'm either at the Goal or can't get to it,
			// which in either case I'm finished so just die.
			setAlive(false);
		}

		// s <- s'
		s = sPrimed;
		// return a
		return a != null ? a : NoOpAction.NO_OP;
!!!491138.java!!!	init() : void
		setAlive(true);
		result.clear();
		untried.clear();
		unbacktracked.clear();
		s = null;
		a = null;
