class AChessAgent
!!!1657858.java!!!	AChessAgent(inout kb : KnowledgeBase)
		super(kb);
		
!!!1657986.java!!!	AChessAgent(inout KB : ChessKnowledgeBase, inout localAction : ChessActionImpl)
		super(KB);
		this.kb = (ChessKnowledgeBase)KB;
		try {
			fw = new FileWriter(outputFileName, true);
		} catch (IOException e1) {

			e1.printStackTrace();
		}
	    writer = new PrintWriter(new BufferedWriter(fw));	
		this.localAction = localAction;
		actions = new ArrayList<ChessActionImpl>();
		opponentPieces = new ArrayList<String>();
		positionList = game.getPositionlist();
		chessDomain = new FOLDomain();
		setPredicatenames();
		 
!!!1658114.java!!!	AChessAgent(inout KB : ChessKnowledgeBase, inout localAction : ChessActionImpl, inout game : PlayGame)
		super(KB);
		this.game = game;
		this.kb = (ChessKnowledgeBase)KB;
		try {
			fw = new FileWriter(outputFileName, true);
		} catch (IOException e1) {

			e1.printStackTrace();
		}
	    writer = new PrintWriter(new BufferedWriter(fw));	
		this.localAction = localAction;
		actions = new ArrayList<ChessActionImpl>();
		opponentPieces = new ArrayList<String>();
		positionList = game.getPositionlist();
		chessDomain = new FOLDomain();
		setPredicatenames();
		forwardChain = new FOLGamesFCAsk(); // A Forward Chain inference procedure see p. 332
		folKb = new FOLKnowledgeBase(chessDomain, forwardChain);
!!!1658242.java!!!	setPredicatenames() : void
		ACTION = KnowledgeBuilder.getACTION();
		ATTACKED = KnowledgeBuilder.getATTACKED();
		CANMOVE = KnowledgeBuilder.getCANMOVE();
		CAPTURE =  KnowledgeBuilder.getCAPTURE();
		CONQUER = KnowledgeBuilder.getCONQUER();
		MOVE =  KnowledgeBuilder.getMOVE();
		OWNER = KnowledgeBuilder.getOWNER();
		PROTECTED =  KnowledgeBuilder.getPROTECTED();
		REACHABLE = KnowledgeBuilder.getREACHABLE();
		SAFEMOVE = KnowledgeBuilder.getSAFEMOVE();
		STRIKE = KnowledgeBuilder.getSTRIKE();
		simpleProtected =  KnowledgeBuilder.getSimpleProtected();
		THREATEN = KnowledgeBuilder.getTHREATEN();
		PIECETYPE = KnowledgeBuilder.getPIECETYPE();
		PAWNMOVE = KnowledgeBuilder.getPAWNMOVE();
		PLAY = KnowledgeBuilder.getPLAY();
		chessDomain.addPredicate(PLAY);
		chessDomain.addPredicate(PROTECTED);
		chessDomain.addPredicate(MOVE);
		chessDomain.addPredicate(OWNER);
		chessDomain.addPredicate(REACHABLE);
		chessDomain.addPredicate(THREATEN);
		chessDomain.addPredicate(ACTION);
		chessDomain.addPredicate(CANMOVE);
		chessDomain.addPredicate(CAPTURE);
		chessDomain.addPredicate(CONQUER);
		chessDomain.addPredicate(SAFEMOVE);
		chessDomain.addPredicate(STRIKE);
		chessDomain.addPredicate(simpleProtected);
		chessDomain.addPredicate(PIECETYPE);
		chessDomain.addPredicate(PAWNMOVE);
		PAWN = KnowledgeBuilder.getPAWN();
		KNIGHT = KnowledgeBuilder.getKNIGHT();
		BISHOP = KnowledgeBuilder.getBISHOP();
		ROOK = KnowledgeBuilder.getROOK();
		KING = KnowledgeBuilder.getKING();
		QUEEN = KnowledgeBuilder.getQUEEN();
		
!!!1658370.java!!!	execute(inout state : Percept) : Action
		stateImpl = (ChessStateImpl)state;
//		Variable kingJohn = new Variable("John");
/*		List<Term> terms = new ArrayList<Term>();
		terms.add(kingJohn);
		Predicate mKing = new Predicate("king",terms);*/
		myPlayer = stateImpl.getMyPlayer();
		opponent = stateImpl.getOpponent();
		actions = stateImpl.getActions(); // creates new actions !!!
		int oppmoves = stateImpl.getOpponent().getMyMoves().size() -1;
		int mymoves = stateImpl.getMyPlayer().getMyMoves().size() -1;
	
		if (oppmoves < 0)
			oppmoves = 0;
		if (mymoves <0)
			mymoves = 0;
		noofMoves = game.getMovements().size();
		setActions(); // Add the move number to the available actions
		kb.setStateImpl(stateImpl);
		

		backwardChain = new FOLGamesBCAsk(); // A backward Chain inference procedure see p. 337
//		folKb = new FOLKnowledgeBase(chessDomain);
//		folKb = new FOLKnowledgeBase(chessDomain, forwardChain);
//		folKb.tell(mKing);
		solver = new AChessProblemSolver(stateImpl,localAction,folKb,chessDomain,forwardChain,backwardChain,game,myPlayer,opponent);
		
		setOpponentpieces(opponent);
		kb.setOpponentPieces(opponentPieces); // creates knowledge about the opponent both to the knowledge base
//	and the first order knowledge base and its domain

		String playerName = stateImpl.getMyPlayer().getNameOfplayer();
		Sentence playSentence = kb.newSymbol(kb.TOPLAY+playerName, noofMoves);
		kb.tell(playSentence);
		
		makeRules(noofMoves); // tells the FOL knowledgebase rules about how to capture opponent pieces
		HashSet<String> chessConstants = (HashSet<String>) chessDomain.getConstants();
		HashSet<String> chessPredicates = (HashSet<String>) chessDomain.getPredicates();
		String sample = "WhitePawn1";
		List<String> chessConstant = chessConstants.stream().collect(Collectors.toList());
		List<String> chesspredicateList = chessPredicates.stream().collect(Collectors.toList());
		writer.println("The chessdomain constants");
		for (String c:chessConstant) {
			writer.println(c);
		}
		writer.println("The chessdomain predicates");
		for (String c:chesspredicateList) {
			writer.println(c);
		}
		String pieceConstant = chessConstants.stream().filter(sample::equals).findAny().orElse(null);
		String chessPr = chesspredicateList.get(0);
		
		InferenceResult result = null;
		InferenceResult fcResult = null;
		Variable posVariable = null;
		Variable pieceVariable = null;
		Variable newPosition = null;
		List<Term> terms = new ArrayList<Term>();
		List<Variable> variables = new ArrayList<Variable>();
		List<InferenceResult>results = new ArrayList<InferenceResult>();
		pieceVariable= new Variable("x");
		posVariable = new Variable("y");
		newPosition = new Variable("z");
		
		variables.add(pieceVariable);
		variables.add(posVariable);
		terms.add(pieceVariable);
		terms.add(posVariable);
		
		Predicate folPredicate = new Predicate(chessPr,terms);  // The folPredicate is OWNER
		QuantifiedSentence qSentence = new QuantifiedSentence("FORALL",variables,folPredicate);
//		folKb.tell(qSentence);
		createConnected(playerName, "y", "x");
		safeMove(playerName,"y", "x");
		makeMove();
		makePawnmove(playerName, "y", "x");
/*		List<Term> ownerTerms = new ArrayList<Term>();
		Variable ownerVariable = new Variable(playerName);
		ownerTerms.add(ownerVariable);
		ownerTerms.add(pieceVariable);
		Predicate ownerPredicate = new Predicate(OWNER,ownerTerms);
		List<Term> reachableTerms = new ArrayList<Term>();
		reachableTerms.add(pieceVariable);
		reachableTerms.add(posVariable);
		Predicate reachablePredicate = new Predicate(REACHABLE,reachableTerms);
		List<Term> moveTerms = new ArrayList<Term>();
		moveTerms.add(pieceVariable);
		moveTerms.add(posVariable);
		Predicate movePredicate = new Predicate(MOVE,moveTerms);
		*/
		
//		ConnectedSentence reachableSentence = new ConnectedSentence(Connectors.AND,ownerPredicate,reachablePredicate);
//		ConnectedSentence goal = new ConnectedSentence(Connectors.IMPLIES,reachableSentence,movePredicate);
//		folKb.tell(reachableSentence);
//		folKb.tell(goal);

//		writer.println(chessDomain.toString());
//		result = folKb.ask(folPredicate);
//		result = folKb.ask(qSentence); 

//		fcResult = forwardChain.ask(folKb, folPredicate);
		writer.println("The first order knowledge base");
		writer.println(folKb.toString());
		
		
/*		Literal chessLiteral = new Literal(folPredicate);
		List<Literal> allLiterals = new ArrayList<Literal>();
		allLiterals.add(chessLiteral);
		LinkedHashSet<Map<Variable, Term>> mapResult = (LinkedHashSet<Map<Variable, Term>>) folKb.fetch(allLiterals);
		List<Map<Variable, Term>> listResults = mapResult.stream().collect(Collectors.toList());
		results.add(result);*/
//		results.add(fcResult);
/*		for (String c:chessConstants) {
//			String folSentence = chessPr+"("+c+"e1)";

	
			if (c.contains("White"))
			  pieceVariable= new Variable(c);
			if (!c.contains("White")&& !c.contains("Black"))
				posVariable = new Variable(c);
			if (posVariable != null && pieceVariable != null) {
				terms.add(pieceVariable);
				terms.add(posVariable);
				Predicate folPredicate = new Predicate(chessPr,terms);
				result = folKb.ask(folPredicate);
			
				results.add(result);
			}

		}*/
		
/*		for(InferenceResult res:results) {
			writer.println(InferenceResultPrinter.printInferenceResult(res));
			writer.println(res.toString());
		}*/
	
		
/*
 * To move this into makePerceptSentence ?		
 */

//		kb.tell("AFACT");
		emptyPositions = game.getNotusedPositionlist();

		makeOpponentsentences(stateImpl.getOpponent(),noofMoves);
		makeSentences();
		StringBuilder builder = new StringBuilder();
		
/*		builder.append("\nA CHESS Knowledge base\n");
		writer.println(builder.toString());
		List<Sentence> mySentences = kb.getSentences();
		Set<Clause> myClauses = kb.asCNF();
		for (Sentence sentence:mySentences) {
			writer.println(sentence.toString());
		}
		for (Clause clause:myClauses) {
			String def = "Not definite";
			if (clause.isDefiniteClause())
				def = "Definite";
			writer.println(clause.toString()+" "+def );
		}*/
		
		writer.flush();
/*
 * End move ?
 */
/*
 * Here we must ask the knowledge base what is the best action to perform:		
 */
		String pieceName = localAction.getChessPiece().getMyPiece().getOntlogyName();
//		List<List<ActionSchema>> solution = solver.solveProblem(localAction);
		
		for (ChessActionImpl action:actions) {
//			double evaluation = game.getGame().analyzePieceandPosition(action);
			if (action.getPossibleMove()!= null && !action.isBlocked()) {
				kb.askPossibleAction(action, noofMoves);
				askMove(myPlayer,action);
				List<List<ActionSchema>> othersolution = solver.solveProblem(action);
			}
			if (action.getActionValue() != null && action.getActionValue().intValue() >= 20) {
				localAction = action;
				return localAction;
			
			}
		}
	
		for (ChessActionImpl action:actions) {
			if (action.getActionValue() == null) {
				action.setActionValue(new Integer(0));
			}
		}
		List<Integer> sortedActions = actions.stream().sorted(Comparator.comparing(ChessActionImpl::getActionValue)).map(ChessActionImpl::getActionValue)
        .collect(Collectors.toList());
		
		int topValue = sortedActions.get(sortedActions.size()-1).intValue();
		for (ChessActionImpl action:actions) {
			int v = action.getActionValue().intValue();
			if (v>=topValue && topValue > 0) {
				localAction = action;
				break;
			}
		}

//		Sentence sentence = makePerceptSentence(state, 0);
//		KB.tell(sentence);
		return localAction;
//		return super.execute(state);
!!!1658498.java!!!	setActions() : void
		List<Term> actionTerms = new ArrayList<Term>();
		String movenr = Integer.toString(noofMoves);
		for (ChessActionImpl action:actions) {
			if (action.getPossibleMove() != null) {
		
				String pos = action.getPossibleMove().getToPosition().getPositionName();
				String name = action.getActionName();
				name = name + "_"+movenr;
				action.setActionName(name);
				action.setMoveNumber(new Integer(noofMoves));
				Constant actionVariable = new Constant(name);
				Constant posVariable = new Constant(pos);
				actionTerms.add(actionVariable);
				actionTerms.add(posVariable);
				Predicate actionPredicate = new Predicate(ACTION,actionTerms);
				name = null;
				actionTerms.clear();
				folKb.tell(actionPredicate);
			}

		}
!!!1658626.java!!!	createConnected(in name : String, in pos : String, in piece : String) : void
		List<Term> ownerTerms = new ArrayList<Term>();
		Constant ownerVariable = new Constant(name);
		Variable pieceVariable= new Variable(piece); // = x a variable
		Variable posVariable = new Variable(pos); // = y  a variable
		Variable newPosition = new Variable("z");
		ownerTerms.add(ownerVariable);
		ownerTerms.add(pieceVariable);
		Predicate ownerPredicate = new Predicate(OWNER,ownerTerms);
		List<Term> reachableTerms = new ArrayList<Term>();
		reachableTerms.add(pieceVariable);
		reachableTerms.add(posVariable);
		Predicate reachablePredicate = new Predicate(REACHABLE,reachableTerms);
		List<Term> moveTerms = new ArrayList<Term>();
		moveTerms.add(pieceVariable);
		moveTerms.add(posVariable);
		Predicate movePredicate = new Predicate(CANMOVE,moveTerms);
		ConnectedSentence reachableSentence = new ConnectedSentence(Connectors.AND,ownerPredicate,reachablePredicate);
		ConnectedSentence goal = new ConnectedSentence(Connectors.IMPLIES,reachableSentence,movePredicate);
		folKb.tell(goal);

!!!1658754.java!!!	safeMove(in name : String, in pos : String, in piece : String) : void
		List<Term> ownerTerms = new ArrayList<Term>();
		Constant ownerVariable = new Constant(name);
		Variable pieceVariable= new Variable(piece); // = x a variable
		Variable posVariable = new Variable(pos); // = y  a variable
		Variable protectedBy = new Variable("z");
		ownerTerms.add(ownerVariable);
		ownerTerms.add(pieceVariable);
		Predicate ownerPredicate = new Predicate(OWNER,ownerTerms);
		List<Term> reachableTerms = new ArrayList<Term>();
		reachableTerms.add(protectedBy);
		reachableTerms.add(posVariable);
		Predicate reachablePredicate = new Predicate(PROTECTED,reachableTerms);
		List<Term> moveTerms = new ArrayList<Term>();
		moveTerms.add(pieceVariable);
		moveTerms.add(posVariable);
		Predicate movePredicate = new Predicate(SAFEMOVE,moveTerms);
		ConnectedSentence reachableSentence = new ConnectedSentence(Connectors.AND,ownerPredicate,reachablePredicate);
		ConnectedSentence goal = new ConnectedSentence(Connectors.IMPLIES,reachableSentence,movePredicate);
		folKb.tell(goal);
!!!1658882.java!!!	makeMove() : void
		String p1 = "p1";
		String p2 = "p2";
		String pos = "pos";
		List<Term> moveTerms = new ArrayList<Term>();
		List<Term> safeTerms = new ArrayList<Term>();
		Variable movePiece = new Variable(p2);
		Variable position = new Variable (pos);
		moveTerms.add(movePiece);
		moveTerms.add(position);
		safeTerms.add(movePiece);
		safeTerms.add(position);
		Predicate safePredicate = new Predicate(SAFEMOVE,safeTerms);
		Predicate canmovePredicate = new Predicate(CANMOVE,moveTerms);
		Predicate movePredicate = new Predicate(MOVE,moveTerms);
		ConnectedSentence possibleSentence = new ConnectedSentence(Connectors.AND,safePredicate,canmovePredicate);
		ConnectedSentence goal = new ConnectedSentence(Connectors.IMPLIES,possibleSentence,movePredicate);
		folKb.tell(goal);
!!!1659010.java!!!	makePawnmove(in name : String, in pos : String, in piece : String) : void
		List<Term> ownerTerms = new ArrayList<Term>();
		Constant ownerVariable = new Constant(name);
		Variable pieceVariable= new Variable(piece); // = x a variable
		Variable posVariable = new Variable(pos); // = y  a variable
		Variable newPosition = new Variable("z");
		ownerTerms.add(ownerVariable);
		ownerTerms.add(pieceVariable);
		Predicate ownerPredicate = new Predicate(OWNER,ownerTerms);
		List<Term> reachableTerms = new ArrayList<Term>();
		reachableTerms.add(pieceVariable);
		reachableTerms.add(posVariable);
		Predicate reachablePredicate = new Predicate(REACHABLE,reachableTerms);
		List<Term> pieceTypeterms = new ArrayList<Term>();
		Constant typeVariable = new Constant(PAWN);
		pieceTypeterms.add(pieceVariable);
		pieceTypeterms.add(typeVariable);
		Predicate typePredicate = new Predicate(PIECETYPE,pieceTypeterms);
		ConnectedSentence possibleSentence = new ConnectedSentence(Connectors.AND,ownerPredicate,reachablePredicate);
		ConnectedSentence typeSentence = new ConnectedSentence(Connectors.AND,possibleSentence,typePredicate);
		List<Term> moveTerms = new ArrayList<Term>();
		moveTerms.add(pieceVariable);
		moveTerms.add(posVariable);
		Predicate movePredicate = new Predicate(PAWNMOVE,moveTerms);
		ConnectedSentence goal = new ConnectedSentence(Connectors.IMPLIES,typeSentence,movePredicate);
		folKb.tell(goal);	
!!!1659138.java!!!	askMove(inout player : APlayer, inout action : ChessActionImpl) : void
		List<AgamePiece> pieces = player.getMygamePieces();
		
		String playername = player.getNameOfplayer();
		AgamePiece piece = action.getChessPiece();
		String name = action.getChessPiece().getMyPiece().getOntlogyName(); 

		List<Position> availablePositions = piece.getNewlistPositions();
		if (availablePositions != null && !availablePositions.isEmpty()) {
			for (Position pos:availablePositions){
				if(!piece.checkRemoved(pos)) {
					String position = pos.getPositionName();
					Constant pieceVariable = new Constant(name);
					Constant posVariable = new Constant(position);
					ChessPieceType pieceType = piece.getChessType();
					Constant typeVariable = null;
					List<Term>typeTerms = new ArrayList<Term>();
					List<Term> moveTerms = new ArrayList<Term>();
					moveTerms.add(pieceVariable);
					moveTerms.add(posVariable);
					Predicate movePredicate = new Predicate(MOVE,moveTerms);
					Predicate pawnPredicate = new Predicate(PAWNMOVE,moveTerms);
					if (pieceType instanceof APawn) {
						typeVariable = new Constant(PAWN);
						typeTerms.add(pieceVariable);
						typeTerms.add(typeVariable);
						Predicate typePredicate = new Predicate(PIECETYPE,typeTerms);
//						ConnectedSentence possibleSentence = new ConnectedSentence(Connectors.AND,typePredicate,pawnPredicate);
						writer.println(" Also trying to prove\n"+pawnPredicate.toString());
						InferenceResult pawnresult =  backwardChain.ask(folKb, pawnPredicate);
						writer.println(InferenceResultPrinter.printInferenceResult(pawnresult));
						
					}

					writer.println("Trying to prove\n"+movePredicate.toString());
					InferenceResult result = forwardChain.ask(folKb,movePredicate);
					writer.println(InferenceResultPrinter.printInferenceResult(result));
					writer.println("Trying to prove backward chaining\n"+movePredicate.toString());
					InferenceResult backWardresult =  backwardChain.ask(folKb, movePredicate);
			
			
	
					
					BCGamesAskHandler bcHandler = (BCGamesAskHandler) backWardresult;
//					writer.println(bcHandler.toString());
					writer.println(InferenceResultPrinter.printInferenceResult(backWardresult));
					
				}
			}
		}
		

!!!1659266.java!!!	makeRules(in t : int) : void
		APlayer player= stateImpl.getMyPlayer();
		chessDomain.addConstant(player.getNameOfplayer());
//		chessDomain.addPredicate(OWNER);
		Constant ownerVariable = new Constant(player.getNameOfplayer());
		playerName = player.getNameOfplayer();
		String predicate = "";
//		chessDomain.addPredicate(PROTECTED);
//		chessDomain.addPredicate(MOVE);
		List<AgamePiece> pieces = player.getMygamePieces();
		for (AgamePiece piece:pieces) {
			createType(piece);
			List<Term> ownerTerms = new ArrayList<Term>();
			ownerTerms.add(ownerVariable);
			String name = piece.getMyPiece().getOntlogyName(); 
			String posName = piece.getmyPosition().getPositionName();
			chessDomain.addConstant(posName);
			chessDomain.addConstant(name);
			chessDomain.addPredicate(piece.returnPredicate());
			if (!predicate.equals(piece.returnPredicate())) {
				predicate = piece.returnPredicate();
			}
//			predicate = predicate+"("+name+","+posName+")";
			chessDomain.addPredicate(predicate);
//			chessDomain.addConstant(predicate);
			Constant pieceVariable = new Constant(name);
			Constant posVariable = new Constant(posName);
			List<Term> terms = new ArrayList<Term>();
			terms.add(pieceVariable);
			terms.add(posVariable);
			ownerTerms.add(pieceVariable);
			Predicate folPredicate = new Predicate(predicate,terms);
			Predicate ownerPredicate = new Predicate(OWNER,ownerTerms);
			folKb.tell(folPredicate);
			folKb.tell(ownerPredicate);
		
			HashMap<String,Position> attackMap = piece.getAttackPositions();
			List<Position> attackPositions = null;
			if (attackMap != null)
				attackPositions = new ArrayList(attackMap.values());
			List<Position> availablePositions = piece.getNewlistPositions();
			boolean pawnattack = false;
			if (attackPositions != null && !attackPositions.isEmpty())
				pawnattack = true;
			if (availablePositions != null && !availablePositions.isEmpty()) {
//				chessDomain.addPredicate(REACHABLE);
				for (Position pos:availablePositions){
					if(!piece.checkRemoved(pos)) {
						String position = pos.getPositionName();
						Constant protectorVariable = new Constant(name);
						Constant protectedVariable = new Constant(position);
						List<Term> protectedTerms = new ArrayList<Term>();
						protectedTerms.add(protectorVariable);
						protectedTerms.add(protectedVariable);
						
						Predicate protectorPredicate = new Predicate(PROTECTED,protectedTerms);
						Predicate reachablePredicate = new Predicate(REACHABLE,protectedTerms);
						if (!pawnattack) {
							folKb.tell(protectorPredicate);
							kb.tellCaptureRules(t, position, name);
						}
						folKb.tell(reachablePredicate);
						chessDomain.addConstant(position);
				
					}
				}
			}
			if (pawnattack) {
				for (Position pos:attackPositions){
					if(!piece.checkRemoved(pos)) {
						String position = pos.getPositionName();
						Constant protectorVariable = new Constant(name);
						Constant protectedVariable = new Constant(position);
						List<Term> protectedTerms = new ArrayList<Term>();
						protectedTerms.add(protectorVariable);
						protectedTerms.add(protectedVariable);
						Predicate protectorPredicate = new Predicate(PROTECTED,protectedTerms);
/*						Constant typeVariable = new Constant(PAWN);
						List<Term> typeTerms = new ArrayList<Term>();
						typeTerms.add(protectorVariable);
						typeTerms.add(typeVariable);
						Predicate typePredicate = new Predicate(PIECETYPE,typeTerms);
						folKb.tell(typePredicate);*/
						folKb.tell(protectorPredicate);
						chessDomain.addConstant(position);
						kb.tellCaptureRules(t, position, name);
					}
				}
			}
		}
!!!1659394.java!!!	createType(inout piece : AgamePiece) : void
		ChessPieceType pieceType = piece.getChessType();
		List<Term> pieceTypeterms = new ArrayList<Term>();
		String name = piece.getMyPiece().getOntlogyName();
		Constant pieceVariable = new Constant(name);
		Constant typeVariable = null;
		if (pieceType instanceof APawn) {
			typeVariable = new Constant(PAWN);
		}
		if (pieceType instanceof ABishop) {
			typeVariable = new Constant(BISHOP);
		}
		if (pieceType instanceof ARook) {
			typeVariable = new Constant(ROOK);
		}
		if (pieceType instanceof AQueen) {
			typeVariable = new Constant(QUEEN);
		}
		if (pieceType instanceof AKnight) {
			typeVariable = new Constant(KNIGHT);
		}
		if (pieceType instanceof Aking) {
			typeVariable = new Constant(KING);
		}
		if (typeVariable != null) {
			pieceTypeterms.add(pieceVariable);
			pieceTypeterms.add(typeVariable);
			Predicate typePredicate = new Predicate(PIECETYPE,pieceTypeterms);
			folKb.tell(typePredicate);
		}
!!!1659522.java!!!	makeSentences() : void
		APlayer player= stateImpl.getMyPlayer();
		List<AgamePiece> pieces = player.getMygamePieces();
		ABishop b = null;
		ARook r = null;
		AQueen qt = null;
		AKnight kn = null;
		Aking king = null;
		for (AgamePiece piece:pieces) {
			String name = piece.getMyPiece().getOntlogyName();
			piece.setPredicate(piece.getMyPiece().getPredicate());
			ChessPieceType pieceType = piece.getChessType();
			if (pieceType instanceof ABishop) {
				b = (ABishop) pieceType;
				kb.setOwnBishop(name);
			}
			if (pieceType instanceof ARook) {
				r = (ARook) pieceType;
				kb.setOwnRook(name);
			}
			if (pieceType instanceof AQueen) {
				qt = (AQueen) pieceType;
				kb.setOwnQueen(name);
			}
			if (pieceType instanceof AKnight) {
				kn = (AKnight) pieceType;
				kb.setOwnKnight(name);
			}
			if (pieceType instanceof Aking) {
				king = (Aking) pieceType;
				kb.setOwnKing(name);
			}			

			String position = piece.getmyPosition().getPositionName();
			Sentence sentence = kb.newSymbol(name+"_"+"AT"+position, noofMoves);
			kb.tell(sentence);
		}		
		for (ChessActionImpl action:actions) {
			Sentence sentence = makeActionSentence(action,noofMoves);
			if (sentence != null)
				kb.tell(sentence);
		}
		for (Position position:emptyPositions) {
			String name = position.getPositionName();
			Sentence sentence =  kb.newSymbol(name+"_",noofMoves);
			kb.tell(sentence);
		}
!!!1659650.java!!!	makeOpponentsentences(inout opponent : APlayer, in t : int) : void
		List<AgamePiece> pieces = opponent.getMygamePieces();
		for (AgamePiece piece:pieces) {
			String name = piece.getMyPiece().getOntlogyName();
			String position = piece.getmyPosition().getPositionName();
			piece.setPredicate(piece.getMyPiece().getPredicate());
			Sentence sentence = kb.newSymbol(name+"_"+"AT"+position, t);
			kb.tell(sentence);
			HashMap<String,Position> reachablePositions = piece.getReacablePositions();
			HashMap<String,Position> attackPositions = piece.getAttackPositions();
			List<Position> piecePositions = null;
			piecePositions = piece.getNewlistPositions();
			if (attackPositions != null && !attackPositions.isEmpty()) {
				piecePositions = new ArrayList(attackPositions.values());
			}

//			List<Position> piecePositions = new ArrayList(reachablePositions.values());
			for (Position opponentposition:piecePositions) {
				if (!piece.checkRemoved(opponentposition)) {
					String pos = opponentposition.getPositionName();
					Sentence attacksentence = kb.newSymbol(THREATEN+name+"_"+pos, t);
					kb.tell(attacksentence);
					Sentence protectSentence = kb.newSymbol(PROTECTED+name+"_"+pos, t);
					kb.tell(protectSentence);
				}
			}

		}
		
!!!1659778.java!!!	setOpponentpieces(inout opponent : APlayer) : void
		List<AgamePiece> pieces = opponent.getMygamePieces();
		chessDomain.addConstant(opponent.getNameOfplayer());
		Constant ownerVariable = new Constant(opponent.getNameOfplayer());
		String predicate = "";
		chessDomain.addPredicate(THREATEN);
		for (AgamePiece piece:pieces) {
			createType(piece);
			List<Term> ownerTerms = new ArrayList<Term>();
			ownerTerms.add(ownerVariable);
			String name = piece.getMyPiece().getOntlogyName();
			String posName = piece.getmyPosition().getPositionName();
			chessDomain.addConstant(posName);
			chessDomain.addConstant(name);
			chessDomain.addPredicate(piece.returnPredicate());
			if (!predicate.equals(piece.returnPredicate())) {
				predicate = piece.returnPredicate();
			}
//			predicate = predicate+"("+name+","+posName+")";
			chessDomain.addPredicate(predicate);
//			chessDomain.addConstant(predicate);
			Constant pieceVariable = new Constant(name);
			Constant posVariable = new Constant(posName);
			ownerTerms.add(pieceVariable);
			Predicate ownerPredicate = new Predicate(OWNER,ownerTerms);

			List<Term> terms = new ArrayList<Term>();
			terms.add(pieceVariable);
			terms.add(posVariable);
			Predicate folPredicate = new Predicate(predicate,terms);
			folKb.tell(folPredicate);
			folKb.tell(ownerPredicate);

			opponentPieces.add(name);
			HashMap<String,Position> attackMap = piece.getAttackPositions();
			List<Position> attackPositions = null;
			if (attackMap != null)
				attackPositions = new ArrayList(attackMap.values());
			List<Position> availablePositions = piece.getNewlistPositions();
			if (attackPositions != null && !attackPositions.isEmpty())
				availablePositions = attackPositions;
			if (availablePositions != null && !availablePositions.isEmpty()) {
				for (Position pos:availablePositions){
					if(!piece.checkRemoved(pos)) {
						String position = pos.getPositionName();
						Constant protectorVariable = new Constant(name);
						Constant protectedVariable = new Constant(position);
						List<Term> protectedTerms = new ArrayList<Term>();
						protectedTerms.add(protectorVariable);
						protectedTerms.add(protectedVariable);
						Predicate protectorPredicate = new Predicate(THREATEN,protectedTerms);
						folKb.tell(protectorPredicate);
						chessDomain.addConstant(position);

					}
				}
			}
		}
!!!1659906.java!!!	ask(inout kb : KnowledgeBase, inout sentence : Sentence) : Action
		// TODO Auto-generated method stub
		return null;
!!!1660034.java!!!	makeActionQuery(in t : int) : Sentence
		// TODO Auto-generated method stub
		return null;
!!!1660162.java!!!	makeActionSentence(inout action : Action, in t : int) : Sentence
		ChessActionImpl thisAction = (ChessActionImpl) action;
		double evaluation = game.getGame().analyzePieceandPosition(thisAction);
		String active = "NOMOV";
		List<AgamePiece> attackedPieces = thisAction.getAttacked();
		List<Position> protectedPositions = thisAction.getProtectedPositions();
		List<Position> attackedPositions = thisAction.getAttackedPositions();
		List<Position> otherprotectedPositions = thisAction.getOtherprotectedPositions();
		if (attackedPieces != null) {
			for (AgamePiece attackedPiece:attackedPieces) {
				String name = attackedPiece.getMyPiece().getOntlogyName();
				String pos = attackedPiece.getMyPosition().getPositionName();
				String attack = "ATTACK";
				Sentence sentence = kb.newSymbol(attack+name+"_"+pos, t);
				kb.tell(sentence);
			}
		}
		if (protectedPositions != null) {
			for (Position protectedPos:protectedPositions) {
				String name = thisAction.getChessPiece().getMyPiece().getOntlogyName();
				String pos = protectedPos.getPositionName();
				Sentence sentence = kb.newSymbol(PROTECTED+name+"_"+pos, t);
				Sentence simple = kb.newSymbol(simpleProtected +"_"+pos, t);
				kb.tell(sentence);
				kb.tell(simple);
			}
			
		}
		if (otherprotectedPositions != null) {
			for (Position protectedPos:otherprotectedPositions) {
				String name = thisAction.getChessPiece().getMyPiece().getOntlogyName();
				String pos = protectedPos.getPositionName();
				Sentence sentence = kb.newSymbol(PROTECTED+name+"_"+pos, t);
				kb.tell(sentence);
				Sentence attacksentence = kb.newSymbol(ATTACKED+name+"_"+pos, t);
				kb.tell(attacksentence);
			}
			
		}		
		if (attackedPositions != null) {
			for (Position attackedPos:attackedPositions) {
				String pos = attackedPos.getPositionName();
				String name = thisAction.getChessPiece().getMyPiece().getOntlogyName();
				Sentence sentence = kb.newSymbol(ATTACKED+name+"_"+pos, t);
				kb.tell(sentence);
			}
		}
		if (thisAction.getChessPiece().isActive() ) {
			String name = thisAction.getChessPiece().getMyPiece().getOntlogyName();
			String position = thisAction.getChessPiece().getmyPosition().getPositionName();
			ApieceMove move = thisAction.getPossibleMove();
			if (move == null || thisAction.isBlocked()) {
				Sentence sentence = kb.newSymbol(active+name+"_AT"+position, t);
//				kb.tell(sentence);
				return sentence;
			}
			if (move != null && !thisAction.isBlocked()) {
//				String moveNotation = move.getMoveNotation();
				String toPos = move.getToPosition().getPositionName();
/*				if (moveNotation == null || moveNotation.equals(""))
					moveNotation ="MOV";
				String toPos = move.getToPosition().getPositionName();
				Sentence sentence = kb.newSymbol(moveNotation+name+"_"+toPos, t);*/
//				kb.tell(sentence);
				Sentence sentence = kb.newSymbol(ACTION+name+"_AT"+position, t);
				thisAction.setSentence(sentence);
//				kb.tell(sentence);
				kb.tellmoveRule(kb.newSymbol(ACTION+name+"_TO"+toPos, t), "AT"+position, t);
				return sentence;
			}
		}
		if (!thisAction.getChessPiece().isActive()) {
			active = "VAC";
//			Position newPos = thisAction.getPreferredPosition(); // Makes a new attempt creating a new possible move for this action.
//			ApieceMove newMove = thisAction.getPossibleMove();
			String pieceName = thisAction.getChessPiece().getMyPiece().getOntlogyName();
			String position = thisAction.getChessPiece().getmyPosition().getPositionName();
			return kb.newSymbol(active+pieceName+"_"+position, t);
		}
			

		return null;
!!!1660290.java!!!	makePerceptSentence(inout state : Percept, in t : int) : Sentence
		ChessActionImpl action = stateImpl.getChessAction();
		if (localAction == action) {
			String name = localAction.getChessPiece().getMyPiece().getOntlogyName();
			String position = localAction.getChessPiece().getmyPosition().getPositionName();
			return kb.newSymbol(name+"_"+position, 0);
			
		}
		return null;
