class TranspositionMinimax
!!!2481026.java!!!	TranspositionMinimax()
 
        this(new TranspositionTableFactory<T>() { 
   @Override 
            public Map<T, Double> newTransposition() { 
    return new HashMap<>(); 
   } 
        }); 
!!!2481154.java!!!	TranspositionMinimax(inout transpositionTableFactory : TranspositionMinimax::TranspositionTableFactory)
 
        super(); 
        this.transpositionTableMap = initTranspositionTableMap(); 
        this.transpositionTableFactory = transpositionTableFactory; 
!!!2481282.java!!!	TranspositionMinimax(inout algo : Minimax::Algorithm)
 
        this(algo, new TranspositionTableFactory<T>() { 
            @Override 
            public Map<T, Double> newTransposition() { 
                return new HashMap<>(); 
            } 
        }); 
!!!2481410.java!!!	TranspositionMinimax(inout algo : Minimax::Algorithm, inout transpositionTableFactory : TranspositionMinimax::TranspositionTableFactory)
 
        super(algo); 
        this.transpositionTableMap = initTranspositionTableMap(); 
        this.transpositionTableFactory = transpositionTableFactory; 
!!!2481538.java!!!	TranspositionMinimax(inout algo : Minimax::Algorithm, in initialCapacity : int)
 
        super(algo); 
        this.transpositionTableMap = initTranspositionTableMap(); 
        this.transpositionTableFactory = new TranspositionTableFactory<T>() { 
   @Override 
   public Map<T, Double> newTransposition() { 
    return new HashMap<>(initialCapacity); 
   } 
        }; 
!!!2481666.java!!!	TranspositionMinimax(inout algo : Minimax::Algorithm, in initialCapacity : int, in loadFactor : float)
 
        super(algo); 
        this.transpositionTableMap = initTranspositionTableMap(); 
        this.transpositionTableFactory = new TranspositionTableFactory<T>() { 
   @Override 
   public Map<T, Double> newTransposition() { 
    return new HashMap<>(initialCapacity, loadFactor); 
   } 
        }; 
!!!2481794.java!!!	initTranspositionTableMap() : TreeMap<G, Map<T, Double>>
 
        Type t = getClass().getGenericSuperclass(); 
        // search for the Group class within class hierarchy 
        while (!(t instanceof ParameterizedType  
                && TranspositionMinimax.class.getSimpleName().equals( 
                        ((Class<?>) ((ParameterizedType) t).getRawType()).getSimpleName()))) { 
            t = ((Class<?>) t).getGenericSuperclass(); 
        }  
     Class<G> cls = (Class<G>) ((ParameterizedType) t).getActualTypeArguments()[2]; 
        if (Comparable.class.isAssignableFrom(cls)) { 
         // the transposition Group type is Comparable 
         return new TreeMap<>(); 
        } else if (cls.isAssignableFrom(Void.class)) { 
         // no transposition Group required 
         // use everything-is-equal Comparator 
         return new TreeMap<>(new Comparator<G>() { 
                @Override 
                public int compare(G o1, G o2) { 
                    return 0; 
                } 
            }); 
        } else { 
         throw new IllegalArgumentException("The transposition group type : " + cls.getSimpleName() + " is neither Void nor implement the java.lang.Comparable interface."); 
        } 
!!!2481922.java!!!	getTranspositionTableMap() : TreeMap<G, Map<T, Double>>
 
        return this.transpositionTableMap; 
!!!2482050.java!!!	getBestMove(in depth : int) : M
 
     if (clearGroupsBeforeSearch()) { 
      clearGroups(getGroup()); 
     } 
        M m = super.getBestMove(depth); 
     if (clearGroupsAfterSearch()) { 
      clearGroups(getGroup()); 
     } 
     return m; 
!!!2482178.java!!!	useTranspositionTable() : boolean
 
     return true; 
!!!2482306.java!!!	clearGroups(inout currentGroup : G) : void
 
     if (currentGroup != null) { 
      // free memory : 
            // evict unnecessary transpositions 
      transpositionTableMap.headMap(currentGroup).clear(); 
     } 
!!!2482434.java!!!	clearGroupsBeforeSearch() : boolean
 
     return false; 
!!!2482562.java!!!	clearGroupsAfterSearch() : boolean
 
     return false; 
!!!2482690.java!!!	clearTranspositionTable() : void
 
     transpositionTableMap.clear(); 
!!!2482946.java!!!	getSymetricTranspositions() : Collection<T>
 
        return Collections.singleton(getTransposition()); 
!!!2483202.java!!!	saveTransposition(inout transpositionTable : Map<T, Double>, in score : double) : void
 
        if (transpositionTable == null) { 
            transpositionTable = transpositionTableFactory.newTransposition(); 
            transpositionTableMap.put(getGroup(), transpositionTable); 
        } 
        // save transposition 
        for (T st : getSymetricTranspositions()) { 
            transpositionTable.put(st, score); 
        } 
!!!2483330.java!!!	minimaxScore(in depth : int, in who : int) : double
 
     if (!useTranspositionTable()) { 
      return super.minimaxScore(depth, who); 
     } 
     double score = 0; 
     T t = getTransposition(); 
        Map<T, Double> transpositionTable = transpositionTableMap.get(getGroup()); 
        if (transpositionTable != null && transpositionTable.containsKey(t)) { 
            // transposition found 
            // we can stop here as we already know the value 
            // returned by the evaluation function 
            score = who * transpositionTable.get(t); 
        } else { 
            score = super.minimaxScore(depth, who); 
            saveTransposition(transpositionTable, who * score); 
        } 
        return score; 
!!!2483458.java!!!	alphabetaScore(in depth : int, in who : int, in alpha : double, in beta : double) : double
 
     if (!useTranspositionTable()) { 
      return super.alphabetaScore(depth, who, alpha, beta); 
     } 
     double score = 0; 
        T t = getTransposition(); 
        Map<T, Double> transpositionTable = transpositionTableMap.get(getGroup()); 
        if (transpositionTable != null && transpositionTable.containsKey(t)) { 
            // transposition found 
            // we can stop here as we already know the value 
            // returned by the evaluation function 
            score = who * transpositionTable.get(t); 
        } else { 
            score = super.alphabetaScore(depth, who, alpha, beta); 
            saveTransposition(transpositionTable, who * score); 
        } 
        return score; 
!!!2483586.java!!!	negamaxScore(in depth : int, in alpha : double, in beta : double) : double
 
     if (!useTranspositionTable()) { 
      return super.negamaxScore(depth, alpha, beta); 
     } 
     double score = 0; 
        T t = getTransposition(); 
        Map<T, Double> transpositionTable = transpositionTableMap.get(getGroup()); 
        if (transpositionTable != null && transpositionTable.containsKey(t)) { 
            // transposition found 
            // we can stop here as we already know the value 
            // returned by the evaluation function 
            score = transpositionTable.get(t); 
        } else { 
            score = super.negamaxScore(depth, alpha, beta); 
            saveTransposition(transpositionTable, score); 
        } 
        return score; 
!!!2483714.java!!!	negascoutScore(inout first : boolean, in depth : int, in alpha : double, in beta : double, in b : double) : double
 
     if (!useTranspositionTable()) { 
      return super.negascoutScore(first, depth, alpha, beta, b); 
     } 
     double score = 0; 
        T t = getTransposition(); 
        Map<T, Double> transpositionTable = transpositionTableMap.get(getGroup()); 
        if (transpositionTable != null && transpositionTable.containsKey(t)) { 
            // transposition found 
            // we can stop here as we already know the value 
            // returned by the evaluation function 
            score = transpositionTable.get(t); 
        } else { 
            score = super.negascoutScore(first, depth, alpha, beta, b); 
            saveTransposition(transpositionTable, score); 
        } 
        return score; 
