class KnowledgeBuilder
!!!2163074.java!!!	getPIECE() : String
	return PIECE;
!!!2163202.java!!!	setPIECE(in pIECE : String) : void
	  PIECE = pIECE;
!!!2163330.java!!!	getOPPONENTTO() : String
	  return OPPONENTTO;
!!!2163458.java!!!	getPOSSIBLEPROTECT() : String
	  return POSSIBLEPROTECT;
!!!2163586.java!!!	setPOSSIBLEPROTECT(in pOSSIBLEPROTECT : String) : void
	  POSSIBLEPROTECT = pOSSIBLEPROTECT;
!!!2163714.java!!!	getPOSSIBLEREACH() : String
	  return POSSIBLEREACH;
!!!2163842.java!!!	setPOSSIBLEREACH(in pOSSIBLEREACH : String) : void
	  POSSIBLEREACH = pOSSIBLEREACH;
!!!2163970.java!!!	setOPPONENTTO(in oPPONENTTO : String) : void
	  OPPONENTTO = oPPONENTTO;
!!!2164098.java!!!	getPOSSIBLETHREAT() : String
	  return POSSIBLETHREAT;
!!!2164226.java!!!	setPOSSIBLETHREAT(in pOSSIBLETHREAT : String) : void
	  POSSIBLETHREAT = pOSSIBLETHREAT;
!!!2164354.java!!!	getCASTLE() : String
	  return CASTLE;
!!!2164482.java!!!	setCASTLE(in cASTLE : String) : void
	  CASTLE = cASTLE;
!!!2164610.java!!!	getBOARD() : String
	  return BOARD;
!!!2164738.java!!!	setBOARD(in bOARD : String) : void
	  BOARD = bOARD;
!!!2164866.java!!!	getPLAYER() : String
	  return PLAYER;
!!!2164994.java!!!	setPLAYER(in pLAYER : String) : void
	  PLAYER = pLAYER;
!!!2165122.java!!!	getPAWNATTACK() : String
	  return PAWNATTACK;
!!!2165250.java!!!	setPAWNATTACK(in pAWNATTACK : String) : void
	  PAWNATTACK = pAWNATTACK;
!!!2165378.java!!!	getOCCUPIES() : String
	  return OCCUPIES;
!!!2165506.java!!!	setOCCUPIES(in oCCUPIES : String) : void
	  OCCUPIES = oCCUPIES;
!!!2165634.java!!!	getPLAY() : String
		return PLAY;
!!!2165762.java!!!	setPLAY(in pLAY : String) : void
		PLAY = pLAY;
!!!2165890.java!!!	getPAWN() : String
		return PAWN;
!!!2166018.java!!!	setPAWN(in pAWN : String) : void
		PAWN = pAWN;
!!!2166146.java!!!	getKNIGHT() : String
		return KNIGHT;
!!!2166274.java!!!	setKNIGHT(in kNIGHT : String) : void
		KNIGHT = kNIGHT;
!!!2166402.java!!!	getBISHOP() : String
		return BISHOP;
!!!2166530.java!!!	setBISHOP(in bISHOP : String) : void
		BISHOP = bISHOP;
!!!2166658.java!!!	getROOK() : String
		return ROOK;
!!!2166786.java!!!	setROOK(in rOOK : String) : void
		ROOK = rOOK;
!!!2166914.java!!!	getKING() : String
		return KING;
!!!2167042.java!!!	setKING(in kING : String) : void
		KING = kING;
!!!2167170.java!!!	getQUEEN() : String
		return QUEEN;
!!!2167298.java!!!	setQUEEN(in qUEEN : String) : void
		QUEEN = qUEEN;
!!!2167426.java!!!	getPAWNMOVE() : String
		return PAWNMOVE;
!!!2167554.java!!!	setPAWNMOVE(in pAWNMOVE : String) : void
		PAWNMOVE = pAWNMOVE;
!!!2167682.java!!!	getPIECETYPE() : String
		return PIECETYPE;
!!!2167810.java!!!	setPIECETYPE(in pIECETYPE : String) : void
		PIECETYPE = pIECETYPE;
!!!2167938.java!!!	getACTION() : String
		return ACTION;
!!!2168066.java!!!	setACTION(in aCTION : String) : void
		ACTION = aCTION;
!!!2168194.java!!!	getPROTECTED() : String
		return PROTECTED;
!!!2168322.java!!!	setPROTECTED(in pROTECTED : String) : void
		PROTECTED = pROTECTED;
!!!2168450.java!!!	getSimpleProtected() : String
		return simpleProtected;
!!!2168578.java!!!	setSimpleProtected(in simpleProtected : String) : void
		KnowledgeBuilder.simpleProtected = simpleProtected;
!!!2168706.java!!!	getATTACKED() : String
	  return ATTACKED;
!!!2168834.java!!!	setATTACKED(in aTTACKED : String) : void
		ATTACKED = aTTACKED;
!!!2168962.java!!!	getCAPTURE() : String
		return CAPTURE;
!!!2169090.java!!!	setCAPTURE(in cAPTURE : String) : void
		CAPTURE = cAPTURE;
!!!2169218.java!!!	getCONQUER() : String
		return CONQUER;
!!!2169346.java!!!	setCONQUER(in cONQUER : String) : void
		CONQUER = cONQUER;
!!!2169474.java!!!	getTHREATEN() : String
		return THREATEN;
!!!2169602.java!!!	setTHREATEN(in tHREATEN : String) : void
		THREATEN = tHREATEN;
!!!2169730.java!!!	getOWNER() : String
		return OWNER;
!!!2169858.java!!!	setOWNER(in oWNER : String) : void
		OWNER = oWNER;
!!!2169986.java!!!	getMOVE() : String
		return MOVE;
!!!2170114.java!!!	setMOVE(in mOVE : String) : void
		MOVE = mOVE;
!!!2170242.java!!!	getREACHABLE() : String
		return REACHABLE;
!!!2170370.java!!!	setREACHABLE(in rEACHABLE : String) : void
		REACHABLE = rEACHABLE;
!!!2170498.java!!!	getCANMOVE() : String
		return CANMOVE;
!!!2170626.java!!!	setCANMOVE(in cANMOVE : String) : void
		CANMOVE = cANMOVE;
!!!2170754.java!!!	getSAFEMOVE() : String
		return SAFEMOVE;
!!!2170882.java!!!	setSAFEMOVE(in sAFEMOVE : String) : void
	  SAFEMOVE = sAFEMOVE;
!!!2171010.java!!!	getSTRIKE() : String
	  return STRIKE;
!!!2171138.java!!!	setSTRIKE(in sTRIKE : String) : void
	  STRIKE = sTRIKE;
!!!2171266.java!!!	getOCCUPY() : String
	return OCCUPY;
!!!2171394.java!!!	setOCCUPY(in oCCUPY : String) : void
	OCCUPY = oCCUPY;
!!!2171522.java!!!	getPROTECT() : String
	return PROTECT;
!!!2171650.java!!!	setPROTECT(in pROTECT : String) : void
	PROTECT = pROTECT;
!!!2171778.java!!!	getMAKESTRONG() : String
	return MAKESTRONG;
!!!2171906.java!!!	setMAKESTRONG(in mAKESTRONG : String) : void
	MAKESTRONG = mAKESTRONG;
!!!2172034.java!!!	getAllconstants() : Constant
	return allconstants;
!!!2172162.java!!!	setAllconstants(inout allconstants : List<Constant>) : void
	KnowledgeBuilder.allconstants = allconstants;
!!!2172290.java!!!	getPieceType(inout piece : AgamePiece) : String
	  pieceType type = piece.getPieceType();
	  if (type == type.PAWN) {
		  return PAWN;
	  }
	  if (type == type.BISHOP) {
		  return BISHOP;
	  }		
	  if (type == type.ROOK) {
		  return ROOK;
	  }			
	  if (type == type.KNIGHT) {
		  return KNIGHT;
	  }
	  if (type == type.QUEEN) {
		  return QUEEN;
	  }
	  if (type == type.KING) {
		  return KING;
	  }	
	  return null;
!!!2172418.java!!!	parseSentence(in sentence : String, in goalSentence : String, inout kb : FOLKnowledgeBase) : void
	  List<Literal> rules = Utils.parse(sentence);
	  List<Literal> goals = Utils.parse(goalSentence);
	  ConnectedSentence premise = null;
	  int s = rules.size();
	  for (int i= 0; i < s;i=i+2) {
		  Predicate p = (Predicate) rules.get(i).getAtomicSentence();
		  Predicate y = (Predicate) rules.get(i+1).getAtomicSentence();	
		  premise = new ConnectedSentence(Connectors.AND,p,y);

	  }
	  Predicate g = (Predicate)goals.get(0).getAtomicSentence();
	  ConnectedSentence goal = new ConnectedSentence(Connectors.IMPLIES,premise,g);
	  kb.tell(goal);

!!!2172546.java!!!	createOccupyaction(inout  : String...names) : ActionSchema
	int nargs = names.length;
	String apos = null;
	Variable posname = new Variable("posx");
	Constant givenPos = null;
	Variable startPos = null;
	Variable pieceName = new Variable("byPiece");
	List<Term> othervariables = new ArrayList<Term>();
	List<Term> totalvariables = new ArrayList<Term>();
	List<Term> boardTerms = new ArrayList<Term>();
	othervariables.add(pieceName);
	totalvariables.add(pieceName);
	if (nargs > 0) {
		apos = names[0];
		givenPos = new Constant(apos);
		othervariables.add(givenPos);
		totalvariables.add(givenPos);
		boardTerms.add(givenPos);
	}
	if (nargs == 0) {
		startPos = new Variable("posy");
		othervariables.add(startPos);
		totalvariables.add(startPos);
		boardTerms.add(startPos);
	}
	List<Literal> precondition = new ArrayList();
	List<Literal> effects = new ArrayList();
	Variable typeofPiece = new Variable("type");
	List<Term> variables = new ArrayList<Term>();

	List<Term> typevariables = new ArrayList<Term>();


	variables.add(pieceName);
	variables.add(posname);
	

	typevariables.add(pieceName);
	typevariables.add(typeofPiece);

	String actionName = "occupypos";
	//	  totalvariables.addAll(boardTerms);
	
	
	totalvariables.add(typeofPiece);
	totalvariables.add(posname);
	Predicate firstposPredicate = new Predicate(OCCUPIES,othervariables); 
	Predicate reachPredicate = new Predicate(REACHABLE,variables);
	Predicate typePredicate = new Predicate(PIECETYPE,typevariables);
	Predicate boardPredicate = new Predicate(BOARD,boardTerms);
	precondition.add(new Literal((AtomicSentence)firstposPredicate));
	precondition.add(new Literal((AtomicSentence) boardPredicate));
	precondition.add(new Literal((AtomicSentence) typePredicate));
	precondition.add(new Literal((AtomicSentence) reachPredicate));
	Predicate occupyPredicate = new Predicate(OCCUPIES,variables); 
	effects.add(new Literal((AtomicSentence) occupyPredicate));
	ActionSchema occupyAction = new ActionSchema(actionName,totalvariables,precondition,effects);
	return occupyAction;
!!!2172674.java!!!	findApplicable(inout initStates : Map<String,State>, inout action : ActionSchema) : ActionSchema
	  List<State> allStates = new ArrayList<State>(initStates.values());
	  List<Constant> stateconstants = new ArrayList<Constant>();
	  List<Constant> tempconstants = new ArrayList<Constant>();
	  allconstants.clear();
	  List<ActionSchema> actions = new ArrayList<ActionSchema>();
	  for (State state:allStates) {
		  List<Literal> literals = state.getFluents(); // The initial states have only ground atoms
		  for (Literal lit:literals) {
			  Predicate p = (Predicate) lit.getAtomicSentence();
			  List<Term> terms = p.getTerms(); 
			  for (Term t:terms) {
				  Constant c = (Constant)t;
				  if (!stateconstants.contains(t)) {
					  stateconstants.add(c);
					  allconstants.add(c);
				  }
				  
			  }
		  }
		  ActionSchema propAction = null;
		  int nofVar = action.getVariables().size();
		  int noC = stateconstants.size(); // This value changes when elements are removed
//		  List<Term> vars = action.getVariables();
/*		  tempconstants.add(stateconstants.get(0));
		  for (int i = 1;i<nofVar;i++) {
			  tempconstants.add(stateconstants.get(i));
		  }*/
		  int diff = noC-nofVar;
		  for (int i = 0;i<diff;i++) {
			  makeProp(action, stateconstants, state, actions);
			  stateconstants.remove(nofVar-1);
		  }
	
		  stateconstants.clear();
	  }
	  return actions;

	  
!!!2172802.java!!!	makeProp(inout action : ActionSchema, inout stateconstants : List<Constant>, inout state : State, inout actions : List<ActionSchema>) : void
		  ActionSchema propAction = null;
//		  if(noC >= nofVar) {
			  propAction = action.getActionBySubstitution(stateconstants); // a propostionalized action schema
			  boolean found = state.getFluents().containsAll(propAction.getPrecondition());//is applicable in state s if the precondition of the action is satisfied by s.
			  boolean finnes = false;
/*			  if (!actions.isEmpty()) {
				  for (ActionSchema schema:actions) {
					  finnes = schema.getPrecondition().containsAll(propAction.getPrecondition());
					  if (finnes)
						  break;
				  }
			  }*/
			  if (found && !finnes) {
				  actions.add(propAction);
			  }
//		  }
/*		  else {
			  actions.add(action);
		  }*/
!!!2172930.java!!!	extract(in s : String, inout f : Function<String,String>) : String
	  return f.apply(s);
!!!2173058.java!!!	extractString(in line : String, in separator : char, in startindex : int) : String
	  int index = line.lastIndexOf(separator);
	  if (index == -1)
		  return null;
	  Function<String,String> f = (String s) -> line.substring(startindex,index);
	  Function<String,String> ef = (String s) -> line.substring(index+1);
	  if (startindex == -1)
		  return extract(line,ef);
	  else
		  return extract(line,f);

