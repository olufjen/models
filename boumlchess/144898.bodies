class PLParser
!!!374914.java!!!	getLexer() : Lexer
		return lexer;
!!!375042.java!!!	parse() : Sentence
		Sentence result = null;

		ParseNode root = parseSentence(0);
		if (root != null && root.node instanceof Sentence) {
			result = (Sentence) root.node;
		}

		return result;
!!!375170.java!!!	parseSentence(in level : int) : PLParser::ParseNode
		List<ParseNode> levelParseNodes = parseLevel(level);

		ParseNode result = null;

		// Now group up the tokens based on precedence order from highest to
		// lowest.
		levelParseNodes = groupSimplerSentencesByConnective(Connective.NOT,
				levelParseNodes);
		levelParseNodes = groupSimplerSentencesByConnective(Connective.AND,
				levelParseNodes);
		levelParseNodes = groupSimplerSentencesByConnective(Connective.OR,
				levelParseNodes);
		levelParseNodes = groupSimplerSentencesByConnective(
				Connective.IMPLICATION, levelParseNodes);
		levelParseNodes = groupSimplerSentencesByConnective(
				Connective.BICONDITIONAL, levelParseNodes);

		// At this point there should just be the root formula
		// for this level.
		if (levelParseNodes.size() == 1
				&& levelParseNodes.get(0).node instanceof Sentence) {
			result = levelParseNodes.get(0);
		} else {
			// Did not identify a root sentence for this level,
			// therefore throw an exception indicating the problem.
			throw new ParserException("Unable to correctly parse sentence: "
					+ levelParseNodes, getTokens(levelParseNodes));
		}

		return result;
!!!375298.java!!!	groupSimplerSentencesByConnective(inout connectiveToConstruct : Connective, inout parseNodes : List<ParseNode>) : PLParser::ParseNode
		List<ParseNode> newParseNodes = new ArrayList<ParseNode>();
		int numSentencesMade = 0;
		// Go right to left in order to make right associative,
		// which is a natural default for propositional logic
		for (int i = parseNodes.size() - 1; i >= 0; i--) {
			ParseNode parseNode = parseNodes.get(i);
			if (parseNode.node instanceof Connective) {
				Connective tokenConnective = (Connective) parseNode.node;
				if (tokenConnective == Connective.NOT) {
					// A unary connective
					if (i + 1 < parseNodes.size()
							&& parseNodes.get(i + 1).node instanceof Sentence) {
						if (tokenConnective == connectiveToConstruct) {
							ComplexSentence newSentence = new ComplexSentence(
									connectiveToConstruct,
									(Sentence) parseNodes.get(i + 1).node);
							parseNodes.set(i, new ParseNode(newSentence,
									parseNode.token));
							parseNodes.set(i + 1, null);
							numSentencesMade++;
						}
					} else {
						throw new ParserException(
								"Unary connective argurment is not a sentence at input position "
										+ parseNode.token
												.getStartCharPositionInInput(),
								parseNode.token);
					}
				} else {
					// A Binary connective
					if ((i - 1 >= 0 && parseNodes.get(i - 1).node instanceof Sentence)
							&& (i + 1 < parseNodes.size() && parseNodes
									.get(i + 1).node instanceof Sentence)) {
						// A binary connective
						if (tokenConnective == connectiveToConstruct) {
							ComplexSentence newSentence = new ComplexSentence(
									connectiveToConstruct,
									(Sentence) parseNodes.get(i - 1).node,
									(Sentence) parseNodes.get(i + 1).node);
							parseNodes.set(i - 1, new ParseNode(newSentence,
									parseNode.token));
							parseNodes.set(i, null);
							parseNodes.set(i + 1, null);
							numSentencesMade++;
						}
					} else {
						throw new ParserException(
								"Binary connective argurments are not sentences at input position "
										+ parseNode.token
												.getStartCharPositionInInput(),
								parseNode.token);
					}
				}
			}
		}

		for (int i = 0; i < parseNodes.size(); i++) {
			ParseNode parseNode = parseNodes.get(i);
			if (parseNode != null) {
				newParseNodes.add(parseNode);
			}
		}

		// Ensure no tokens left unaccounted for in this pass.
		int toSubtract = 0;
		if (connectiveToConstruct == Connective.NOT) {
			toSubtract = (numSentencesMade * 2) - numSentencesMade;
		} else {
			toSubtract = (numSentencesMade * 3) - numSentencesMade;
		}

		if (parseNodes.size() - toSubtract != newParseNodes.size()) {
			throw new ParserException(
					"Unable to construct sentence for connective: "
							+ connectiveToConstruct + " from: " + parseNodes,
					getTokens(parseNodes));
		}

		return newParseNodes;
!!!375426.java!!!	parseLevel(in level : int) : PLParser::ParseNode
		List<ParseNode> tokens = new ArrayList<ParseNode>();
		while (lookAhead(1).getType() != LogicTokenTypes.EOI
				&& lookAhead(1).getType() != LogicTokenTypes.RPAREN
				&& lookAhead(1).getType() != LogicTokenTypes.RSQRBRACKET) {
			if (detectConnective()) {
				tokens.add(parseConnective());
			} else if (detectAtomicSentence()) {
				tokens.add(parseAtomicSentence());
			} else if (detectBracket()) {
				tokens.add(parseBracketedSentence(level));
			}
		}

		if (level > 0 && lookAhead(1).getType() == LogicTokenTypes.EOI) {
			throw new ParserException(
					"Parser Error: end of input not expected at level " + level,
					lookAhead(1));
		}

		return tokens;
!!!375554.java!!!	detectConnective() : boolean
		return lookAhead(1).getType() == LogicTokenTypes.CONNECTIVE;
!!!375682.java!!!	parseConnective() : PLParser::ParseNode
		Token token = lookAhead(1);
		Connective connective = Connective.get(token.getText());
		consume();
		return new ParseNode(connective, token);
!!!375810.java!!!	detectAtomicSentence() : boolean
		int type = lookAhead(1).getType();
		return type == LogicTokenTypes.TRUE || type == LogicTokenTypes.FALSE
				|| type == LogicTokenTypes.SYMBOL;
!!!375938.java!!!	parseAtomicSentence() : PLParser::ParseNode
		Token t = lookAhead(1);
		if (t.getType() == LogicTokenTypes.TRUE) {
			return parseTrue();
		} else if (t.getType() == LogicTokenTypes.FALSE) {
			return parseFalse();
		} else if (t.getType() == LogicTokenTypes.SYMBOL) {
			return parseSymbol();
		} else {
			throw new ParserException(
					"Error parsing atomic sentence at position "
							+ t.getStartCharPositionInInput(), t);
		}
!!!376066.java!!!	parseTrue() : PLParser::ParseNode
		Token token = lookAhead(1);
		consume();
		return new ParseNode(new PropositionSymbol(PropositionSymbol.TRUE_SYMBOL),
				token);
!!!376194.java!!!	parseFalse() : PLParser::ParseNode
		Token token = lookAhead(1);
		consume();
		return new ParseNode(new PropositionSymbol(PropositionSymbol.FALSE_SYMBOL),
				token);
!!!376322.java!!!	parseSymbol() : PLParser::ParseNode
		Token token = lookAhead(1);
		String sym = token.getText();
		consume();
		return new ParseNode(new PropositionSymbol(sym), token);
!!!376450.java!!!	detectBracket() : boolean
		return lookAhead(1).getType() == LogicTokenTypes.LPAREN
				|| lookAhead(1).getType() == LogicTokenTypes.LSQRBRACKET;
!!!376578.java!!!	parseBracketedSentence(in level : int) : PLParser::ParseNode
		Token startToken = lookAhead(1);

		String start = "(";
		String end = ")";
		if (startToken.getType() == LogicTokenTypes.LSQRBRACKET) {
			start = "[";
			end = "]";
		}

		match(start);
		ParseNode bracketedSentence = parseSentence(level + 1);
		match(end);

		return bracketedSentence;
!!!376706.java!!!	getTokens(inout parseNodes : List<ParseNode>) : Token
		Token[] result = new Token[parseNodes.size()];

		for (int i = 0; i < parseNodes.size(); i++) {
			result[i] = parseNodes.get(i).token;
		}

		return result;
