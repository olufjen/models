class KnowledgeBuilder
!!!2298626.java!!!	getKingCastleKey() : String
	return kingCastleKey;
!!!2298754.java!!!	setKingCastleKey(in kingCastleKey : String) : void
	KnowledgeBuilder.kingCastleKey = kingCastleKey;
!!!2178050.java!!!	getPIECE() : String
	return PIECE;
!!!2178178.java!!!	setPIECE(in pIECE : String) : void
	  PIECE = pIECE;
!!!1835522.java!!!	getOPPONENTTO() : String
	return OPPONENTTO;
!!!2087298.java!!!	getPOSSIBLEPROTECT() : String
	return POSSIBLEPROTECT;
!!!2087426.java!!!	setPOSSIBLEPROTECT(in pOSSIBLEPROTECT : String) : void
	POSSIBLEPROTECT = pOSSIBLEPROTECT;
!!!2087554.java!!!	getPOSSIBLEREACH() : String
	return POSSIBLEREACH;
!!!2087682.java!!!	setPOSSIBLEREACH(in pOSSIBLEREACH : String) : void
	POSSIBLEREACH = pOSSIBLEREACH;
!!!1835650.java!!!	setOPPONENTTO(in oPPONENTTO : String) : void
	OPPONENTTO = oPPONENTTO;
!!!1835778.java!!!	getPOSSIBLETHREAT() : String
	return POSSIBLETHREAT;
!!!1835906.java!!!	setPOSSIBLETHREAT(in pOSSIBLETHREAT : String) : void
	POSSIBLETHREAT = pOSSIBLETHREAT;
!!!1798274.java!!!	getCASTLE() : String
	return CASTLE;
!!!1798402.java!!!	setCASTLE(in cASTLE : String) : void
	CASTLE = cASTLE;
!!!1781250.java!!!	getBOARD() : String
	return BOARD;
!!!1781378.java!!!	setBOARD(in bOARD : String) : void
	BOARD = bOARD;
!!!1781506.java!!!	getPLAYER() : String
	return PLAYER;
!!!1781634.java!!!	setPLAYER(in pLAYER : String) : void
	PLAYER = pLAYER;
!!!1781762.java!!!	getPAWNATTACK() : String
	return PAWNATTACK;
!!!1781890.java!!!	setPAWNATTACK(in pAWNATTACK : String) : void
	PAWNATTACK = pAWNATTACK;
!!!1782018.java!!!	getOCCUPIES() : String
	return OCCUPIES;
!!!1782146.java!!!	setOCCUPIES(in oCCUPIES : String) : void
	OCCUPIES = oCCUPIES;
!!!1782274.java!!!	getPLAY() : String
		return PLAY;
!!!1782402.java!!!	setPLAY(in pLAY : String) : void
		PLAY = pLAY;
!!!1782530.java!!!	getPAWN() : String
		return PAWN;
!!!1782658.java!!!	setPAWN(in pAWN : String) : void
		PAWN = pAWN;
!!!1782786.java!!!	getKNIGHT() : String
		return KNIGHT;
!!!1782914.java!!!	setKNIGHT(in kNIGHT : String) : void
		KNIGHT = kNIGHT;
!!!1783042.java!!!	getBISHOP() : String
		return BISHOP;
!!!1783170.java!!!	setBISHOP(in bISHOP : String) : void
		BISHOP = bISHOP;
!!!1783298.java!!!	getROOK() : String
		return ROOK;
!!!1783426.java!!!	setROOK(in rOOK : String) : void
		ROOK = rOOK;
!!!1783554.java!!!	getKING() : String
		return KING;
!!!1783682.java!!!	setKING(in kING : String) : void
		KING = kING;
!!!1783810.java!!!	getQUEEN() : String
		return QUEEN;
!!!1783938.java!!!	setQUEEN(in qUEEN : String) : void
		QUEEN = qUEEN;
!!!1784066.java!!!	getPAWNMOVE() : String
		return PAWNMOVE;
!!!1784194.java!!!	setPAWNMOVE(in pAWNMOVE : String) : void
		PAWNMOVE = pAWNMOVE;
!!!1784322.java!!!	getPIECETYPE() : String
		return PIECETYPE;
!!!1784450.java!!!	setPIECETYPE(in pIECETYPE : String) : void
		PIECETYPE = pIECETYPE;
!!!1784578.java!!!	getACTION() : String
		return ACTION;
!!!1784706.java!!!	setACTION(in aCTION : String) : void
		ACTION = aCTION;
!!!1784834.java!!!	getPROTECTED() : String
		return PROTECTED;
!!!1784962.java!!!	setPROTECTED(in pROTECTED : String) : void
		PROTECTED = pROTECTED;
!!!1785090.java!!!	getSimpleProtected() : String
		return simpleProtected;
!!!1785218.java!!!	setSimpleProtected(in simpleProtected : String) : void
		KnowledgeBuilder.simpleProtected = simpleProtected;
!!!1785346.java!!!	getATTACKED() : String
	  return ATTACKED;
!!!1785474.java!!!	setATTACKED(in aTTACKED : String) : void
		ATTACKED = aTTACKED;
!!!1785602.java!!!	getCAPTURE() : String
		return CAPTURE;
!!!1785730.java!!!	setCAPTURE(in cAPTURE : String) : void
		CAPTURE = cAPTURE;
!!!1785858.java!!!	getCONQUER() : String
		return CONQUER;
!!!1785986.java!!!	setCONQUER(in cONQUER : String) : void
		CONQUER = cONQUER;
!!!1786114.java!!!	getTHREATEN() : String
		return THREATEN;
!!!1786242.java!!!	setTHREATEN(in tHREATEN : String) : void
		THREATEN = tHREATEN;
!!!1786370.java!!!	getOWNER() : String
		return OWNER;
!!!1786498.java!!!	setOWNER(in oWNER : String) : void
		OWNER = oWNER;
!!!1786626.java!!!	getMOVE() : String
		return MOVE;
!!!1786754.java!!!	setMOVE(in mOVE : String) : void
		MOVE = mOVE;
!!!1786882.java!!!	getREACHABLE() : String
		return REACHABLE;
!!!1787010.java!!!	setREACHABLE(in rEACHABLE : String) : void
		REACHABLE = rEACHABLE;
!!!1787138.java!!!	getCANMOVE() : String
		return CANMOVE;
!!!1787266.java!!!	setCANMOVE(in cANMOVE : String) : void
		CANMOVE = cANMOVE;
!!!1787394.java!!!	getSAFEMOVE() : String
		return SAFEMOVE;
!!!1787522.java!!!	setSAFEMOVE(in sAFEMOVE : String) : void
		SAFEMOVE = sAFEMOVE;
!!!1787650.java!!!	getSTRIKE() : String
		return STRIKE;
!!!1787778.java!!!	setSTRIKE(in sTRIKE : String) : void
		STRIKE = sTRIKE;
!!!2178306.java!!!	getOCCUPY() : String
	return OCCUPY;
!!!2178434.java!!!	setOCCUPY(in oCCUPY : String) : void
	OCCUPY = oCCUPY;
!!!2178562.java!!!	getPROTECT() : String
	return PROTECT;
!!!2178690.java!!!	setPROTECT(in pROTECT : String) : void
	PROTECT = pROTECT;
!!!2178818.java!!!	getMAKESTRONG() : String
	return MAKESTRONG;
!!!2178946.java!!!	setMAKESTRONG(in mAKESTRONG : String) : void
	MAKESTRONG = mAKESTRONG;
!!!2179074.java!!!	getAllconstants() : Constant
	return allconstants;
!!!2179202.java!!!	setAllconstants(inout allconstants : List<Constant>) : void
	KnowledgeBuilder.allconstants = allconstants;
!!!1787906.java!!!	getPieceType(inout piece : AgamePiece) : String
	  pieceType type = piece.getPieceType();
	  if (type == type.PAWN) {
		  return PAWN;
	  }
	  if (type == type.BISHOP) {
		  return BISHOP;
	  }		
	  if (type == type.ROOK) {
		  return ROOK;
	  }			
	  if (type == type.KNIGHT) {
		  return KNIGHT;
	  }
	  if (type == type.QUEEN) {
		  return QUEEN;
	  }
	  if (type == type.KING) {
		  return KING;
	  }	
	  return null;
!!!1788034.java!!!	parseSentence(in sentence : String, in goalSentence : String, inout kb : FOLKnowledgeBase) : void
	  List<Literal> rules = Utils.parse(sentence);
	  List<Literal> goals = Utils.parse(goalSentence);
	  ConnectedSentence premise = null;
	  int s = rules.size();
	  for (int i= 0; i < s;i=i+2) {
		  Predicate p = (Predicate) rules.get(i).getAtomicSentence();
		  Predicate y = (Predicate) rules.get(i+1).getAtomicSentence();	
		  premise = new ConnectedSentence(Connectors.AND,p,y);

	  }
	  Predicate g = (Predicate)goals.get(0).getAtomicSentence();
	  ConnectedSentence goal = new ConnectedSentence(Connectors.IMPLIES,premise,g);
	  kb.tell(goal);

!!!2179330.java!!!	createOccupyaction(inout  : String...names) : ActionSchema
	int nargs = names.length;
	int noofKeys = keys.length;
	HashMap cparams = new HashMap<String,Constant>();
	HashMap vparams = new HashMap<String,Variable>();
	FunctionContect contex = new FunctionContect(); // Used to register and run functions
/*	String apos = null;
	Variable posname = new Variable("posx"); // The end position as a variable
	Constant newPos = null; // The end position as a constant
	Constant givenPos = null; // The start position as a Constant
	Variable startPos = null; // The start position as a Variable
	Variable pieceName = null; // The piece name as a variable
	Constant namedPiece = null; //The piece name as a constant 
	Variable typeofPiece = null; // The type of piece as a variable
	Constant givenType = null; // The type of piece as a constant
	*/
	List<Term> othervariables = new ArrayList<Term>(); // The list of Terms for the occupy predicate
	List<Term> totalvariables = new ArrayList<Term>(); // The list of all terms
	List<Term> boardTerms = new ArrayList<Term>(); // The list of terms for the board predicate
	List<Term> variables = new ArrayList<Term>(); // The list of Terms for the reachable predicate and the occupy predicate in the Effect.
	List<Term> typevariables = new ArrayList<Term>();// The list of Terms for the piecetype predicate
	ANewposfunction newPosfunction = new ANewposfunction(variables);
	AStartposfunction startPosfunction = new AStartposfunction(othervariables);
	APiecetypefunction pieceTypefunction = new APiecetypefunction(typevariables);
	ABoardtermFunction boardTermfunction = new ABoardtermFunction(boardTerms);
	ApawnstrikeFunction pawnStrikefunction = new ApawnstrikeFunction(variables);
	contex.register(keys[2], newPosfunction);
	contex.register(keys[1], boardTermfunction);
	contex.register(keys[0], startPosfunction);
	contex.register(keys[3], pieceTypefunction);
	contex.register(keys[4],pawnStrikefunction);
/*	pieceName = new Variable("byPiece");
	typeofPiece = new Variable("type");*/
	String reach = REACHABLE;
	if (nargs > 0) {
		for (int i = 0;i<nargs;i++) {
			AChessExecutor exec = null;
			if (names[i] == null) {
				exec = new AChessExecutor(i); // Creates a Variable Term
				Variable var = (Variable)exec.execute();
				vparams.put(keys[i], var);
			}else {
				exec = new AChessExecutor(names[i]); //Creates a Constant Term
				Object tvar = exec.execute();
				if (tvar instanceof Constant) {
					Constant var = (Constant)tvar;
					cparams.put(keys[i], var);
				}
				if (tvar instanceof String) {
					String tpar = (String)tvar;
					if (tpar.equals("pawn"))
						reach = PAWNATTACK;
					if (tpar.equals("castle"))
						reach = CASTLE;
				}
			}

		}
		for (int i = 0;i<noofKeys;i++) {
			contex.get(keys[i]).buildTerms(cparams, vparams);
		}
//		contex.get(keys[0]).buildTerms(cparams, vparams);
		List<Term> thevariables = newPosfunction.getVariables();
		totalvariables.add(othervariables.get(0));
		totalvariables.add(othervariables.get(1));
		totalvariables.add(typevariables.get(1));
		totalvariables.add(variables.get(1));

	}
	if (nargs == 0) {
		for (int i = 0;i<noofKeys;i++) {
			AChessExecutor exec = new AChessExecutor(i); // Creates a Variable Term
			Variable var = (Variable)exec.execute();
			vparams.put(keys[i], var);
		}
		for (int i = 0;i<noofKeys;i++) {
			contex.get(keys[i]).buildTerms(cparams, vparams);
		}
/*		startPos = new Variable("posy");*/
		totalvariables.add(othervariables.get(0));
		totalvariables.add(othervariables.get(1));
		totalvariables.add(typevariables.get(1));
		totalvariables.add(variables.get(1));

	}
	List<Literal> precondition = new ArrayList();
	List<Literal> effects = new ArrayList();
	String actionName = "occupypos";
	Term type = typevariables.get(1);
	Constant piecetype = null;
/*	boolean pawn = false;
	if (type instanceof Constant) {
		piecetype = (Constant)type;
		String typeName = piecetype.getSymbolicName();
		pawn = typeName == PAWN;
	}*/
	Predicate firstposPredicate = new Predicate(OCCUPIES,othervariables); 
	Predicate reachPredicate = new Predicate(reach,variables);
	Predicate typePredicate = new Predicate(PIECETYPE,typevariables);
	Predicate boardPredicate = new Predicate(BOARD,boardTerms);
	precondition.add(new Literal((AtomicSentence)firstposPredicate));
	precondition.add(new Literal((AtomicSentence) boardPredicate));
	precondition.add(new Literal((AtomicSentence) typePredicate));
	precondition.add(new Literal((AtomicSentence) reachPredicate));
	Predicate occupyPredicate = new Predicate(OCCUPIES,variables); 
	effects.add(new Literal((AtomicSentence) occupyPredicate));
	ActionSchema occupyAction = new ActionSchema(actionName,totalvariables,precondition,effects);
	return occupyAction;
!!!2179458.java!!!	findApplicable(inout initStates : Map<String,State>, inout action : ActionSchema) : ActionSchema
	  List<State> allStates = new ArrayList<State>(initStates.values());
	  List<Constant> stateconstants = new ArrayList<Constant>();
	  List<Constant> tempconstants = new ArrayList<Constant>();
	  allconstants.clear();
	  List<ActionSchema> actions = new ArrayList<ActionSchema>();
	  for (State state:allStates) {
		  List<Literal> literals = state.getFluents(); // The initial states have only ground atoms
		  for (Literal lit:literals) {
			  Predicate p = (Predicate) lit.getAtomicSentence();
			  List<Term> terms = p.getTerms(); 
			  for (Term t:terms) {
				  Constant c = (Constant)t;
				  if (!stateconstants.contains(t)) {
					  stateconstants.add(c);
					  allconstants.add(c);
				  }
				  
			  }
		  }
		  ActionSchema propAction = null;
		  int nofVar = action.getVariables().size();
		  int noC = stateconstants.size(); // This value changes when elements are removed
//		  List<Term> vars = action.getVariables();
/*		  tempconstants.add(stateconstants.get(0));
		  for (int i = 1;i<nofVar;i++) {
			  tempconstants.add(stateconstants.get(i));
		  }*/
		  int diff = noC-nofVar;
		  for (int i = 0;i<diff;i++) {
			  makeProp(action, stateconstants, state, actions);
			  stateconstants.remove(nofVar-1);
		  }
		  stateconstants.clear();
	  }
	  return actions;

	  
!!!2179586.java!!!	makeProp(inout action : ActionSchema, inout stateconstants : List<Constant>, inout state : State, inout actions : List<ActionSchema>) : void
		ActionSchema propAction = null;
		propAction = action.getActionBySubstitution(stateconstants); // a propositionalized action schema
		boolean found = state.getFluents().containsAll(propAction.getPrecondition());//is applicable in state s if the precondition of the action is satisfied by s.
		boolean finnes = false;
		if (!actions.isEmpty()) {
			for (ActionSchema schema:actions) {
				finnes = schema.getPrecondition().containsAll(propAction.getPrecondition());
				if (finnes)
					break;
			}
		}
		if (found && !finnes) {
		
			actions.add(propAction);
		}
!!!2179714.java!!!	extract(in s : String, inout f : Function<String,String>) : String
	  return f.apply(s);
!!!2179842.java!!!	extractString(in line : String, in separator : char, in startindex : int) : String
	  int index = line.lastIndexOf(separator);
	  if (index == -1)
		  return null;
	  Function<String,String> f = (String s) -> line.substring(startindex,index); // The implementation of the apply method of Function
	  Function<String,String> ef = (String s) -> line.substring(index+1);
//	  Function<String,String> xef = String::substring(index+1);
	  if (startindex == -1)
		  return extract(line,ef);
	  else
		  return extract(line,f);

!!!2285058.java!!!	toDouble() : Node
	  ToDoubleFunction<Node<PlannerState, ChessPlannerAction>> h = node -> node.getPathCost();
	  return h;
!!!2285186.java!!!	aResultFunction() : ResultFunction
	  ResultFunction<PlannerState, ChessPlannerAction> r = (s,a) -> a.findPlannerState(s);
	  return r;
!!!2285314.java!!!	anActionFunction() : ActionsFunction
	  ActionsFunction<PlannerState, ChessPlannerAction> a = s -> s.getActions();
	  return a;
!!!2285442.java!!!	stepCost() : StepCostFunction
	  StepCostFunction<PlannerState, ChessPlannerAction> step = new ChessStepCostImpl();
	  return step;
!!!2285570.java!!!	aGoaltest(inout a : ChessPlannerAction) : ChessGoalTest
	  ChessGoalTest<PlannerState>  g = s -> s.testEnd(a);
	  return g;
