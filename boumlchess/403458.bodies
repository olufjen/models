class ChessFolKnowledgeBase
!!!1958402.java!!!	ChessFolKnowledgeBase(inout domain : ChessDomain, inout inferenceProcedure : InferenceProcedure)
		super(domain, inferenceProcedure);
		String catalog = KnowledgeBuilder.getFileCatalog();
		fileName = "tempknowledgebase.txt";
		outputFileName = catalog+outputFileName+this.fileName;
		movePieces = new ArrayList<AgamePiece>();
		try {
			fw = new FileWriter(outputFileName, true);
		} catch (IOException e1) {

			e1.printStackTrace();
		}
	    writer = new PrintWriter(new BufferedWriter(fw));	
	    setPieceTypes();
	 
!!!1965954.java!!!	ChessFolKnowledgeBase(inout domain : ChessDomain, inout inferenceProcedure : InferenceProcedure, in fileName : String)
		super(domain, inferenceProcedure);
		String catalog = KnowledgeBuilder.getFileCatalog();
		this.fileName = fileName;
		outputFileName = catalog+outputFileName+this.fileName;
		try {
			fw = new FileWriter(outputFileName, true);
		} catch (IOException e1) {

			e1.printStackTrace();
		}
	    writer = new PrintWriter(new BufferedWriter(fw));
		movePieces = new ArrayList<AgamePiece>();
	    setPieceTypes();
!!!1991682.java!!!	setPieceTypes() : void
		PAWN = KnowledgeBuilder.getPAWN();
		KNIGHT = KnowledgeBuilder.getKNIGHT();
		BISHOP = KnowledgeBuilder.getBISHOP();
		ROOK = KnowledgeBuilder.getROOK();
		KING = KnowledgeBuilder.getKING();
		QUEEN = KnowledgeBuilder.getQUEEN();
		pieceTypes = new ArrayList<String>();
		pieceTypes.add(PAWN);
		pieceTypes.add(BISHOP);
		pieceTypes.add(KNIGHT);
		pieceTypes.add(ROOK);
		pieceTypes.add(KING);
		pieceTypes.add(QUEEN);
!!!2047106.java!!!	getMovePieces() : AgamePiece
		return movePieces;
!!!2047234.java!!!	setMovePieces(inout movePieces : List<AgamePiece>) : void
		this.movePieces = movePieces;
!!!1966082.java!!!	getFileName() : String
		return fileName;
!!!1966210.java!!!	setFileName(in fileName : String) : void
		this.fileName = fileName;
!!!1966338.java!!!	getBackWardChain() : FOLGamesBCAsk
		return backWardChain;
!!!1966466.java!!!	setBackWardChain(inout backWardChain : FOLGamesBCAsk) : void
		this.backWardChain = backWardChain;
!!!1991810.java!!!	checkPieceType(in name : String) : String
		String foundType = null;
		Constant pieceVariable= new Constant(name);
		List<Term> typeTerms = new ArrayList<Term>();
		for (String type:pieceTypes) {
			Predicate typePredicate = new Predicate(type,typeTerms);
			InferenceResult backWardresult =  backWardChain.ask(this, typePredicate);
			if (backWardresult.isTrue()) {
				foundType = type;
				return foundType;
			}
		}
		return foundType;
!!!1975426.java!!!	checkmyProtection(in pieceName : String, in pos : String, in predName : String, inout myPlayer : APlayer) : boolean
	  List<AgamePiece> myPieces = myPlayer.getMygamePieces();
	  boolean protectedpiece = false;
	  for (AgamePiece piece:myPieces) {
		  String name = piece.getMyPiece().getOntlogyName();
		  if (!name.equals(pieceName)) {
				Constant pieceVariable= new Constant(name);
				Constant posVariable = new Constant(pos);
				List<Term> reachableTerms = new ArrayList<Term>();
				reachableTerms.add(pieceVariable);
				reachableTerms.add(posVariable);
				Predicate reachablePredicate = new Predicate(predName,reachableTerms);
				InferenceResult backWardresult =  backWardChain.ask(this, reachablePredicate);
				protectedpiece = backWardresult.isTrue();
				if (protectedpiece)
					return protectedpiece;
		  }
	  }
	return protectedpiece;
!!!1966594.java!!!	checkThreats(in pieceName : String, in pos : String, in fact : String, inout opponent : APlayer) : boolean
		  movePieces.clear();	
		  List<AgamePiece> pieces = opponent.getMygamePieces();
		  AgamePiece piece = pieces.stream().filter(c -> c.getMyPiece().getOntlogyName().equals(pieceName)).findAny().orElse(null);
		  Constant pieceVariable = null;
		  Variable pieceVar = null;
		  boolean result = false;
		  boolean tempResult = false;
		  List<Term> reachableTerms = new ArrayList<Term>();
		  if (piece != null && piece.isActive()) {
			  pieceVariable = new Constant(pieceName);
			  reachableTerms.add(pieceVariable);
			  tempResult = pos.equals(piece.getMyPosition().getPositionName()) && fact.equals("occupies"); // OBS OJN 29.07.24
		  }else if(piece == null) {
			  pieceVar = new Variable(pieceName);
			  reachableTerms.add(pieceVar);
		  }
		  Constant posVariable = new Constant(pos);
		  reachableTerms.add(posVariable);
		  Predicate threatPredicate = new Predicate(fact,reachableTerms);
//		  writer.println("Trying to prove\n"+threatPredicate.toString());
		  InferenceResult backWardresult =  backWardChain.ask(this,threatPredicate);
		  boolean backresult = backWardresult.isTrue();
		
//		  writer.println(InferenceResultPrinter.printInferenceResult(backWardresult));
/*
 * Added 28.5.22:
 */
		  List<String> termNames = new ArrayList<String>();
		  BCGamesAskHandler handler = (BCGamesAskHandler)backWardresult;
		  List<HashMap<Variable, Term>> finals = handler.getFinalList();
		  int noofFinals = finals.size();
		  HashMap vars = null;
		  Term usedTerm = null;
		  String termName = null;
		  if (finals != null && !finals.isEmpty() && pieceVar != null) {
			  for (int i = 0;i<noofFinals;i++) {
				  vars = finals.get(i);
				  usedTerm = (Term) vars.get(pieceVar);
				  termName = usedTerm.getSymbolicName(); // Finds which piece(s) is protecting/threatening this position.
				  termNames.add(termName);
			  }
			  for (String name:termNames) {
				  AgamePiece opponentpiece = pieces.stream().filter(c -> c.getMyPiece().getOntlogyName().equals(name)).findAny().orElse(null);
				  if (opponentpiece != null && opponentpiece.isActive()) {
					  movePieces.add(opponentpiece);
					  result = true;
				  }
			  }
		  }
		  if (!result && backresult) {
			  result = backresult;
			  writer.println("This predicate has no answer "+ backresult);
			  writer.println(threatPredicate.toString());
/*			  if (tempResult) {
				  writeKnowledgebase();
			  }*/

		  }
		  return result;
		  
!!!1975554.java!!!	checkpieceFacts(in pieceVar : String, in pieceName : String, in pos : String, in fact : String) : boolean
			Variable pieceVarx = null;
			if (pieceVar.equals("x"))
				pieceVarx = new Variable(pieceVar);
			Constant pieceVariable= new Constant(pieceName);
			Constant posVariable = new Constant(pos);
			List<Term> reachableTerms = new ArrayList<Term>();
			if (pieceVarx != null) {
				reachableTerms.add(pieceVarx);
			}else
				reachableTerms.add(pieceVariable);
			reachableTerms.add(posVariable);
			Predicate reachablePredicate = new Predicate(fact,reachableTerms);
//			writer.println("PieceFacts Trying to prove\n"+reachablePredicate.toString());
			InferenceResult backWardresult =  backWardChain.ask(this, reachablePredicate);
			BCGamesAskHandler handler = (BCGamesAskHandler)backWardresult;
			HashMap vars = null;
			Term usedTerm = null;
			String termName = null;
			boolean properProtection = false;
			List<HashMap<Variable, Term>> finals = handler.getFinalList();
			if (finals != null && !finals.isEmpty() && pieceVarx != null) {
				vars = finals.get(0);
				usedTerm = (Term) vars.get(pieceVarx);
				termName = usedTerm.getSymbolicName(); // Finds which piece is protecting this position. This is only true if fact is PROTECTEDBY
				properProtection = !termName.equals(pieceName);
//				writer.println("PieceFacts: position "+pos+" protected by "+termName+" and reachable by "+pieceName);
				return properProtection;
			}
			return backWardresult.isTrue();

!!!1975682.java!!!	checkFacts(in pieceName : String, in pos : String, in fact : String, inout actions : List<ChessActionImpl>, inout positionList : List<Position>) : boolean
			Constant pieceVariable= new Constant(pieceName);
			Constant posVariable = new Constant(pos);
			List<Term> reachableTerms = new ArrayList<Term>();
			reachableTerms.add(pieceVariable);
			reachableTerms.add(posVariable);
			Predicate reachablePredicate = new Predicate(fact,reachableTerms);
			InferenceResult backWardresult =  backWardChain.ask(this, reachablePredicate);
		    ChessActionImpl naction =  (ChessActionImpl) actions.stream().filter(c -> c.getActionName().contains(pieceName)).findAny().orElse(null);
		    Position position =  (Position) positionList.stream().filter(c -> c.getPositionName().contains(pos)).findAny().orElse(null);
			if (backWardresult.isTrue() && naction != null) {
				if (naction.getPossibleMove() == null) {
					writer.println("Action "+naction.toString()+ " has no move");
					return false;
				}
				naction.getPossibleMove().setToPosition(position);
				naction.setPreferredPosition(position);
				return true;
			}
			return false;
!!!2001410.java!!!	searchFacts(in pieceName : String, in posName : String, in fact : String) : List<String>
		Variable pieceVarx = null;
		Constant pieceVariable = null;
		List<String> termNames = new ArrayList<String>();
		List<Term> reachableTerms = new ArrayList<Term>();
		if (pieceName.equals("x")) {
			pieceVarx = new Variable(pieceName);
			reachableTerms.add(pieceVarx);
		}else {
			pieceVariable = new Constant(pieceName);
			reachableTerms.add(pieceVariable);
		}
		Constant posVariable = new Constant(posName);
		reachableTerms.add(posVariable);
		Predicate reachablePredicate = new Predicate(fact,reachableTerms);
//		writer.println("PieceFacts Trying to prove\n"+reachablePredicate.toString());
		InferenceResult backWardresult =  backWardChain.ask(this, reachablePredicate);
		BCGamesAskHandler handler = (BCGamesAskHandler)backWardresult;
		HashMap vars = null;
		Term usedTerm = null;
		String termName = null;
		List<HashMap<Variable, Term>> finals = handler.getFinalList();
		int noofFinals = finals.size();
		if (finals != null && !finals.isEmpty() && pieceVarx != null) {
			for (int i = 0;i<noofFinals;i++) {
				vars = finals.get(i);
				usedTerm = (Term) vars.get(pieceVarx);
				termName = usedTerm.getSymbolicName(); // Finds which piece is protecting this position.
				termNames.add(termName);
			}
		}
		return termNames;
!!!1958530.java!!!	createfacts(in fact : String, in pos : String, in piece : String) : void
		Constant pieceVariable= new Constant(piece);
		Constant posVariable = new Constant(pos);
		List<Term> reachableTerms = new ArrayList<Term>();
		reachableTerms.add(pieceVariable);
		reachableTerms.add(posVariable);
		Predicate factPredicate = new Predicate(fact,reachableTerms);
		tell(factPredicate);
		
!!!1958658.java!!!	writeKnowledgebase() : void
		writer.println("The first order knowledge base");
		writer.println(this.toString());
		writer.flush();
		
!!!2029186.java!!!	findFacts(in name : String, in fact : String) : List<String>
		Constant nameConstant = new Constant(name);
		Variable nameVar = new Variable("x");
		List<Term> reachableTerms = new ArrayList<Term>();
		List<String> termNames = new ArrayList<String>();
		reachableTerms.add(nameVar);
		reachableTerms.add(nameConstant);
		Predicate factPredicate = new Predicate(fact,reachableTerms);
		InferenceResult backWardresult =  backWardChain.ask(this, factPredicate);
		BCGamesAskHandler handler = (BCGamesAskHandler)backWardresult;
		HashMap vars = null;
		Term usedTerm = null;
		String termName = null;
		List<HashMap<Variable, Term>> finals = handler.getFinalList();
		int noofFinals = finals.size();
		if (finals != null && !finals.isEmpty() && nameConstant != null) {
			for (int i = 0;i<noofFinals;i++) {
				vars = finals.get(i);
				usedTerm = (Term) vars.get(nameVar);
				termName = usedTerm.getSymbolicName(); // Finds which name of piece
				termNames.add(termName);
			}
		}
		return termNames;
!!!2029314.java!!!	checkPosition(in name : String, in fact : String) : String
		Constant pieceVariable= new Constant(name);
		Variable posVar = new Variable("x");
		List<Term> reachableTerms = new ArrayList<Term>();
		reachableTerms.add(pieceVariable);
		reachableTerms.add(posVar);
		Predicate factPredicate = new Predicate(fact,reachableTerms);
		InferenceResult backWardresult =  backWardChain.ask(this, factPredicate);
		BCGamesAskHandler handler = (BCGamesAskHandler)backWardresult;
		HashMap vars = null;
		Term usedTerm = null;
		String termName = null;
		List<HashMap<Variable, Term>> finals = handler.getFinalList();
		int noofFinals = finals.size();
		if (finals != null && !finals.isEmpty() && pieceVariable != null) {
			for (int i = 0;i<noofFinals;i++) {
				vars = finals.get(i);
				usedTerm = (Term) vars.get(posVar);
				termName = usedTerm.getSymbolicName(); // Finds which position this is used.
//				termNames.add(termName);
			}
		}
		return termName;
!!!2047362.java!!!	searchKing(in namePredicate : String, in kingPos : String) : List<String>
		Constant kingPosition = new Constant(kingPos);
		Variable posVar = new Variable("x");
		List<String> termNames = new ArrayList<String>();
		List<Term> reachableTerms = new ArrayList<Term>();
		reachableTerms.add(posVar);
		reachableTerms.add(kingPosition);
		Predicate factPredicate = new Predicate(namePredicate,reachableTerms);
		InferenceResult backWardresult =  backWardChain.ask(this, factPredicate);
		BCGamesAskHandler handler = (BCGamesAskHandler)backWardresult;
		HashMap vars = null;
		Term usedTerm = null;
		String termName = null;
		List<HashMap<Variable, Term>> finals = handler.getFinalList();
		int noofFinals = finals.size();
		if (finals != null && !finals.isEmpty() && kingPosition != null) {
			for (int i = 0;i<noofFinals;i++) {
				vars = finals.get(i);
				usedTerm = (Term) vars.get(posVar);
				termName = usedTerm.getSymbolicName(); // Finds which position this is used.
				termNames.add(termName);
			}
		}
		return termNames;
