class AgamePiece
!!!752258.java!!!	AgamePiece(inout myPosition : Position)
		super();
		this.myPosition = myPosition;
		
!!!752386.java!!!	AgamePiece(inout myPosition : Position, inout myPiece : ChessPiece)
		super();
		this.myPosition = myPosition;
		this.myPiece = myPiece;
		heldPositions = new Stack();
		moveNumbers = new ArrayList<Integer>();
		myMoves = new ArrayList<ApieceMove>();
		predicates = new ArrayList<String>();
		northEast = new ArrayList<XYLocation>();
		northWest = new ArrayList<XYLocation>();
		southEast = new ArrayList<XYLocation>();
		southWest = new ArrayList<XYLocation>();
		north = new ArrayList<XYLocation>();
		south = new ArrayList<XYLocation>();
		east = new ArrayList<XYLocation>();
		west = new ArrayList<XYLocation>();
//		determinePieceType(); Moved to setOntologyPositions: Then new available positions are replaced by ontology positions
!!!752514.java!!!	AgamePiece()
		super();
		
!!!2069506.java!!!	getMyMoves() : ApieceMove
		return myMoves;
!!!2069634.java!!!	setMyMoves(inout myMoves : List<ApieceMove>) : void
		this.myMoves = myMoves;
!!!2046210.java!!!	getNameType() : String
		return nameType;
!!!2046338.java!!!	setNameType(in nameType : String) : void
		this.nameType = nameType;
!!!1988866.java!!!	getSouth() : XYLocation
		return south;
!!!1988994.java!!!	setSouth(inout south : List<XYLocation>) : void
		this.south = south;
!!!1989122.java!!!	getNorth() : XYLocation
		return north;
!!!1989250.java!!!	setNorth(inout north : List<XYLocation>) : void
		this.north = north;
!!!1989378.java!!!	getEast() : XYLocation
		return east;
!!!1989506.java!!!	setEast(inout east : List<XYLocation>) : void
		this.east = east;
!!!1989634.java!!!	getWest() : XYLocation
		return west;
!!!1989762.java!!!	setWest(inout west : List<XYLocation>) : void
		this.west = west;
!!!1833474.java!!!	getNorthWest() : XYLocation
		return northWest;
!!!1833602.java!!!	setNorthWest(inout northWest : List<XYLocation>) : void
		this.northWest = northWest;
!!!1833730.java!!!	getNorthEast() : XYLocation
		return northEast;
!!!1833858.java!!!	setNorthEast(inout northEast : List<XYLocation>) : void
		this.northEast = northEast;
!!!1833986.java!!!	getSouthWest() : XYLocation
		return southWest;
!!!1834114.java!!!	setSouthWest(inout southWest : List<XYLocation>) : void
		this.southWest = southWest;
!!!1834242.java!!!	getSouthEast() : XYLocation
		return southEast;
!!!1834370.java!!!	setSouthEast(inout southEast : List<XYLocation>) : void
		this.southEast = southEast;
!!!1834498.java!!!	getBishopRemoved() : Position
		return bishopRemoved;
!!!1834626.java!!!	setBishopRemoved(inout bishopRemoved : List<Position>) : void
		this.bishopRemoved = bishopRemoved;
!!!1796226.java!!!	isCastlingMove() : boolean
		return castlingMove;
!!!1796354.java!!!	setCastlingMove(inout castlingMove : boolean) : void
		this.castlingMove = castlingMove;
!!!1777794.java!!!	getPredicate() : String
		return predicate;
!!!1777922.java!!!	setPredicate(in predicate : String) : void
		this.predicate = predicate;
		String str[] = this.predicate.split(";");
		predicates = Arrays.asList(str);
!!!1778050.java!!!	returnPredicate() : String
		String pred = predicates.get(0);
		String endPredicate[] = pred.split(":");
		return endPredicate[0];
!!!1778178.java!!!	getPredicates() : List<String>
		return predicates;
!!!1778306.java!!!	setPredicates(inout predicates : List<String>) : void
		this.predicates = predicates;
!!!752642.java!!!	getOntologyPositions() : Position
		return ontologyPositions;
!!!1778434.java!!!	getCastlePositions() : Position
		return castlePositions;
!!!1778562.java!!!	setCastlePositions(inout castlePositions : HashMap<String, Position>) : void
		this.castlePositions = castlePositions;
!!!1796482.java!!!	getBishopPositions() : Position
		return bishopPositions;
!!!1796610.java!!!	setBishopPositions(inout bishopPositions : HashMap<String, Position>) : void
		this.bishopPositions = bishopPositions;
!!!752770.java!!!	setOntologyPositions(inout ontologyPositions : HashMap<String, Position>) : void
		this.ontologyPositions = ontologyPositions;
		determinePieceType();
		myValue = new Integer(getValue());
!!!2019842.java!!!	getMyValue() : Integer
		return myValue;
!!!2019970.java!!!	setMyValue(inout myValue : Integer) : void
		this.myValue = myValue;
!!!1778690.java!!!	getNofMoves() : int
		return nofMoves;
!!!1778818.java!!!	setNofMoves(in nofMoves : int) : void
		this.nofMoves = this.nofMoves + 1;
!!!1778946.java!!!	getMoveNumbers() : List<Integer>
		return moveNumbers;
!!!1779074.java!!!	setMoveNumbers(inout moveNumbers : List<Integer>) : void
		this.moveNumbers = moveNumbers;
!!!752898.java!!!	isActive() : boolean
		return active;
!!!965122.java!!!	getRemovedPositions() : Position
		return removedPositions;
!!!965250.java!!!	setRemovedPositions(inout removedPositions : List<Position>) : void
		this.removedPositions = removedPositions;
!!!1989890.java!!!	checkFriend(inout pos : Position) : boolean
		boolean removed = false;
		String posName = pos.getPositionName();
		if (removedPositions != null) {
			for (Position position:removedPositions) {
				if (pos == position) {
					if(pos.isInUse()) {
						AgamePiece piece = pos.getUsedBy().getMyPiece();
						if(piece.getPieceColor() == this.getPieceColor()){
							removed = false;
							break;
						}
					}
					removed = true;
					break;
				}

			}
		}

		return removed;
!!!965378.java!!!	checkRemoved(inout pos : Position) : boolean
		boolean removed = false;
		String posName = pos.getPositionName();
		if (removedPositions != null) {
			for (Position position:removedPositions) {
				String pName = position.getPositionName();
				if (pos == position) {
					removed = true;
					break;
				}
				if (posName.equals(pName)) {
					removed = true;
					break;
				}
			}
		}

		return removed;
!!!753026.java!!!	setActive(inout active : boolean) : void
		this.active = active;
!!!753154.java!!!	restoreValue() : void
		value = orgValue;
!!!753282.java!!!	getLocalColor() : AbstractGamePiece::pieceColor
		return localColor;
!!!753410.java!!!	setLocalColor(inout localColor : AbstractGamePiece::pieceColor) : void
		this.localColor = localColor;
!!!753538.java!!!	getChessType() : ChessPieceType
		return chessType;
!!!753666.java!!!	setChessType(inout chessType : ChessPieceType) : void
		this.chessType = chessType;
!!!753794.java!!!	checkBlack() : boolean
		return localColor == pieceColor.BLACK;
!!!753922.java!!!	checkWhite() : boolean
		return localColor == pieceColor.WHITE;
!!!965506.java!!!	getAttackPositions() : Position
		return attackPositions;
!!!965634.java!!!	setAttackPositions(inout attackPositions : HashMap<String, Position>) : void
		this.attackPositions = attackPositions;
!!!2069762.java!!!	getMyPawn() : APawn
		return myPawn;
!!!2069890.java!!!	setMyPawn(inout myPawn : APawn) : void
		this.myPawn = myPawn;
!!!754050.java!!!	createPosition(inout newPositions : HashMap<String,Position>) : void
//		XYLocation newloc = new XYLocation(x,y);
		List<Position> tempPositions = new ArrayList(newPositions.values());
		for (Position pos : tempPositions) {
			String name = pos.getPositionName();
			Position ontPosition = ontologyPositions.get(name);
			if (ontPosition != null) {
				newPositions.put(name, ontPosition);
			}
		}

!!!754178.java!!!	determinMytype() : void
		ChessPieceType king = new Aking();
		king.test(this);
		
		
!!!1834754.java!!!	giveNewdirections() : void
		if (myType == myType.BISHOP || myType == myType.QUEEN) {
			calculateDirections();
		}
		if (myType == myType.ROOK || myType == myType.QUEEN) {
			calculatenorthSouth();
		}
!!!1834882.java!!!	calculateDirections() : void
		XYLocation myLocation = myPosition.getXyloc();
		northWest.clear();
		northEast.clear();
		southWest.clear();
		southEast.clear();
		int ocol = myLocation.getXCoOrdinate();
		int orow = myLocation.getYCoOrdinate();
		int col = ocol; int row = orow;
		boolean nWest = col > 0 && row < 7;
		while (nWest) {
			col--;row++;
			XYLocation nwest = new XYLocation(col,row);
			northWest.add(nwest);
			nWest = col > 0 && row < 7;
		}
		col = ocol;row = orow;
		boolean nEast = col < 7 && row < 7;
		while (nEast) {
			col++;row++;
			XYLocation neast = new XYLocation(col,row);
			northEast.add(neast);
			nEast = col < 7 && row < 7;
		}
		col = ocol;row = orow;
		boolean sw = col > 0 && row > 0;
		while(sw) {
			col--;row--;
			XYLocation swest = new XYLocation(col,row);
			southWest.add(swest);
			sw = col > 0 && row > 0;
		}
		col = ocol;row = orow;
		boolean se = col < 7 && row > 0;
		while(se) {
			col++;row--;
			XYLocation seast = new XYLocation(col,row);
			southEast.add(seast);
			se = col < 7 && row > 0;
		}
		
!!!1990018.java!!!	calculatenorthSouth() : void
		XYLocation myLocation = myPosition.getXyloc();
		north.clear();
		east.clear();
		west.clear();
		south.clear();
		int ocol = myLocation.getXCoOrdinate();
		int orow = myLocation.getYCoOrdinate();
		int col = ocol; int row = orow;
		boolean wwest = col > 0;
		while (wwest) {
			col--;
			XYLocation wxwest = new XYLocation(col,row);
			west.add(wxwest);
			wwest = col > 0;
		}
		col = ocol;row = orow;
		boolean eest = col < 7;
		while (eest) {
			col++;
			XYLocation wxwest = new XYLocation(col,row);
			east.add(wxwest);
			eest = col < 7;
		}
		col = ocol;row = orow;
		boolean nnorth = row < 7;
		while (nnorth) {
			row++;
			XYLocation nxnorth = new XYLocation(col,row);
			north.add(nxnorth);
			nnorth = row < 7;
		}
		col = ocol;row = orow;
		boolean ssouth = row > 0;
		while (ssouth) {
			row--;
			XYLocation sxsouth = new XYLocation(col,row);
			south.add(sxsouth);
			ssouth = row > 0;
		}		
!!!754306.java!!!	determinePieceType() : void
		String name = myPiece.getPieceName();
		color = myPiece.getColor();
		if (color.equals("w"))
			localColor = pieceColor.WHITE;
		else
			localColor = pieceColor.BLACK;
		GamePiece gamePiece = null;
		switch(name) {
		
			case "P":
				myType = pieceType.PAWN;
				chessType = new APawn(myPosition,myPiece);
				APawn pawn = (APawn) chessType;
				nameType = pawn.getChesstype();
				myPawn = pawn;
				value = myPawn.getValue();
//				pawn.setMother(this);
				attackPositions = pawn.getAttackPositions();
				gamePiece = (GamePiece) chessType;
				reacablePositions = gamePiece.getNewPositions();
				createPosition(reacablePositions); // To replace created positions with ontology positions
				gamePiece.setOntologyPositions(ontologyPositions);
				newlistPositions = new ArrayList(reacablePositions.values());
				break;
			case"B":	
				myType = pieceType.BISHOP;
				chessType = new ABishop(myPosition,myPiece);
				String pieceColorB = myPiece.getColor();
				gamePiece = (GamePiece) chessType;
				ABishop bishop = (ABishop) chessType;
				nameType = bishop.getChesstype();
				mybishop = bishop;
				value = mybishop.getValue();
				reacablePositions = gamePiece.getNewPositions();
				createPosition(reacablePositions); // To replace created positions with ontology positions
				gamePiece.setOntologyPositions(ontologyPositions);
//				reacablePositions = chessType.getNewPositions();
				newlistPositions = new ArrayList(reacablePositions.values());
				calculateDirections();
/*				for (Position pos:newlistPositions) {
					System.out.println(pieceColorB+" Bishop positions: "+pos.getPositionName() + " " + pos.getPositionColor());
				}*/
				break;	
			case "N":
				myType = pieceType.KNIGHT;
				chessType = new AKnight(myPosition,myPiece);
				String pieceColorK = myPiece.getColor();
				gamePiece = (GamePiece) chessType;
				AKnight knight = (AKnight) chessType;
				nameType = knight.getChesstype();
				myKnight = knight;
				value = myKnight.getValue();
				reacablePositions = gamePiece.getNewPositions();
				createPosition(reacablePositions); // To replace created positions with ontology positions
				gamePiece.setOntologyPositions(ontologyPositions);
//				reacablePositions = chessType.getNewPositions();
				newlistPositions = new ArrayList(reacablePositions.values());
/*				for (Position pos:newlistPositions) {
					System.out.println("Knight positions: "+pos.getPositionName() + " " + pos.getPositionColor());
				}	*/
				break;
			case "K":
				myType = pieceType.KING;
				chessType = new Aking(myPosition,myPiece);
				gamePiece = (GamePiece) chessType;
				Aking king = (Aking) chessType;
				nameType = king.getChesstype();
				myKing = king;
				value = myKing.getValue();
				reacablePositions = gamePiece.getNewPositions();
				createPosition(reacablePositions); // To replace created positions with ontology positions
				gamePiece.setOntologyPositions(ontologyPositions);
//				reacablePositions = chessType.getNewPositions();
				newlistPositions = new ArrayList(reacablePositions.values());
				if (nofMoves == 0) {
					king.makeCastlemove();
					castlePositions = king.getCastlePositions();
				}
/*				for (Position pos:newlistPositions) {
					System.out.println("King positions: "+pos.getPositionName() + " " + pos.getPositionColor());
				}*/
				break;
			case "R":
				myType = pieceType.ROOK;
				chessType = new ARook(myPosition,myPiece);
				String pieceColorR = myPiece.getColor();
				gamePiece = (GamePiece) chessType;
				ARook rook = (ARook) chessType;
				nameType = rook.getChesstype();
				myrook = rook;
				value = myrook.getValue();
				reacablePositions = gamePiece.getNewPositions();
				createPosition(reacablePositions); // To replace created positions with ontology positions
				gamePiece.setOntologyPositions(ontologyPositions);
				if (nofMoves == 0) {
					rook.makeCastlemove();
					castlePositions = rook.getCastlePositions();
				}				
//				reacablePositions = chessType.getNewPositions();
				newlistPositions = new ArrayList(reacablePositions.values());
				calculatenorthSouth();
/*				for (Position pos:newlistPositions) {
					System.out.println(pieceColorR+" Rook positions: "+pos.getPositionName() + " " + pos.getPositionColor());
				}*/
				break;
			case "Q":
				myType = pieceType.QUEEN;
				chessType = new AQueen(myPosition,myPiece);
				String pieceColorQ = myPiece.getColor();
				gamePiece = (GamePiece) chessType;
				AQueen queen = (AQueen) chessType;
				nameType = queen.getChesstype();
				myqueen = queen;
				value = myqueen.getValue();
				reacablePositions = gamePiece.getNewPositions(); // Creates two sets of reachable positions: reacablePositions,bishopPositions
				bishopPositions = queen.getBishopPositions();
				createPosition(reacablePositions); // To replace created positions with ontology positions
				createPosition(bishopPositions);
				gamePiece.setOntologyPositions(ontologyPositions);
//				reacablePositions = chessType.getNewPositions();
				newlistPositions = new ArrayList(reacablePositions.values());
				newlistPositions.addAll(bishopPositions.values());
				calculateDirections();
				calculatenorthSouth();
/*				for (Position pos:newlistPositions) {
					System.out.println(pieceColorQ+" Queens positions: "+pos.getPositionName() + " " + pos.getPositionColor());
				}*/				
				break;
			default:
				myType = pieceType.PAWN;
				break;
		}
!!!2000130.java!!!	clearfriendPositions() : void
		if (myType == pieceType.QUEEN) {
			myqueen.getFriendPositions().clear();
		}
		if (myType == pieceType.ROOK) {
			myrook.getFriendPositions().clear();
		}
		if (myType == pieceType.BISHOP) {
			mybishop.getFriendPositions().clear();
		}
		if (myType == pieceType.KNIGHT) {
			myKnight.getFriendPositions().clear();
		}
!!!2000258.java!!!	determinFriendPosition(inout pos : Position) : void
		if (myType == pieceType.QUEEN) {
			//AQueen queen = (AQueen) chessType;
			String name = pos.getPositionName();
			HashMap<String,Position> friendly = myqueen.getFriendPositions();
			friendly.put(name, pos);
		}
		if (myType == pieceType.ROOK) {
			//AQueen queen = (AQueen) chessType;
			String name = pos.getPositionName();
			HashMap<String,Position> friendly = myrook.getFriendPositions();
			friendly.put(name, pos);
		}
		if (myType == pieceType.BISHOP) {
			//AQueen queen = (AQueen) chessType;
			String name = pos.getPositionName();
			HashMap<String,Position> friendly = mybishop.getFriendPositions();
			friendly.put(name, pos);
		}
		if (myType == pieceType.KNIGHT) {
			String name = pos.getPositionName();
			HashMap<String,Position> friendly = myKnight.getFriendPositions();
			friendly.put(name, pos);
		}
!!!2000386.java!!!	removeFriendPosition(inout pos : Position) : void
		if (myType == pieceType.QUEEN) {
			//AQueen queen = (AQueen) chessType;
			String name = pos.getPositionName();
			HashMap<String,Position> friendly = myqueen.getFriendPositions();
			friendly.remove(name);
		}
		if (myType == pieceType.ROOK) {
			//AQueen queen = (AQueen) chessType;
			String name = pos.getPositionName();
			HashMap<String,Position> friendly = myrook.getFriendPositions();
			friendly.remove(name);
		}
		if (myType == pieceType.BISHOP) {
			//AQueen queen = (AQueen) chessType;
			String name = pos.getPositionName();
			HashMap<String,Position> friendly = mybishop.getFriendPositions();
			friendly.remove(name);
		}
!!!2000514.java!!!	checkFriendlyPosition(inout pos : Position) : boolean
		String name = pos.getPositionName();
		boolean friendpos = false;
		if (myType == pieceType.QUEEN) {
			HashMap<String,Position> friendly = myqueen.getFriendPositions();
			friendpos = friendly.containsKey(name);
		}
		if (myType == pieceType.ROOK) {
			HashMap<String,Position> friendly = myrook.getFriendPositions();
			friendpos = friendly.containsKey(name);
		}
		if (myType == pieceType.BISHOP) {
			HashMap<String,Position> friendly = mybishop.getFriendPositions();
			friendpos = friendly.containsKey(name);
		}
		if (myType == pieceType.KNIGHT) {
			HashMap<String,Position> friendly = myKnight.getFriendPositions();
			friendpos = friendly.containsKey(name);
		}
		if (myType == pieceType.KING) {
			friendpos = true;
		}
		return friendpos;
!!!754434.java!!!	getPreferredPositions() : Position
		return preferredPositions;
!!!754562.java!!!	setPreferredPositions(inout preferredPositions : List<Position>) : void
		this.preferredPositions = preferredPositions;
!!!754690.java!!!	getLegalmoves() : Position
			return (HashMap<String, Position>) reacablePositions;
!!!754818.java!!!	getmyPosition() : Position
		return (Position) myPosition;
		
!!!754946.java!!!	getMyPosition() : Position
		return myPosition;
!!!755074.java!!!	setMyPosition(inout newPosition : Position) : void
		if (this.myPosition != null) {
			heldPositions.push(this.myPosition);
			this.heldPosition = myPosition;
		}
		this.myPosition = newPosition;
!!!1958274.java!!!	settempMyposition(inout newPosition : Position) : void
		this.myPosition = newPosition;
!!!755202.java!!!	setMypositionEmpty(inout position : Position) : void
		heldPosition = myPosition;
		myPosition = position;
		if (myPosition == null && heldPosition == null) {
			System.out.println("Both positions empty !!--");
		}
!!!755330.java!!!	restorePosition() : void
/*		if (active && heldPositions != null) {
			heldPositions.clear();
		}*/
		if (heldPositions != null && !heldPositions.isEmpty())
			this.myPosition = heldPositions.pop();
		if (myPosition != null) // Added 1.08.20
			active = true;
		
//		myPosition = heldPosition;
!!!755458.java!!!	getHeldPosition() : Position
		if (heldPosition == null && heldPositions == null)
			return null;
		if (heldPosition == null && heldPositions.isEmpty())
			return null;
		if (!heldPositions.isEmpty())
			heldPosition = heldPositions.pop();
		return heldPosition;
!!!755586.java!!!	setHeldPosition(inout heldPosition : Position) : void
		this.heldPosition = heldPosition;
		if (heldPosition == null) {
			heldPositions.clear();
		}
		if (heldPosition != null) {
			heldPositions.push(heldPosition);
		}
!!!755714.java!!!	getMyPiece() : ChessPiece
		return myPiece;
!!!755842.java!!!	setMyPiece(inout myPiece : ChessPiece) : void
		this.myPiece = myPiece;
!!!755970.java!!!	getPieceType() : AbstractGamePiece::pieceType
		
		return myType;
!!!756098.java!!!	getColor() : String
		return color;
!!!756226.java!!!	setColor(in color : String) : void
		this.color = color;
!!!756354.java!!!	getMyType() : AbstractGamePiece::pieceType
		return myType;
!!!756482.java!!!	setMyType(inout myType : AbstractGamePiece::pieceType) : void
		this.myType = myType;
!!!756610.java!!!	getReacablePositions() : Position
		return reacablePositions;
!!!756738.java!!!	setReacablePositions(inout reacablePositions : HashMap<String, Position>) : void
		this.reacablePositions = reacablePositions;
!!!965762.java!!!	setNewlistPositions(inout newPositions : ArrayList<Position>) : void
		this.newlistPositions = newPositions;
!!!965890.java!!!	getNewlistPositions() : Position
		return newlistPositions;
!!!756994.java!!!	toString() : String
		StringBuilder result = new StringBuilder();
		String posName = "Removed!!!";
		XYLocation localXY = new XYLocation(0,0);
		String pActive = " Active";
		if (!active)
			pActive = " Taken!!!";
		if (myPosition != null) {
			posName = myPosition.getPositionName();
			localXY = myPosition.getXyloc();
		}
		
		result.append("Piece position "+posName + " X, Y "+localXY.toString()  + " "+myPiece.getName()+ " "+myPiece.getPosition().toString()+" "+ myType+pActive);
	
		String na = myPiece.getPieceName();
		result.append("Name " + na + "\n" + "Available positions\n");
		for (Position pos:newlistPositions) {
			result.append("Position: "+pos.getPositionName() + " " + pos.getPositionColor() + " X, Y "+pos.getXyloc().toString() );
			if (pos.isInUse()) {
				result.append(" Occupied by: "+pos.getUsedBy().getOntlogyName() + "\n");
			}else {
				result.append("\n");
			}
		}
		result.append("Removed positions\n");
		if (removedPositions != null && !removedPositions.isEmpty()) {
			for (Position pos:removedPositions) {
				result.append("Position: "+pos.getPositionName() + " " + pos.getPositionColor() + " X, Y "+pos.getXyloc().toString());
				if (pos.isInUse()) {
					result.append(" Occupied by: "+pos.getUsedBy().getOntlogyName() + "\n");
				}else {
					result.append("\n");
				}

			}	
		}
		result.append("Northwest positions\n");
		if (northWest != null && !northWest.isEmpty()) {
			for (XYLocation pos:northWest) {
				result.append(" X, Y "+pos.toString());
				}

		}	
		result.append("\nNortheast positions\n");
		if (northEast != null && !northEast.isEmpty()) {
			for (XYLocation pos:northEast) {
				result.append(" X, Y "+pos.toString());
				}

		}
		result.append("\nSoutheast positions\n");
		if (southEast != null && !southEast.isEmpty()) {
			for (XYLocation pos:southEast) {
				result.append(" X, Y "+pos.toString());
				}

		}	
		result.append("\nSouthwest positions\n");
		if (southWest != null && !southWest.isEmpty()) {
			for (XYLocation pos:southWest) {
				result.append(" X, Y "+pos.toString());
				}

		}	
		result.append("\nSouth positions\n");
		if (south != null && !south.isEmpty()) {
			for (XYLocation pos:south) {
				result.append(" X, Y "+pos.toString());
				}

		}
		result.append("\nNorth positions\n");
		if (north != null && !north.isEmpty()) {
			for (XYLocation pos:north) {
				result.append(" X, Y "+pos.toString());
				}

		}
		result.append("\nWest positions\n");
		if (west != null && !west.isEmpty()) {
			for (XYLocation pos:west) {
				result.append(" X, Y "+pos.toString());
				}

		}
		result.append("\nEast positions\n");
		if (east != null && !east.isEmpty()) {
			for (XYLocation pos:east) {
				result.append(" X, Y "+pos.toString());
				}

		}
		if(castlePositions != null && !castlePositions.isEmpty() && (myType == myType.KING || myType == myType.ROOK) && nofMoves == 0) {
			List<Position> castle = new ArrayList(castlePositions.values());
			result.append("\ncastle positions\n");
			for (Position pos:castle) {
				result.append("Position: "+pos.getPositionName() + " " + pos.getPositionColor() + " X, Y "+pos.getXyloc().toString());
				if (pos.isInUse()) {
					result.append(" Occupied by: "+pos.getUsedBy().getOntlogyName() + "\n");
				}else {
					result.append("\n");
				}
			}
		}
	
		return result.toString();
!!!757122.java!!!	test(inout piece : GamePiece) : boolean
		// TODO Auto-generated method stub
		return false;
!!!757250.java!!!	checkName(in name : String) : boolean
		// TODO Auto-generated method stub
		return false;
!!!757378.java!!!	getLegalmoves(inout position : Position) : void
		AgamePiece localpiece = (AgamePiece) chessType;
		localpiece.setMyPosition(position);
		localpiece.produceLegalmoves(position);
		reacablePositions = localpiece.getNewPositions();
//		reacablePositions =  chessType.getNewPositions();
		newlistPositions = null;
		newlistPositions = new ArrayList(reacablePositions.values());
//		newlistPositions =  (List<Position>) reacablePositions.values();
!!!757506.java!!!	produceLegalmoves(inout position : Position) : void

		if (chessType instanceof APawn) {
			APawn p = (APawn) chessType;
			p.produceLegalmoves(position);
			attackPositions = p.getAttackPositions();
		}
		if (chessType instanceof AKnight) {
			AKnight p = (AKnight) chessType;
			p.produceLegalmoves(position);
		}
		if (chessType instanceof ARook) {
			ARook p = (ARook) chessType;
			p.produceLegalmoves(position);
		}	
		if (chessType instanceof ABishop) {
			ABishop p = (ABishop) chessType;
			p.produceLegalmoves(position);
		}
		if (chessType instanceof AQueen) {
			AQueen p = (AQueen) chessType;
			p.produceLegalmoves(position);
		}
		if (chessType instanceof Aking) {
			Aking p = (Aking) chessType;
			p.produceLegalmoves(position);
		}

/*		Optional<ARook> r = Optional.ofNullable((ARook) chessType);
		Optional<AKnight> n = Optional.ofNullable((AKnight) chessType);
		Optional<AQueen> q = Optional.ofNullable((AQueen) chessType);
		Optional<Aking> k = Optional.ofNullable((Aking) chessType);*/
/*		Optional<APawn> p = Optional.ofNullable(ChessFunctions.findpieceType(localpiece,(APawn piece) -> piece.getPieceType() == pieceType.PAWN));
		ABishop b = ChessFunctions.findpieceType(localpiece,(AgamePiece piece) -> piece.getPieceType() == pieceType.BISHOP);
		ARook r = ChessFunctions.findpieceType(localpiece,(AgamePiece piece) -> piece.getPieceType() == pieceType.ROOK);
		AKnight n = ChessFunctions.findpieceType(localpiece,(AgamePiece piece) -> piece.getPieceType() == pieceType.KNIGHT);
		AQueen q = ChessFunctions.findpieceType(localpiece,(AgamePiece piece) -> piece.getPieceType() == pieceType.QUEEN);
		Aking k = ChessFunctions.findpieceType(localpiece,(AgamePiece piece) -> piece.getPieceType() == pieceType.KING);
		if (k != null)
			k.produceLegalmoves(position);*/
		GamePiece gamePiece = (GamePiece) chessType;
		reacablePositions = gamePiece.getNewPositions();	
//		reacablePositions =  chessType.getNewPositions();
		newlistPositions = null;
		newlistPositions = new ArrayList(reacablePositions.values());
		if (bishopPositions != null)
			newlistPositions.addAll(bishopPositions.values()); // In case of queen olj 05.10.21
!!!757634.java!!!	checkPositions() : boolean
		boolean newPos = false;
		if (newlistPositions == null || newlistPositions.isEmpty()) {
			newlistPositions = null;
			newlistPositions = new ArrayList(reacablePositions.values());
			newPos = true;
		}
		return newPos;
!!!757762.java!!!	getPieceColor() : AbstractGamePiece::pieceColor
		// TODO Auto-generated method stub
		return null;
!!!757890.java!!!	getNewPositions() : Position
		
		return reacablePositions;
