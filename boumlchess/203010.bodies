class Ellipse2D
!!!529538.java!!!	Ellipse2D(inout center : Point2D, in rx : double, in ry : double)
		this.center = center;
		this.horizontal = new Vector2D(rx,0.0d);
		this.horizontalLength = rx;
		this.vertical = new Vector2D(0.0d,ry);
		this.verticalLength = ry;
		this.angle = 0.0d;
		this.transform = TransformMatrix2D.UNITY_MATRIX;
		this.transformInverse = TransformMatrix2D.UNITY_MATRIX;
!!!529666.java!!!	Ellipse2D(inout center : Point2D, inout horizontal : Vector2D, inout vertical : Vector2D)
		this.center = center;
		if(Util.compareDoubles(horizontal.getX(),0.0d) && Util.compareDoubles(vertical.getY(),0.0d)) {
			this.horizontal = vertical;
			this.vertical = horizontal;
		} else {
			this.horizontal = horizontal;
			this.vertical = vertical;
		}
		this.horizontalLength = this.horizontal.length();
		this.verticalLength = this.vertical.length();
		if(Util.compareDoubles(this.horizontal.getY(),0.0d) && Util.compareDoubles(this.vertical.getX(),0.0d)) {
			this.angle = 0.0d;
			this.transform = TransformMatrix2D.UNITY_MATRIX;
			this.transformInverse = TransformMatrix2D.UNITY_MATRIX;
		} else {
			if(Util.compareDoubles(this.horizontal.getX(),0.0d)) {
				this.angle = Vector2D.Y_VECTOR.angleTo(this.vertical);
			} else {
				this.angle = Vector2D.X_VECTOR.angleTo(this.horizontal);
			}
			TransformMatrix2D result = TransformMatrix2D.translate(center.getX(), center.getY());
			result = result.multiply(TransformMatrix2D.rotate(-this.angle));
			this.transform = result.multiply(TransformMatrix2D.translate(-center.getX(), -center.getY()));
			this.transformInverse = this.transform.inverse();
		}
!!!529794.java!!!	getCenter() : Point2D
		return center;
!!!529922.java!!!	getHorizontalLength() : double
		return horizontalLength;
!!!530050.java!!!	getVerticalLength() : double
		return verticalLength;
!!!530178.java!!!	getAngle() : double
		return angle;
!!!530306.java!!!	randomPoint() : Point2D
		final double x = Util.generateRandomDoubleBetween(-horizontalLength,horizontalLength);
		final double delta = Math.abs(verticalLength*Math.sin(Math.acos(x/horizontalLength)));
		final double y = Util.generateRandomDoubleBetween(-delta, delta);
		return transformInverse.multiply(new Point2D(center.getX()+x,center.getY()+y));
!!!530434.java!!!	isInside(inout point : Point2D) : boolean
		Point2D transformedPoint = transform.multiply(point);
		if(center.getX()-horizontalLength < transformedPoint.getX() && center.getX()+horizontalLength > transformedPoint.getX()) {
			final double delta = Math.abs(verticalLength*Math.sin(Math.acos((transformedPoint.getX() - center.getX())/horizontalLength)));
			return transformedPoint.getY() < center.getY() + delta && transformedPoint.getY() > center.getY() - delta;
		} else {
			return false;
		}
!!!530562.java!!!	isInsideBorder(inout point : Point2D) : boolean
		Point2D transformedPoint = transform.multiply(point);
		if((center.getX()-horizontalLength < transformedPoint.getX() || Util.compareDoubles(transformedPoint.getX(), center.getX()-horizontalLength)) && (center.getX()+horizontalLength > transformedPoint.getX() || Util.compareDoubles(transformedPoint.getX(), center.getX()+horizontalLength))) {
			final double delta = Math.abs(verticalLength*Math.sin(Math.acos((transformedPoint.getX() - center.getX())/horizontalLength)));
			return (transformedPoint.getY() < center.getY() + delta || Util.compareDoubles(transformedPoint.getY(), center.getY() + delta)) && (transformedPoint.getY() >= center.getY() - delta  || Util.compareDoubles(transformedPoint.getY(), center.getY() - delta));
		}
		return false;
!!!530690.java!!!	rayCast(inout ray : Ray2D) : double
		final Ray2D transformedRay = ray.transform(transform);
		final double squaredHorizontal = horizontalLength*horizontalLength;
		final double squaredVertical = verticalLength*verticalLength;
		final double squaredDirectionX = transformedRay.getDirection().getX()*transformedRay.getDirection().getX();
		final double divisor = squaredHorizontal*transformedRay.getDirection().getY()*transformedRay.getDirection().getY()+squaredVertical*squaredDirectionX;
		if(Util.compareDoubles(divisor,0.0d)) return Double.POSITIVE_INFINITY;
		final double squareRoot = Math.sqrt(squaredHorizontal*squaredVertical*(squaredDirectionX*(squaredVertical-center.getY()*center.getY()+transformedRay.getStart().getY()*(2*center.getY()-transformedRay.getStart().getY()))+transformedRay.getDirection().getY()*(transformedRay.getDirection().getY()*(squaredHorizontal-center.getX()*center.getX()+transformedRay.getStart().getX()*(2*center.getX()-transformedRay.getStart().getX()))+2*transformedRay.getDirection().getX()*(transformedRay.getStart().getX()*(transformedRay.getStart().getY()-center.getY())+center.getX()*(center.getY()-transformedRay.getStart().getY())))));
		if(Util.compareDoubles(squareRoot,Double.NaN)) return Double.POSITIVE_INFINITY;
		final double tmpFactor1 = squaredVertical*transformedRay.getDirection().getX();
		final double tmpFactor2 = squaredHorizontal*transformedRay.getDirection().getY();
		final double factors = tmpFactor1*center.getX() - tmpFactor1*transformedRay.getStart().getX() + tmpFactor2*center.getY() - tmpFactor2*transformedRay.getStart().getY();
		final double result = (factors-Math.abs(squareRoot))/divisor;
		if(result >= 0) {
			final Point2D intersection = transformedRay.getStart().add(transformedRay.getDirection().multiply(result));
			return transformInverse.multiply(intersection).vec(ray.getStart()).length();
		}
		return Double.POSITIVE_INFINITY;
!!!530818.java!!!	getBounds() : Rect2D
		final double cosAngle = Math.cos(angle);
		final double sinAngle = Math.sin(angle);
		final double boundX = Math.sqrt(horizontalLength*horizontalLength*cosAngle*cosAngle+verticalLength*verticalLength*sinAngle*sinAngle);
		final double boundY = Math.sqrt(horizontalLength*horizontalLength*sinAngle*sinAngle+verticalLength*verticalLength*cosAngle*cosAngle);
		return new Rect2D(center.getX()-boundX, center.getY()-boundY, center.getX()+boundX, center.getY()+boundY);
!!!530946.java!!!	transform(inout matrix : TransformMatrix2D) : IGeometric2D
		final Point2D centerNew = matrix.multiply(center);
		final Vector2D  horizontalNew = centerNew.vec(matrix.multiply(center.add(horizontal))),
						verticalNew = centerNew.vec(matrix.multiply(center.add(vertical)));
		final double radiusHorizontalNew = horizontalNew.length();
		final double radiusVerticalNew = verticalNew.length();
		if(Util.compareDoubles(radiusHorizontalNew,radiusVerticalNew)) {
			//Transform let this ellipse become a circle.
			return new Circle2D(centerNew,radiusHorizontalNew);
		}
		return new Ellipse2D(centerNew,horizontalNew,verticalNew);
