class Level
!!!352770.java!!!	Level(inout prevLevel : Level, inout problem : Problem)
        this.prevLevel = prevLevel;
        this.problem = problem;
        if (prevLevel != null) {
            HashMap<Object, List<Object>> linksFromPreviousLevel = prevLevel.getNextLinks();
            this.problem = problem;
            levelObjects = new ArrayList<>();
            prevLinks = new HashMap<>();
            for (Object node :
                    linksFromPreviousLevel.keySet()) {
                List<Object> thisLevelObjects = linksFromPreviousLevel.get(node);
                for (Object nextNode :
                        thisLevelObjects) {
                    if (levelObjects.contains(nextNode)) {
                        List<Object> tempPrevLink = prevLinks.get(nextNode);
                        tempPrevLink.add(node);
                        prevLinks.put(nextNode, tempPrevLink);
                    } else {
                        levelObjects.add(nextNode);
                        prevLinks.put(nextNode, new ArrayList<>(Collections.singletonList(node)));
                    }

                }

            }
            addNoPrecondActions();
            calculateNextLinks();
            calculateMutexLinks(prevLevel);
        } else {
            levelObjects = new ArrayList<>();
            prevLinks = new HashMap<>();
            levelObjects.addAll(problem.getInitialState().getFluents());
            for (Object obj :
                    levelObjects) {
                prevLinks.put(obj, new ArrayList<>());
            }
            addNoPrecondActions();
            calculateNextLinks();
            calculateMutexLinks(null);
        }
        addPersistentActions();
!!!352898.java!!!	Level(inout prevLevel : Level, inout problem : Problem, in extraLiterals : String)
        this(prevLevel, problem);
        this.addExtraLiterals(extraLiterals);
!!!353026.java!!!	addExtraLiterals(in s : String) : void
        for (Literal literal :
                Utils.parse(s)) {
            if(!levelObjects.contains(literal)){
                levelObjects.add(literal);
            }
        }
        calculateNextLinks();
        calculateMutexLinks(getPrevLevel());
        addPersistentActions();
!!!353154.java!!!	getLevelObjects() : List<Object>
        return levelObjects;
!!!353282.java!!!	getMutexLinks() : HashMap<Object, List<Object>>
        return mutexLinks;
!!!353410.java!!!	getNextLinks() : HashMap<Object, List<Object>>
        return nextLinks;
!!!353538.java!!!	getPrevLinks() : HashMap<Object, List<Object>>
        return prevLinks;
!!!353666.java!!!	getProblem() : Problem
        return problem;
!!!353794.java!!!	addPersistentActions() : void
       if(getLevelObjects().get(0) instanceof Literal) {
           for (Object literal :
                   getLevelObjects()) {
               ActionSchema action = new ActionSchema("No-op", null,
                       Collections.singletonList((Literal) literal),
                       Collections.singletonList((Literal) literal));
               addToHashMap(literal, action, nextLinks);
           }
       }
!!!353922.java!!!	addNoPrecondActions() : void
        if(getLevelObjects().get(0) instanceof ActionSchema){
            for (ActionSchema action :
                    problem.getPropositionalisedActions()) {
                if (action.getPrecondition().size()==0)
                    levelObjects.add(action);
            }
        }
!!!354050.java!!!	calculateMutexLinks(inout prevLevel : Level) : void
        mutexLinks = new HashMap<>();
        if(prevLevel == null) return;
        if (levelObjects.get(0) instanceof Literal) {
            Literal firstLiteral, secondLiteral;
            List<Object> possibleActionsFirst, possibleActionsSecond;
            for (int i = 0; i < levelObjects.size(); i++) {
                firstLiteral = (Literal) levelObjects.get(i);
                possibleActionsFirst = prevLinks.get(firstLiteral);
                for (int j = i; j < levelObjects.size(); j++) {
                    secondLiteral = (Literal) levelObjects.get(j);
                    possibleActionsSecond = prevLinks.get(secondLiteral);
                    if (firstLiteral.getAtomicSentence().getSymbolicName().equals(
                            secondLiteral.getAtomicSentence().getSymbolicName()) &&
                            ((firstLiteral.isNegativeLiteral() && secondLiteral.isPositiveLiteral()) ||
                                    firstLiteral.isPositiveLiteral() && secondLiteral.isNegativeLiteral()
                            )) {

                        addToHashMap(firstLiteral, secondLiteral, mutexLinks);
                        addToHashMap(secondLiteral, firstLiteral, mutexLinks);
                    } else {
                        boolean eachPossiblePairExclusive = true;
                        HashMap<Object, List<Object>> prevMutexes = prevLevel.getMutexLinks();
                        for (Object firstAction :
                                possibleActionsFirst) {
                            for (Object secondAction :
                                    possibleActionsSecond) {
                                if ((!prevMutexes.containsKey(firstAction))||(!prevMutexes.get(firstAction).contains(secondAction))) {
                                    eachPossiblePairExclusive = false;
                                }
                            }
                        }
                        if (eachPossiblePairExclusive) {
                            addToHashMap(firstLiteral, secondLiteral, mutexLinks);
                            addToHashMap(secondLiteral, firstLiteral, mutexLinks);
                        }
                    }
                }
            }
        } else if (levelObjects.get(0) instanceof ActionSchema) {
            ActionSchema firstAction, secondAction;
            boolean checkMutex;

            for (int i = 0; i < levelObjects.size(); i++) {
                firstAction = (ActionSchema) levelObjects.get(i);
                List<Literal> firstActionEffects = firstAction.getEffects();
                List<Literal> firstActionPositiveEffects = firstAction.getEffectsPositiveLiterals();
                List<Literal> firstActionPreconditions = firstAction.getPrecondition();
                for (int j = i+1; j < levelObjects.size(); j++) {
                    checkMutex = false;
                    secondAction = (ActionSchema) levelObjects.get(j);
                    List<Literal> secondActionEffects = secondAction.getEffects();
                    List<Literal> secondActionNegatedLiterals = secondAction.getEffectsNegativeLiterals();
                    List<Literal> secondActionPreconditions = secondAction.getPrecondition();
                    for (Literal posLiteral :
                            firstActionPositiveEffects) {
                        for (Literal negatedLit :
                                secondActionNegatedLiterals) {
                            if (posLiteral.equals(new Literal(negatedLit.getAtomicSentence(),false))
                            ) {
                                checkMutex = true;
                            }
                        }
                    }
                    if (!checkMutex) {
                        if (checkInterference(secondActionPreconditions, firstActionEffects)) {
                            checkMutex = true;
                        }
                        if (checkInterference(firstActionPreconditions, secondActionEffects)) {
                            checkMutex = true;
                        }
                    }
                    if (!checkMutex) {
                        HashMap<Object, List<Object>> prevMutex = prevLevel.getMutexLinks();
                        if(prevMutex!=null) {
                            for (Literal firstActionPrecondition :
                                    firstActionPreconditions) {
                                for (Literal secondActionPrecondition :
                                        secondActionPreconditions) {
                                    if (prevMutex.get(firstActionPrecondition) != null && prevMutex.get(firstActionPrecondition).contains(secondActionPrecondition)) {
                                        checkMutex = true;
                                    }
                                }

                            }
                        }
                    }
                    if (checkMutex) {
                        addToHashMap(firstAction, secondAction, mutexLinks);
                        addToHashMap(secondAction, firstAction, mutexLinks);
                    }
                }

            }
        }
!!!354178.java!!!	checkInterference(inout firstActionPreconditions : List<Literal>, inout secondActionEffects : List<Literal>) : boolean
        boolean checkMutex = false;
        for (Literal secondActionEffect :
                secondActionEffects) {
            for (Literal firstActionPrecondition :
                    firstActionPreconditions) {
                if (secondActionEffect.equals(new Literal(firstActionPrecondition.getAtomicSentence(),firstActionPrecondition.isPositiveLiteral())))
                {
                        checkMutex = true;
                }

            }
        }
        return checkMutex;
!!!354306.java!!!	addToHashMap(inout firstObject : Object, inout secondObject : Object, inout map : HashMap<Object, List<Object>>) : void
        List<Object> tempList;
        if (map.containsKey(firstObject)) {
            tempList = map.get(firstObject);
            tempList.add(secondObject);
            map.put(firstObject, tempList);
        } else {
            map.put(firstObject, new ArrayList<>(Collections.singletonList(secondObject)));
        }
!!!354434.java!!!	calculateNextLinks() : void
        nextLinks = new HashMap<>();
        if (levelObjects.get(0) instanceof Literal) {
            for (ActionSchema action :
                    problem.getPropositionalisedActions()) {
                if (levelObjects.containsAll(action.getPrecondition())) {
                    List<Object> nextLevelNodes;
                    for (Literal literal :
                            action.getPrecondition()) {
                        if (nextLinks.containsKey(literal)) {
                            nextLevelNodes = nextLinks.get(literal);
                            nextLevelNodes.add(action);
                        } else {
                            nextLevelNodes = new ArrayList<>(Collections.singletonList(action));
                        }
                        nextLinks.put(literal, nextLevelNodes);
                    }
                }

            }
        } else if (levelObjects.get(0) instanceof ActionSchema) {
            for (Object action :
                    levelObjects) {
                Object[] effects =  ((ActionSchema) action).getEffects().toArray();
                nextLinks.put(action, new ArrayList<>(Arrays.asList(effects)));
            }
        }

!!!354562.java!!!	getPrevLevel() : Level
        return prevLevel;
!!!354690.java!!!	equals(inout obj : Object) : boolean
        if (!(obj instanceof Level))
            return false;
        return this.levelObjects.containsAll(((Level) obj).levelObjects)
                && ((Level) obj).levelObjects.containsAll(this.levelObjects)
                && this.mutexLinks.equals(((Level) obj).mutexLinks)
                && this.nextLinks.equals(((Level) obj).nextLinks)
                && this.prevLinks.equals(((Level) obj).prevLinks);
