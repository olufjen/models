class ChessCombinationGenerator
!!!2012546.java!!!	generateCombinations(inout list : List<T>, in r : int) : Iterable<List<T>>
        return () -> new Iterator<List<T>>() {
            int index = -1;
            int total = (int) ChessCombinationGenerator.nCr(list.size(), r);
            int[] currCombination = new int[r];

            @Override
            public boolean hasNext() {
                index++;
                return index < total;
            }

            @Override
            public List<T> next() {
                if (index == 0) {
                    for (int i = 0; i < currCombination.length; i++) {
                        currCombination[i] = i + 1;
                    }
                } else
                    currCombination = ChessCombinationGenerator.generateNextCombination(currCombination, list.size(), r);
                List<T> result = new ArrayList<>();
                for (int aCurrCombination : currCombination) {
                    result.add(list.get(aCurrCombination - 1));
                }
                return result;
            }
        };
!!!2012674.java!!!	nCr(in n : int, in r : int) : double
        int rfact = 1, nfact = 1, nrfact = 1, temp1 = n - r, temp2 = r;
        if (r > n - r) {
            temp1 = r;
            temp2 = n - r;
        }
        for (int i = 1; i <= n; i++) {
            if (i <= temp2) {
                rfact *= i;
                nrfact *= i;
            } else if (i <= temp1) {
                nrfact *= i;
            }
            nfact *= i;
        }
        return nfact / (double) (rfact * nrfact);
!!!2012802.java!!!	generateNextCombination(inout temp : int [[]], in n : int, in r : int) : int
        int m = r;
        int maxVal = n;
        while (temp[m - 1] == maxVal) {
            m = m - 1;
            maxVal--;
        }
        temp[m - 1]++;
        for (int j = m; j < r; j++) {
            temp[j] = temp[j - 1] + 1;
        }
        return temp;
